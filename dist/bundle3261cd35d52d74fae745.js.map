{"version":3,"file":"bundle3261cd35d52d74fae745.js","mappings":";;;;;;;;;;;;;;;AAAO;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9ZA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,sBAAsB,2BAA2B,oGAAoG,mBAAmB,iBAAiB,sHAAsH;AAC/S,4CAA4C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD;AAC/P,8DAA8D,sEAAsE,8DAA8D,kDAAkD,iBAAiB,GAAG;AACxQ,+BAA+B,uCAAuC;AACtE,qCAAqC,iEAAiE,sCAAsC,0BAA0B,+CAA+C,2CAA2C,uEAAuE;AACvU,kDAAkD,0CAA0C;AAC5F,eAAe,mBAAO,CAAC,yEAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,yGAAmC;AAChE,gBAAgB,mBAAO,CAAC,0CAAO;AAC/B;AACA,qBAAqB,uEAAsB;AAC3C;AACA;AACA,mBAAmB,mBAAO,CAAC,wEAAwB;AACnD,eAAe,mBAAO,CAAC,gEAAoB;AAC3C,0BAA0B,mBAAO,CAAC,kEAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,6FAA6B;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,iBAAiB,OAAO,eAAe,OAAO,eAAe,OAAO,WAAW,OAAO;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sEAAsE,aAAa;AACnF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,6FAA6F,eAAe;AAC5G;AACA;AACA;AACA;AACA;AACA,6FAA6F,eAAe;AAC5G;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,6FAA6F,eAAe;AAC5G;AACA;AACA;AACA;AACA;AACA,6FAA6F,eAAe;AAC5G;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;AC7kBA;AACA;;AAEa;;AAEb,yBAAyB,wBAAwB,oCAAoC,yCAAyC,kCAAkC,0DAA0D,0BAA0B;AACpP,4BAA4B,gBAAgB,sBAAsB,OAAO,kDAAkD,sDAAsD,8BAA8B,mJAAmJ,qEAAqE,KAAK;AAC5a,4CAA4C,2BAA2B,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;AAC/N,kDAAkD,0CAA0C;AAC5F,4CAA4C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD;AAC/P,8DAA8D,sEAAsE,8DAA8D,kDAAkD,iBAAiB,GAAG;AACxQ,+BAA+B,uCAAuC;AACtE,qCAAqC,iEAAiE,sCAAsC,0BAA0B,+CAA+C,2CAA2C,uEAAuE;AACvU,2CAA2C,+DAA+D,6EAA6E,yEAAyE,eAAe,uDAAuD,GAAG,+CAA+C,iBAAiB,GAAG;AAC5Y,iCAAiC,6DAA6D,yCAAyC,8CAA8C,iCAAiC,mDAAmD,2DAA2D,OAAO,yCAAyC;AACpX,kDAAkD,0EAA0E,eAAe,4BAA4B,mFAAmF;AAC1P,wCAAwC,uBAAuB,yFAAyF;AACxJ,mCAAmC,gEAAgE,sDAAsD,+DAA+D,mCAAmC,6EAA6E,qCAAqC,iDAAiD,8BAA8B,qBAAqB,0EAA0E,qDAAqD,eAAe,yEAAyE,GAAG,2CAA2C;AACttB,2CAA2C,mCAAmC,yCAAyC,OAAO,wDAAwD,gBAAgB,uBAAuB,kDAAkD,kCAAkC,uDAAuD,sBAAsB;AAC9X,uCAAuC,wEAAwE,0CAA0C,8CAA8C,MAAM,4EAA4E,IAAI,eAAe,YAAY;AACxT,iCAAiC;AACjC,iCAAiC,0GAA0G,iBAAiB,aAAa;AACzK,8BAA8B,uGAAuG,mDAAmD;AACxL,sBAAsB,2BAA2B,oGAAoG,mBAAmB,iBAAiB,sHAAsH;AAC/S,eAAe,mBAAO,CAAC,0CAAO;AAC9B;AACA,gBAAgB,mBAAO,CAAC,iEAAW;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,sBAAsB,OAAO,WAAW,OAAO,gBAAgB,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa,IAAI,aAAa;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,UAAU,OAAO,WAAW,OAAO;AACnC;AACA;AACA,YAAY,OAAO,WAAW,OAAO,yBAAyB,OAAO;AACrE;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,UAAU;AACnE;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,CAAC;AACD;;;;;;;;;;;AC5bA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B,oGAAoG,mBAAmB,iBAAiB,sHAAsH;AAC/S,4CAA4C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD;AAC/P,8DAA8D,sEAAsE,8DAA8D,kDAAkD,iBAAiB,GAAG;AACxQ,+BAA+B,uCAAuC;AACtE,qCAAqC,iEAAiE,sCAAsC,0BAA0B,+CAA+C,2CAA2C,uEAAuE;AACvU,kDAAkD,0CAA0C;AAC5F,2CAA2C,+DAA+D,6EAA6E,yEAAyE,eAAe,uDAAuD,GAAG,+CAA+C,iBAAiB,GAAG;AAC5Y,iCAAiC,0GAA0G,iBAAiB,aAAa;AACzK,iCAAiC,6DAA6D,yCAAyC,8CAA8C,iCAAiC,mDAAmD,2DAA2D,OAAO,yCAAyC;AACpX,kDAAkD,0EAA0E,eAAe,4BAA4B,mFAAmF;AAC1P,wCAAwC,uBAAuB,yFAAyF;AACxJ,uCAAuC,wEAAwE,0CAA0C,8CAA8C,MAAM,4EAA4E,IAAI,eAAe,YAAY;AACxT,8BAA8B,uGAAuG,mDAAmD;AACxL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,qCAAqC,mBAAO,CAAC,wDAAW;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,iCAAiC,mBAAO,CAAC,0CAAO;AAChD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;AACD;AACA,sEAAsE,aAAa;AACnF;AACA;AACA,qCAAqC,mBAAO,CAAC,wDAAW;AACxD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oBAAoB;;;;;;;;;;;AC1KpB;AACA;;AAEa;;AAEb,kCAAkC;AAClC,8BAA8B;AAC9B,kDAAkD,gBAAgB,gEAAgE,wDAAwD,6DAA6D,sDAAsD;AAC7S,uCAAuC,uDAAuD,uCAAuC,SAAS,uBAAuB;AACrK,uCAAuC,kGAAkG,iBAAiB,wCAAwC,MAAM,yCAAyC,6BAA6B,UAAU,YAAY,kEAAkE,WAAW,YAAY,iBAAiB,UAAU,MAAM,2EAA2E,UAAU,oBAAoB;AACvgB,gCAAgC;AAChC,sBAAsB,2BAA2B,oGAAoG,mBAAmB,iBAAiB,sHAAsH;AAC/S;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uCAAuC,mBAAO,CAAC,oDAAW;AAC1D;AACA;AACA;AACA,gDAAgD,mBAAO,CAAC,8CAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,kBAAkB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW,oBAAoB,WAAW;AACzD;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9jBa;;AAEb,mBAAmB,mBAAO,CAAC,mFAAe;;AAE1C,eAAe,mBAAO,CAAC,6CAAI;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACda;;AAEb,WAAW,mBAAO,CAAC,4DAAe;AAClC,mBAAmB,mBAAO,CAAC,mFAAe;AAC1C,wBAAwB,mBAAO,CAAC,wEAAqB;;AAErD,iBAAiB,mBAAO,CAAC,wDAAgB;AACzC;AACA;AACA;;AAEA,sBAAsB,mBAAO,CAAC,sEAAoB;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,kBAAkB;AAC9D,EAAE;AACF,CAAC,oBAAoB;AACrB;;;;;;;;;;;;AClCa;;AAEb;;AAEA,aAAa,mBAAO,CAAC,oDAAW;AAChC,iBAAiB,mBAAO,CAAC,wDAAgB;AACzC,kBAAkB,mBAAO,CAAC,0DAAiB;AAC3C,sBAAsB,mBAAO,CAAC,sDAAe;AAC7C,mBAAmB,mBAAO,CAAC,4DAAkB;AAC7C,iBAAiB,mBAAO,CAAC,wDAAgB;AACzC,gBAAgB,mBAAO,CAAC,sDAAe;;AAEvC;;AAEA;AACA;AACA;AACA,kCAAkC,8CAA8C;AAChF,GAAG;AACH;;AAEA;AACA;AACA;AACA,UAAU;AACV,GAAG;AACH,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,EAAE;AACF;;AAEA,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,eAAe,mBAAO,CAAC,oDAAW;;AAElC;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD,GAAG;AACH,gDAAgD;AAChD,GAAG;AACH,sDAAsD;AACtD,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,4DAAe;AAClC,aAAa,mBAAO,CAAC,8CAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtWA;AACA,WAAW,mBAAO,CAAC,yCAAM;AACzB,aAAa,mBAAO,CAAC,qDAAQ;AAC7B,iBAAiB;;AAEjB;AACA;AACA;;AAEA,WAAW,qBAAM,oBAAoB,qBAAM;AAC3C,cAAc,qBAAM;AACpB,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,sBAAsB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACtFA;AAC0G;AACjB;AACzF,8BAA8B,mFAA2B,CAAC,4FAAqC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B,mBAAmB;AACnB,uBAAuB;AACvB,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB,kCAAkC;AAClC,oBAAoB;AACpB;AACA,kBAAkB;AAClB,kMAAkM;AAClM,iCAAiC;AACjC,mCAAmC;AACnC,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,kBAAkB;AAClB,yBAAyB;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mHAAmH;AACnH,iCAAiC;AACjC,mCAAmC;AACnC,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB,yBAAyB;AACzB,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,kCAAkC;AAClC,oCAAoC;AACpC,mBAAmB;AACnB,wBAAwB;AACxB,wBAAwB;AACxB,kBAAkB;AAClB,aAAa;AACb,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,iCAAiC;AACjC,0BAA0B;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC,wBAAwB;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd,kBAAkB;AAClB;;AAEA;AACA;AACA,cAAc;AACd,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,0BAA0B;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,OAAO,iFAAiF,YAAY,MAAM,OAAO,qBAAqB,oBAAoB,qBAAqB,qBAAqB,MAAM,MAAM,WAAW,MAAM,YAAY,MAAM,MAAM,qBAAqB,qBAAqB,qBAAqB,UAAU,oBAAoB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,MAAM,OAAO,MAAM,KAAK,oBAAoB,qBAAqB,MAAM,QAAQ,MAAM,KAAK,oBAAoB,oBAAoB,qBAAqB,MAAM,MAAM,MAAM,KAAK,WAAW,WAAW,WAAW,MAAM,MAAM,MAAM,UAAU,WAAW,WAAW,MAAM,MAAM,MAAM,KAAK,UAAU,WAAW,MAAM,MAAM,MAAM,MAAM,WAAW,MAAM,SAAS,MAAM,QAAQ,qBAAqB,qBAAqB,qBAAqB,oBAAoB,MAAM,MAAM,MAAM,KAAK,UAAU,MAAM,MAAM,MAAM,MAAM,UAAU,UAAU,WAAW,WAAW,MAAM,KAAK,UAAU,MAAM,KAAK,UAAU,MAAM,QAAQ,MAAM,KAAK,oBAAoB,qBAAqB,qBAAqB,MAAM,QAAQ,MAAM,SAAS,qBAAqB,qBAAqB,qBAAqB,oBAAoB,qBAAqB,qBAAqB,oBAAoB,oBAAoB,oBAAoB,MAAM,MAAM,MAAM,MAAM,WAAW,MAAM,OAAO,MAAM,QAAQ,qBAAqB,qBAAqB,qBAAqB,MAAM,MAAM,MAAM,KAAK,UAAU,MAAM,MAAM,MAAM,KAAK,WAAW,MAAM,MAAM,MAAM,KAAK,WAAW,MAAM,MAAM,MAAM,MAAM,UAAU,MAAM,OAAO,MAAM,KAAK,qBAAqB,qBAAqB,MAAM,MAAM,MAAM,KAAK,WAAW,MAAM,OAAO,MAAM,KAAK,qBAAqB,oBAAoB,MAAM,MAAM,MAAM,KAAK,WAAW,MAAM,MAAM,MAAM,iBAAiB,UAAU,MAAM,KAAK,UAAU,UAAU,MAAM,KAAK,UAAU,MAAM,OAAO,WAAW,UAAU,UAAU,MAAM,MAAM,KAAK,KAAK,UAAU,MAAM,MAAM,MAAM,KAAK,WAAW,MAAM,OAAO,MAAM,KAAK,oBAAoB,oBAAoB,MAAM,MAAM,oBAAoB,oBAAoB,MAAM,MAAM,MAAM,MAAM,UAAU,MAAM,MAAM,KAAK,KAAK,UAAU,MAAM,QAAQ,MAAM,YAAY,oBAAoB,qBAAqB,MAAM,MAAM,MAAM,MAAM,UAAU,UAAU,MAAM,WAAW,KAAK,UAAU,MAAM,KAAK,WAAW,WAAW,WAAW,WAAW,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,WAAW,WAAW,WAAW,WAAW,WAAW,UAAU,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,UAAU,WAAW,WAAW,WAAW,WAAW,UAAU,WAAW,UAAU,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,KAAK,MAAM,KAAK,WAAW,WAAW,WAAW,WAAW,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,WAAW,WAAW,WAAW,WAAW,WAAW,UAAU,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,UAAU,WAAW,WAAW,WAAW,WAAW,UAAU,WAAW,UAAU,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,KAAK,KAAK,KAAK,YAAY,YAAY,YAAY,YAAY,YAAY,aAAa,aAAa,aAAa,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,WAAW,YAAY,YAAY,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,YAAY,aAAa,aAAa,aAAa,aAAa,aAAa,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,WAAW,MAAM,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM,MAAM,YAAY,aAAa,aAAa,MAAM,MAAM,MAAM,YAAY,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,MAAM,MAAM,YAAY,aAAa,MAAM,yCAAyC,yBAAyB,wBAAwB,mBAAmB;AACvxN;AACA,iEAAe,uBAAuB,EAAC;;;;;;;;;;;;ACr+B1B;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,gDAAgD;AAChD;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,sFAAsF,qBAAqB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,iDAAiD,qBAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,sDAAsD,qBAAqB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpFa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,cAAc;AACrE;AACA;AACA;AACA;AACA;;;;;;;;;;;ACfa;;AAEb,sBAAsB,mBAAO,CAAC,sEAAoB;;AAElD,mBAAmB,mBAAO,CAAC,4DAAkB;AAC7C,iBAAiB,mBAAO,CAAC,wDAAgB;;AAEzC,WAAW,mBAAO,CAAC,0CAAM;;AAEzB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW,0CAA0C;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,GAAG;AACH;AACA,yBAAyB;AACzB,GAAG;AACH;AACA;AACA;;;;;;;;;;;;ACvDa;;AAEb,WAAW,mBAAO,CAAC,wDAAa;AAChC;;AAEA;AACA;AACA,yBAAyB,mBAAO,CAAC,0EAAsB;;AAEvD;AACA;AACA;;AAEA,0BAA0B,mBAAO,CAAC,kFAA0B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;AC9Ca;;AAEb,mBAAmB,mBAAO,CAAC,4FAAe;;AAE1C,WAAW,aAAa;AACxB;AACA;AACA;AACA,oBAAoB,SAAS,UAAU;AACvC,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACfa;;AAEb;;AAEA,aAAa,mBAAO,CAAC,oDAAW;AAChC,iBAAiB,mBAAO,CAAC,wDAAgB;AACzC,kBAAkB,mBAAO,CAAC,0DAAiB;AAC3C,sBAAsB,mBAAO,CAAC,sDAAe;AAC7C,mBAAmB,mBAAO,CAAC,4DAAkB;AAC7C,iBAAiB,mBAAO,CAAC,wDAAgB;AACzC,gBAAgB,mBAAO,CAAC,sDAAe;;AAEvC;;AAEA;AACA;AACA;AACA,kCAAkC,8CAA8C;AAChF,GAAG;AACH;;AAEA;AACA;AACA;AACA,UAAU;AACV,GAAG;AACH,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,EAAE;AACF;;AAEA,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,eAAe,mBAAO,CAAC,oDAAW;;AAElC;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD,GAAG;AACH,gDAAgD;AAChD,GAAG;AACH,sDAAsD;AACtD,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,4DAAe;AAClC,aAAa,mBAAO,CAAC,8CAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtWa;;AAEb,WAAW,kBAAkB;AAC7B;;;;;;;;;;;;ACHa;;AAEb,WAAW,aAAa;AACxB;;;;;;;;;;;;ACHa;;AAEb,WAAW,mBAAmB;AAC9B;;;;;;;;;;;;ACHa;;AAEb,WAAW,iBAAiB;AAC5B;;;;;;;;;;;;ACHa;;AAEb,WAAW,oBAAoB;AAC/B;;;;;;;;;;;;ACHa;;AAEb,WAAW,kBAAkB;AAC7B;;;;;;;;;;;;ACHa;;AAEb,WAAW,iBAAiB;AAC5B;;;;;;;;;;;;ACHa;;AAEb,iBAAiB,mBAAO,CAAC,wDAAa;;AAEtC;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;;;;;;;;;;;;AC7Da;;AAEb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;;AAEA,iFAAiF,sCAAsC;;AAEvH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACnFa;;AAEb,qBAAqB,mBAAO,CAAC,wEAAkB;;AAE/C;;;;;;;;;;;;ACJa;;AAEb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,8CAA8C;AAChF,GAAG;AACH;;AAEA;AACA;AACA;AACA,UAAU;AACV,GAAG;AACH,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,EAAE;AACF;;AAEA,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,eAAe,mBAAO,CAAC,oDAAW;;AAElC;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD,GAAG;AACH,gDAAgD;AAChD,GAAG;AACH,sDAAsD;AACtD,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,4DAAe;AAClC,aAAa,mBAAO,CAAC,8CAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9Va;;AAEb,mBAAmB,mBAAO,CAAC,4DAAe;;AAE1C;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACfa;;AAEb,mBAAmB,mBAAO,CAAC,4DAAe;;AAE1C;;AAEA;AACA;AACA;AACA,qBAAqB,SAAS,UAAU;AACxC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCa;;AAEb;AACA;AACA;;AAEA;;AAEA;AACA,UAAU,iBAAiB,yBAAyB,kBAAkB;AACtE;;;;;;;;;;;;ACVa;;AAEb;AACA,oBAAoB,mBAAO,CAAC,oDAAS;;AAErC;AACA,yCAAyC;AACzC,qCAAqC;AACrC,8CAA8C;AAC9C,0CAA0C;;AAE1C;AACA;;;;;;;;;;;;ACZa;;AAEb;AACA;AACA,2FAA2F;AAC3F,4CAA4C;;AAE5C;AACA;AACA;AACA,gCAAgC;;AAEhC,kEAAkE;AAClE,qEAAqE;;AAErE;AACA,iCAAiC;AACjC;AACA,uCAAuC;;AAEvC,2DAA2D;AAC3D,+DAA+D;;AAE/D;AACA;AACA,oBAAoB,gBAAgB;AACpC,2EAA2E;;AAE3E,yGAAyG;;AAEzG;AACA,6CAA6C;;AAE7C,8DAA8D;;AAE9D;AACA;AACA,uEAAuE;AACvE;;AAEA;AACA;;;;;;;;;;;;ACzCa;;AAEb,iBAAiB,mBAAO,CAAC,8DAAmB;;AAE5C,WAAW,aAAa;AACxB;AACA;AACA;;;;;;;;;;;;ACPa;;AAEb;AACA;AACA,WAAW,mBAAO,CAAC,4DAAe;;AAElC,WAAW,MAAM,mCAAmC;AACpD;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1Ba;;AAEb,qBAAqB,mBAAO,CAAC,sEAAuB;AACpD,gBAAgB,mBAAO,CAAC,kEAAqB;;AAE7C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED,2DAA2D;;AAE3D;;;;;;;;;;;;AChCa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,6BAA6B,WAAW;AACxC,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,2CAA2C;AAC3C,2EAA2E;;AAE3E,0BAA0B;;AAE1B,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,MAAM,YAAY;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,gBAAgB;AAChB,kEAAkE;AAClE;AACA;AACA,IAAI;AACJ,iCAAiC;AACjC;AACA;AACA;AACA;AACA,sBAAsB;AACtB,gBAAgB;AAChB,kEAAkE;AAClE,wBAAwB;AACxB,6BAA6B;AAC7B;AACA,6FAA6F;AAC7F;AACA;;;;;;;;;;;;ACpGa;;AAEb;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,sEAAuB;AACpD;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,wCAAwC;AACxC,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrCa;;AAEb;;AAEA;AACA;AACA;;;;;;;;;;;;ACNa;;AAEb,eAAe,mBAAO,CAAC,wEAAW;AAClC,aAAa,mBAAO,CAAC,oEAAmB;;AAExC,qBAAqB,mBAAO,CAAC,iEAAkB;AAC/C,kBAAkB,mBAAO,CAAC,qDAAY;AACtC,WAAW,mBAAO,CAAC,6CAAQ;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;ACnBa;;AAEb,WAAW,mBAAO,CAAC,4DAAe;AAClC,mBAAmB,mBAAO,CAAC,4DAAe;AAC1C,wBAAwB,mBAAO,CAAC,4FAAqB;;AAErD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS,UAAU;AACvC,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,kBAAkB;AAC9D,EAAE;AACF,CAAC,oBAAoB;AACrB;;;;;;;;;;;;AC3Ca;;AAEb,6BAA6B,mBAAO,CAAC,kFAA0B;;AAE/D,mBAAmB,mBAAO,CAAC,4DAAe;;AAE1C;AACA;AACA;AACA,oBAAoB,SAAS,UAAU;AACvC,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW,mBAAO,CAAC,0CAAM;;AAEzB,WAAW,qMAAqM;AAChN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW,0CAA0C;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,GAAG;AACH;AACA,yBAAyB;AACzB,GAAG;AACH;AACA;AACA;;;;;;;;;;;;ACnEa;;AAEb,mBAAmB,mBAAO,CAAC,4DAAe;AAC1C,aAAa,mBAAO,CAAC,8FAAsB;AAC3C,qBAAqB,mBAAO,CAAC,kFAA0B;AACvD,WAAW,mBAAO,CAAC,0CAAM;;AAEzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxCa;;AAEb,qBAAqB,mBAAO,CAAC,iEAAkB;;AAE/C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTa;;AAEb,aAAa,mBAAO,CAAC,oEAAmB;AACxC,kBAAkB,mBAAO,CAAC,qDAAY;;AAEtC;;AAEA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA,EAAE;AACF;AACA;;;;;;;;;;;;ACfa;;AAEb,sBAAsB,mBAAO,CAAC,oEAAmB;;AAEjD,WAAW,aAAa;AACxB;AACA;AACA;;;;;;;;;;;;ACPa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBa;;AAEb,aAAa,mBAAO,CAAC,oEAAmB;AACxC,eAAe,mBAAO,CAAC,oDAAW;;AAElC,qBAAqB,mBAAO,CAAC,oEAAkB;AAC/C,kBAAkB,mBAAO,CAAC,wDAAY;AACtC,WAAW,mBAAO,CAAC,gDAAQ;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;ACjBa;;AAEb,qBAAqB,mBAAO,CAAC,oEAAkB;;AAE/C;AACA;AACA;;;;;;;;;;;;ACNa;;AAEb,kBAAkB,mBAAO,CAAC,wDAAY;AACtC,aAAa,mBAAO,CAAC,oEAAmB;;AAExC;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA,EAAE;AACF;AACA;;;;;;;;;;;;ACba;;AAEb;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,gEAAe,GAAG;AACxC;AACA,2CAA2C,gBAAgB;AAC3D,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzHa;;AAEb;AACA,aAAa,mBAAO,CAAC,gEAAe;;AAEpC;AACA,6CAA6C,sBAAsB,EAAE,mBAAO,CAAC,sEAAkB;;AAE/F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/Ba;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChBa;;AAEb;AACA,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,iBAAiB,mBAAO,CAAC,8DAAmB;AAC5C,gBAAgB,mBAAO,CAAC,kEAAqB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB,4BAA4B;AAC5B;AACA,aAAa;AACb;AACA,iBAAiB,sBAAsB;AACvC,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,iBAAiB;AACnC;AACA,2CAA2C;AAC3C,mCAAmC;AACnC,6BAA6B;AAC7B;AACA;AACA;;AAEA,YAAY;AACZ;;;;;;;;;;;;AC7Ca;;AAEb,qBAAqB,mBAAO,CAAC,wEAAkB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,MAAM;AAChD;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtDa;;AAEb,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACfA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;;ACvLhB;;AAEb,mBAAmB,mBAAO,CAAC,6FAAe;AAC1C,aAAa,mBAAO,CAAC,0EAAsB;AAC3C,qBAAqB,mBAAO,CAAC,mHAA0B;AACvD,WAAW,mBAAO,CAAC,0CAAM;;AAEzB,iBAAiB,mBAAO,CAAC,wDAAgB;AACzC;;AAEA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,uBAAuB;AAC5C,IAAI;AACJ,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;;;;;;;;;;;;ACzCa;;AAEb;;AAEA,aAAa,mBAAO,CAAC,oDAAW;AAChC,iBAAiB,mBAAO,CAAC,wDAAgB;AACzC,kBAAkB,mBAAO,CAAC,0DAAiB;AAC3C,sBAAsB,mBAAO,CAAC,sDAAe;AAC7C,mBAAmB,mBAAO,CAAC,4DAAkB;AAC7C,iBAAiB,mBAAO,CAAC,wDAAgB;AACzC,gBAAgB,mBAAO,CAAC,sDAAe;;AAEvC;;AAEA;AACA;AACA;AACA,kCAAkC,8CAA8C;AAChF,GAAG;AACH;;AAEA;AACA;AACA;AACA,UAAU;AACV,GAAG;AACH,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,EAAE;AACF;;AAEA,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,eAAe,mBAAO,CAAC,oDAAW;;AAElC;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD,GAAG;AACH,gDAAgD;AAChD,GAAG;AACH,sDAAsD;AACtD,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,4DAAe;AAClC,aAAa,mBAAO,CAAC,8CAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtWa;;AAEb,sBAAsB,mBAAO,CAAC,sEAAoB;;AAElD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBA,MAA+F;AAC/F,MAAqF;AACrF,MAA4F;AAC5F,MAA+G;AAC/G,MAAwG;AACxG,MAAwG;AACxG,MAA8I;AAC9I;AACA;;AAEA;;AAEA,4BAA4B,qGAAmB;AAC/C,wBAAwB,kHAAa;;AAErC,uBAAuB,uGAAa;AACpC;AACA,iBAAiB,+FAAM;AACvB,6BAA6B,sGAAkB;;AAE/C,aAAa,0GAAG,CAAC,8HAAO;;;;AAIwF;AAChH,OAAO,iEAAe,8HAAO,IAAI,8HAAO,UAAU,8HAAO,mBAAmB,EAAC;;;;;;;;;;;;AC1BhE;;AAEb;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnFa;;AAEb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjCa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACTa;;AAEb;AACA;AACA,cAAc,KAAwC,GAAG,sBAAiB,GAAG,CAAI;AACjF;AACA;AACA;AACA;AACA;;;;;;;;;;;ACTa;;AAEb;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5Da;;AAEb;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACLA;AACA;;AAEa;;AAEb,wBAAwB,mBAAO,CAAC,0DAAc;AAC9C,0BAA0B,mBAAO,CAAC,4EAAuB;AACzD,sBAAsB,mBAAO,CAAC,oEAAmB;AACjD,mBAAmB,mBAAO,CAAC,8DAAgB;;AAE3C;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,yBAAyB;AACzB,2BAA2B;AAC3B,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;;AAGzB;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;;;;;;;;;;;AC7UD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,wBAAwB,SAAS;AACjC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa,OAAO,oBAAoB,OAAO;AAC/C;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA,QAAQ,SAAS,OAAO;AACxB,QAAQ,OAAO;AACf,QAAQ;AACR,QAAQ,OAAO;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA,IAAI,OAAO;AACX,iBAAiB,OAAO;AACxB,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA,QAAQ,OAAO;AACf;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;AAGf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,KAAK;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA,WAAW;AACX;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,kGAA0C;;AAE1C;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA,gBAAgB;AAChB,sBAAsB;;AAEtB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,cAAc;AACd,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA,eAAe;AACf,2BAA2B;;AAE3B;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB,kHAAgD;;AAEhD;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,WAAW;AACX,EAAE,OAAO;AACT;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA,WAAW,UAAU;AACrB;AACA,qGAAsC;;AAEtC,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO,qCAAqC;AACxE,4BAA4B,OAAO,sDAAsD;AACzF;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;;AC1sBN;;AAEb,cAAc,mBAAO,CAAC,kDAAU;AAChC,2BAA2B,mBAAO,CAAC,8EAAwB;AAC3D,eAAe,mBAAO,CAAC,oDAAW;AAClC,gBAAgB,mBAAO,CAAC,kEAAqB;AAC7C,WAAW,mBAAO,CAAC,0CAAM;;AAEzB,WAAW,uBAAuB;AAClC;AACA,qBAAqB,mBAAO,CAAC,sEAAuB;;AAEpD,4CAA4C,qBAAM;AAClD;;AAEA;AACA,4CAA4C;;AAE5C,WAAW,8DAA8D;AACzE;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,8HAA8H;AAC5I,aAAa,WAAW,2BAA2B,cAAc,IAAI,mBAAmB;AACxF,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA,WAAW,uDAAuD;AAClE;AACA,YAAY,sCAAsC;AAClD;AACA;AACA,aAAa,YAAY,eAAe,YAAY,cAAc,KAAK;AACvE,aAAa,4BAA4B,2BAA2B,YAAY;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY;AAClB;AACA;AACA;AACA;AACA;;AAEA,WAAW,uDAAuD;AAClE;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA,aAAa,YAAY,eAAe,YAAY,cAAc,KAAK;AACvE,aAAa,kCAAkC,2BAA2B,YAAY;AACtF;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY;AAClB;AACA;AACA;AACA;AACA;;AAEA,WAAW,aAAa;AACxB;AACA,4CAA4C;AAC5C;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAM;AACzB,cAAc,qBAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,KAAK;AAC3D;AACA,8BAA8B,KAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,mCAAmC,eAAe,IAAI,sBAAsB;AAC5E;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK;AAClC,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM,OAAO;AAC/C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS,EAAE,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ,EAAE,SAAS;AAC1D,UAAU;AACV;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,gDAAgD;AAChD;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS,GAAG,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,WAAW,MAAM,0BAA0B,UAAU;AACrD;AACA,WAAW,OAAO,0CAA0C;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa,EAAE;AACtD;AACA,mBAAmB,KAAK,yBAAyB;AACjD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB,EAAE,mBAAmB;AAC/D,8DAA8D,QAAQ;AACtE,UAAU;AACV,8DAA8D,iBAAiB,EAAE,qBAAqB,EAAE,QAAQ;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA,yCAAyC,iBAAiB,EAAE,mBAAmB;AAC/E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ,kBAAkB,SAAS;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,IAAI;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,WAAW;AACvE;AACA;AACA;AACA;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,gBAAgB,yDAAyD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA,SAAS;AACT;AACA,yBAAyB,QAAQ;AACjC;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAqD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,gBAAgB,OAAO;AACvB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iEAAiE;AAC/E;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS,GAAG,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAM;AACrB,eAAe,qBAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD,KAAK;AACL;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C,wBAAwB,QAAQ;AAChC;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,4BAA4B,QAAQ;AACpC,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAiD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,gDAAgD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS,wBAAwB,QAAQ;AACtF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAA0D;AACtE;AACA,qBAAqB,QAAQ;AAC7B;AACA,wBAAwB,iBAAiB;AACzC,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,qBAAqB,QAAQ;AAC7B;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,IAAI;AACpC;AACA;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,mBAAmB,OAAO,iCAAiC,IAAI,YAAY,EAAE;AAC7E;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,2BAA2B,OAAO,WAAW,gBAAgB,aAAa,IAAI;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA,4DAA4D,WAAW;AACvE;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,kBAAkB,GAAG,KAAK,GAAG,WAAW,cAAc,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ,MAAM,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD,oBAAoB,6CAA6C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,yDAAyD,MAAM;AAC/D,YAAY,uCAAuC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,WAAW;AAC9E;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM,QAAQ,aAAa;AACzE;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,4BAA4B,IAAI;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,QAAQ,wCAAwC;AAChD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB,IAAI,GAAG,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE;AAC3D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,uCAAuC,aAAa,4BAA4B,WAAW;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,wBAAwB,uBAAuB;AAC/C,sBAAsB,iBAAiB;AACvC,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,uCAAuC,KAAK,wBAAwB,eAAe,sBAAsB,iBAAiB;AAC1H;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC,cAAc,mCAAmC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,MAAM,OAAO,SAAS,OAAO,cAAc,aAAa,cAAc,gBAAgB;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,GAAG;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,EAAE,YAAY,MAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,GAAG;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB,KAAK,MAAM;AAC7D;AACA;AACA,KAAK;AACL;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,4BAA4B,4CAA4C;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,KAAK,QAAQ,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE,YAAY;AAC3B;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,EAAE;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL,eAAe,OAAO;AACtB;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kCAAkC;AACvE;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,yCAAyC,8BAA8B;AACvE;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,oDAAoD,MAAM,IAAI,MAAM;AACpE;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA,4DAA4D;AAC5D;AACA,mCAAmC,IAAI,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,QAAQ,GAAG,IAAI;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,4BAA4B,IAAI,IAAI;AACpC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM,EAAE,OAAO;AACnC;AACA,yCAAyC,KAAK,IAAI,OAAO;AACzD;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA,6BAA6B,wCAAwC;AACrE,oCAAoC,OAAO;AAC3C;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA,2BAA2B,GAAG,MAAM,GAAG,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY,cAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAK,GAAG;AACtB,gBAAgB,YAAY;AAC5B,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,uBAAuB,KAAK,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yBAAyB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB,mBAAmB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA,aAAa,IAAI;AACjB;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qBAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO,MAAM,4BAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA,2BAA2B,WAAW,GAAG,WAAW;AACpD;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO,KAAK,OAAO,IAAI,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB,cAAc,OAAO;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK,QAAQ,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,wBAAwB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uCAAuC;AACvE,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,sCAAsC,gCAAgC;AACtE;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,kBAAkB,KAAK,IAAI,+BAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,UAAU;AACV,mDAAmD;AACnD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD,cAAc;AACd,uDAAuD;AACvD;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG,KAAK;AACzB,gCAAgC,OAAO;AACvC,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,wBAAwB;AAC1E,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB,GAAG,OAAO;AAC9E,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,SAAS;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,SAAS;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,aAAa;AACxE,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,+CAA+C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,IAAI;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,IAAI;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY,wBAAwB;AACpC,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA,gBAAgB,OAAO;AACvB;AACA,qBAAqB,YAAY;AACjC,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,oBAAoB,OAAO;AAC3B,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,4CAA4C,KAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO,MAAM,6BAA6B;AACpE;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,kCAAkC,GAAG;AACrC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,iCAAiC;AACjC,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,+CAA+C,KAAK,GAAG,QAAQ;AAC/D;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,EAAE,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oBAAoB;AACxE;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,aAAa;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,mEAAmE;AACnE;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,iCAAiC;AACjC,qCAAqC;AACrC;AACA;AACA,KAAK;AACL,6CAA6C;AAC7C;AACA;AACA,KAAK;AACL,wCAAwC;AACxC,yCAAyC;AACzC;AACA;AACA,KAAK;AACL,8BAA8B;AAC9B;AACA;AACA,KAAK;AACL,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,0CAA0C;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iCAAiC;AACzE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,aAAa;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA,uCAAuC,OAAO,qBAAqB,KAAK;AACxE;AACA,8BAA8B,KAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,wCAAwC,kBAAkB,KAAK,gBAAgB;AAC/E;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,sBAAsB;AACtB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,sBAAsB;AACtB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,qBAAqB;AACrB;AACA,kBAAkB;AAClB;AACA;AACA,qDAAqD;AACrD;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA,qBAAqB,YAAY;AACjC,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA,UAAU;AACV,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX,IAAI,OAAO;AACX,qCAAqC,SAAS;AAC9C;AACA,IAAI,OAAO;AACX,IAAI,OAAO;AACX;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA,IAAI,OAAO;AACX,IAAI,OAAO;AACX;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA,IAAI,OAAO;AACX,IAAI,OAAO;AACX,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA,0CAA0C,OAAO,GAAG,aAAa;AACjE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qCAAqC,2BAA2B;AAChE;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,yBAAyB;AACzB,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wCAAwC,+BAA+B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,yDAAyD;AACzD;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,IAAI;AACrE,SAAS;AACT,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB,GAAG,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB,MAAM,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI,GAAG,MAAM;AAC1C;AACA;AACA,SAAS;AACT,gDAAgD,YAAY;AAC5D,kBAAkB,kBAAkB,cAAc,OAAO,EAAE,MAAM,EAAE,OAAO;AAC1E;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA,+BAA+B,EAAE,GAAG,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,6BAA6B,kBAAkB,4BAA4B,GAAG;AAC9E,yBAAyB;AACzB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAM;AACrB,eAAe,qBAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kCAAkC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB,MAAM,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB,GAAG,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,mCAAmC,kBAAkB,GAAG,qBAAqB;AAC7E;AACA,kBAAkB;AAClB;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,cAAc;AACd,uCAAuC;AACvC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;AACA,sBAAsB;AACtB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,oBAAoB;AACjF;AACA;AACA,6DAA6D,oBAAoB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB,SAAS,cAAc;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD,kCAAkC;AAClC;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC,yBAAyB;AAC/D;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,aAAa;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wOAAwO,gMAAgM,8MAA8M,iFAAiF,oBAAoB,yQAAyQ,aAAa,UAAU,YAAY,mDAAmD,eAAe,wFAAwF,4DAA4D,UAAU,yBAAyB,i4BAAi4B,4BAA4B,2CAA2C,0dAA0d,cAAc,oLAAoL,wCAAwC,6BAA6B,uNAAuN,yjBAAyjB,gHAAgH,oCAAoC,cAAc,gBAAgB,0OAA0O,sUAAsU,yDAAyD,sIAAsI,OAAO,iJAAiJ,mMAAmM,QAAQ,MAAM,wXAAwX,0CAA0C,kBAAkB,4BAA4B,8FAA8F,sUAAsU,6BAA6B;AACp1L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA,8CAA8C,EAAE;AAChD;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA,cAAc;AACd,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,YAAY;AACpC,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,YAAY;AACpC,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,gEAAgE,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,MAAM;AACN;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,EAAE;AAC1B;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,wBAAwB,EAAE;AAC1B;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,wBAAwB,EAAE;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AA+LA;;;;;;;;;;;;AC7ysBY;;AAEb,oBAAoB,mBAAO,CAAC,sFAA4B;;AAExD,4CAA4C,qBAAM;;AAElD,WAAW,aAAa;AACxB;AACA,gBAAgB,yCAAyC;AACzD,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UChBA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;;;;;;;;;;;;;;;;ACAqB;AACoB;AACzC;AACA,YAAY,8BAA8B;AAIP;AACnC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,EAAE,OAAO;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,OAAO;AACb;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO;AACT;AACA;AACA,IAAI,+EAA0B;AAC9B,IAAI,mEAAc;AAClB;AACA;AACA;AACA,gCAAgC,uCAAuC;AACvE;AACA;AACA;AACA;AACA;AACA,MAAM,kDAAM;AACZ;AACA;AACA;AACA;AACA,UAAU,kDAAM;AAChB;AACA;AACA;AACA,IAAI;AACJ,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,MAAM,+EAA0B;AAChC,MAAM,mEAAc;AACpB;AACA,IAAI,OAAO;AACX;AACA,iCAAiC,cAAc;AAC/C;AACA,eAAe,kDAAM;AACrB,eAAe,kDAAM;AACrB,OAAO;AACP;AACA;AACA,YAAY,kDAAM;AAClB;AACA;AACA;AACA,MAAM;AACN,MAAM,OAAO;AACb;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA,EAAE,OAAO;AACT;AACA;AACA,eAAe,wBAAwB;AACvC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,IAAI,kDAAM;AACV,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,kDAAM;AAClF;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,cAAc,IAAI;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM,EAAE,OAAO,EAAE,KAAK;AACtE;AACA;AACA,6KAA6K;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kDAAM,qBAAqB;AACzE;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,cAAc,IAAI;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM,EAAE,OAAO,EAAE,KAAK;AACtE;AACA;AACA,6KAA6K,kDAAM;AACnL;AACA,eAAe,QAAQ,kDAAM,qBAAqB,OAAO,MAAM,EAAE,OAAO,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kDAAM,qBAAqB;AACzE;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yBAAyB;AAC9D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI,+EAA0B;AAC9B,IAAI,mEAAc;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAM;AAC/B;AACA,yBAAyB,kDAAM;AAC/B;AACA;AACA,IAAI;AACJ,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./contracts/constants.js","webpack:///./node_modules/assert/build/assert.js","webpack:///./node_modules/assert/build/internal/assert/assertion_error.js","webpack:///./node_modules/assert/build/internal/errors.js","webpack:///./node_modules/assert/build/internal/util/comparisons.js","webpack:///./node_modules/call-bind/callBound.js","webpack:///./node_modules/call-bind/index.js","webpack:///./node_modules/call-bind/node_modules/get-intrinsic/index.js","webpack:///./node_modules/console-browserify/index.js","webpack:///./src/style.css","webpack:///./node_modules/css-loader/dist/runtime/api.js","webpack:///./node_modules/css-loader/dist/runtime/sourceMaps.js","webpack:///./node_modules/define-data-property/index.js","webpack:///./node_modules/define-properties/index.js","webpack:///./node_modules/es-define-property/index.js","webpack:///./node_modules/es-define-property/node_modules/get-intrinsic/index.js","webpack:///./node_modules/es-errors/eval.js","webpack:///./node_modules/es-errors/index.js","webpack:///./node_modules/es-errors/range.js","webpack:///./node_modules/es-errors/ref.js","webpack:///./node_modules/es-errors/syntax.js","webpack:///./node_modules/es-errors/type.js","webpack:///./node_modules/es-errors/uri.js","webpack:///./node_modules/for-each/index.js","webpack:///./node_modules/function-bind/implementation.js","webpack:///./node_modules/function-bind/index.js","webpack:///./node_modules/get-intrinsic/index.js","webpack:///./node_modules/gopd/index.js","webpack:///./node_modules/has-property-descriptors/index.js","webpack:///./node_modules/has-proto/index.js","webpack:///./node_modules/has-symbols/index.js","webpack:///./node_modules/has-symbols/shams.js","webpack:///./node_modules/has-tostringtag/shams.js","webpack:///./node_modules/hasown/index.js","webpack:///./node_modules/inherits/inherits_browser.js","webpack:///./node_modules/is-arguments/index.js","webpack:///./node_modules/is-callable/index.js","webpack:///./node_modules/is-generator-function/index.js","webpack:///./node_modules/is-nan/implementation.js","webpack:///./node_modules/is-nan/index.js","webpack:///./node_modules/is-nan/node_modules/call-bind/index.js","webpack:///./node_modules/is-nan/node_modules/define-data-property/index.js","webpack:///./node_modules/is-nan/node_modules/set-function-length/index.js","webpack:///./node_modules/is-nan/polyfill.js","webpack:///./node_modules/is-nan/shim.js","webpack:///./node_modules/is-typed-array/index.js","webpack:///./node_modules/object-is/implementation.js","webpack:///./node_modules/object-is/index.js","webpack:///./node_modules/object-is/polyfill.js","webpack:///./node_modules/object-is/shim.js","webpack:///./node_modules/object-keys/implementation.js","webpack:///./node_modules/object-keys/index.js","webpack:///./node_modules/object-keys/isArguments.js","webpack:///./node_modules/object.assign/implementation.js","webpack:///./node_modules/object.assign/polyfill.js","webpack:///./node_modules/possible-typed-array-names/index.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/set-function-length/index.js","webpack:///./node_modules/set-function-length/node_modules/get-intrinsic/index.js","webpack:///./node_modules/set-function-length/node_modules/has-property-descriptors/index.js","webpack:///./src/style.css?9011","webpack:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack:///./node_modules/style-loader/dist/runtime/insertBySelector.js","webpack:///./node_modules/style-loader/dist/runtime/insertStyleElement.js","webpack:///./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js","webpack:///./node_modules/style-loader/dist/runtime/styleDomAPI.js","webpack:///./node_modules/style-loader/dist/runtime/styleTagTransform.js","webpack:///./node_modules/util/support/isBufferBrowser.js","webpack:///./node_modules/util/support/types.js","webpack:///./node_modules/util/util.js","webpack:///./node_modules/which-typed-array/index.js","webpack:///./src/ethers.min.js","webpack:///./node_modules/available-typed-arrays/index.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/nonce","webpack:///./src/index.js"],"sourcesContent":["export const marketplaceContractAddress = \"0x07326cdbD68E3b74fda4284e49DaF05086d04918\"\r\n\r\nexport const marketplaceAbi = [\r\n  {\r\n    \"anonymous\": false,\r\n    \"inputs\": [\r\n      {\r\n        \"indexed\": false,\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"carId\",\r\n        \"type\": \"uint256\"\r\n      },\r\n      {\r\n        \"indexed\": false,\r\n        \"internalType\": \"string\",\r\n        \"name\": \"make\",\r\n        \"type\": \"string\"\r\n      },\r\n      {\r\n        \"indexed\": false,\r\n        \"internalType\": \"string\",\r\n        \"name\": \"model\",\r\n        \"type\": \"string\"\r\n      },\r\n      {\r\n        \"indexed\": false,\r\n        \"internalType\": \"string\",\r\n        \"name\": \"imageUrl\",\r\n        \"type\": \"string\"\r\n      },\r\n      {\r\n        \"indexed\": false,\r\n        \"internalType\": \"string\",\r\n        \"name\": \"year\",\r\n        \"type\": \"string\"\r\n      },\r\n      {\r\n        \"indexed\": false,\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"price\",\r\n        \"type\": \"uint256\"\r\n      },\r\n      {\r\n        \"indexed\": false,\r\n        \"internalType\": \"address\",\r\n        \"name\": \"seller\",\r\n        \"type\": \"address\"\r\n      }\r\n    ],\r\n    \"name\": \"carListed\",\r\n    \"type\": \"event\"\r\n  },\r\n  {\r\n    \"anonymous\": false,\r\n    \"inputs\": [\r\n      {\r\n        \"indexed\": false,\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"carId\",\r\n        \"type\": \"uint256\"\r\n      },\r\n      {\r\n        \"indexed\": false,\r\n        \"internalType\": \"address\",\r\n        \"name\": \"buyer\",\r\n        \"type\": \"address\"\r\n      },\r\n      {\r\n        \"indexed\": false,\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"price\",\r\n        \"type\": \"uint256\"\r\n      }\r\n    ],\r\n    \"name\": \"carSold\",\r\n    \"type\": \"event\"\r\n  },\r\n  {\r\n    \"inputs\": [\r\n      {\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"carId\",\r\n        \"type\": \"uint256\"\r\n      }\r\n    ],\r\n    \"name\": \"buyCar\",\r\n    \"outputs\": [],\r\n    \"stateMutability\": \"payable\",\r\n    \"type\": \"function\"\r\n  },\r\n  {\r\n    \"inputs\": [\r\n      {\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"\",\r\n        \"type\": \"uint256\"\r\n      }\r\n    ],\r\n    \"name\": \"carToSeller\",\r\n    \"outputs\": [\r\n      {\r\n        \"internalType\": \"address\",\r\n        \"name\": \"\",\r\n        \"type\": \"address\"\r\n      }\r\n    ],\r\n    \"stateMutability\": \"view\",\r\n    \"type\": \"function\"\r\n  },\r\n  {\r\n    \"inputs\": [\r\n      {\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"\",\r\n        \"type\": \"uint256\"\r\n      }\r\n    ],\r\n    \"name\": \"classicCars\",\r\n    \"outputs\": [\r\n      {\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"id\",\r\n        \"type\": \"uint256\"\r\n      },\r\n      {\r\n        \"internalType\": \"string\",\r\n        \"name\": \"make\",\r\n        \"type\": \"string\"\r\n      },\r\n      {\r\n        \"internalType\": \"string\",\r\n        \"name\": \"model\",\r\n        \"type\": \"string\"\r\n      },\r\n      {\r\n        \"internalType\": \"string\",\r\n        \"name\": \"imageUrl\",\r\n        \"type\": \"string\"\r\n      },\r\n      {\r\n        \"internalType\": \"string\",\r\n        \"name\": \"year\",\r\n        \"type\": \"string\"\r\n      },\r\n      {\r\n        \"internalType\": \"address\",\r\n        \"name\": \"seller\",\r\n        \"type\": \"address\"\r\n      },\r\n      {\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"price\",\r\n        \"type\": \"uint256\"\r\n      },\r\n      {\r\n        \"internalType\": \"string\",\r\n        \"name\": \"description\",\r\n        \"type\": \"string\"\r\n      },\r\n      {\r\n        \"internalType\": \"bool\",\r\n        \"name\": \"isSold\",\r\n        \"type\": \"bool\"\r\n      }\r\n    ],\r\n    \"stateMutability\": \"view\",\r\n    \"type\": \"function\"\r\n  },\r\n  {\r\n    \"inputs\": [],\r\n    \"name\": \"getAllListedCars\",\r\n    \"outputs\": [\r\n      {\r\n        \"components\": [\r\n          {\r\n            \"internalType\": \"uint256\",\r\n            \"name\": \"id\",\r\n            \"type\": \"uint256\"\r\n          },\r\n          {\r\n            \"internalType\": \"string\",\r\n            \"name\": \"make\",\r\n            \"type\": \"string\"\r\n          },\r\n          {\r\n            \"internalType\": \"string\",\r\n            \"name\": \"model\",\r\n            \"type\": \"string\"\r\n          },\r\n          {\r\n            \"internalType\": \"string\",\r\n            \"name\": \"imageUrl\",\r\n            \"type\": \"string\"\r\n          },\r\n          {\r\n            \"internalType\": \"string\",\r\n            \"name\": \"year\",\r\n            \"type\": \"string\"\r\n          },\r\n          {\r\n            \"internalType\": \"address\",\r\n            \"name\": \"seller\",\r\n            \"type\": \"address\"\r\n          },\r\n          {\r\n            \"internalType\": \"uint256\",\r\n            \"name\": \"price\",\r\n            \"type\": \"uint256\"\r\n          },\r\n          {\r\n            \"internalType\": \"string\",\r\n            \"name\": \"description\",\r\n            \"type\": \"string\"\r\n          },\r\n          {\r\n            \"internalType\": \"bool\",\r\n            \"name\": \"isSold\",\r\n            \"type\": \"bool\"\r\n          }\r\n        ],\r\n        \"internalType\": \"struct ClassicCar[]\",\r\n        \"name\": \"\",\r\n        \"type\": \"tuple[]\"\r\n      }\r\n    ],\r\n    \"stateMutability\": \"view\",\r\n    \"type\": \"function\"\r\n  },\r\n  {\r\n    \"inputs\": [\r\n      {\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"carId\",\r\n        \"type\": \"uint256\"\r\n      }\r\n    ],\r\n    \"name\": \"getCarDetails\",\r\n    \"outputs\": [\r\n      {\r\n        \"components\": [\r\n          {\r\n            \"internalType\": \"uint256\",\r\n            \"name\": \"id\",\r\n            \"type\": \"uint256\"\r\n          },\r\n          {\r\n            \"internalType\": \"string\",\r\n            \"name\": \"make\",\r\n            \"type\": \"string\"\r\n          },\r\n          {\r\n            \"internalType\": \"string\",\r\n            \"name\": \"model\",\r\n            \"type\": \"string\"\r\n          },\r\n          {\r\n            \"internalType\": \"string\",\r\n            \"name\": \"imageUrl\",\r\n            \"type\": \"string\"\r\n          },\r\n          {\r\n            \"internalType\": \"string\",\r\n            \"name\": \"year\",\r\n            \"type\": \"string\"\r\n          },\r\n          {\r\n            \"internalType\": \"address\",\r\n            \"name\": \"seller\",\r\n            \"type\": \"address\"\r\n          },\r\n          {\r\n            \"internalType\": \"uint256\",\r\n            \"name\": \"price\",\r\n            \"type\": \"uint256\"\r\n          },\r\n          {\r\n            \"internalType\": \"string\",\r\n            \"name\": \"description\",\r\n            \"type\": \"string\"\r\n          },\r\n          {\r\n            \"internalType\": \"bool\",\r\n            \"name\": \"isSold\",\r\n            \"type\": \"bool\"\r\n          }\r\n        ],\r\n        \"internalType\": \"struct ClassicCar\",\r\n        \"name\": \"\",\r\n        \"type\": \"tuple\"\r\n      }\r\n    ],\r\n    \"stateMutability\": \"view\",\r\n    \"type\": \"function\"\r\n  },\r\n  {\r\n    \"inputs\": [],\r\n    \"name\": \"getNumberOfCars\",\r\n    \"outputs\": [\r\n      {\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"\",\r\n        \"type\": \"uint256\"\r\n      }\r\n    ],\r\n    \"stateMutability\": \"view\",\r\n    \"type\": \"function\"\r\n  },\r\n  {\r\n    \"inputs\": [\r\n      {\r\n        \"internalType\": \"address\",\r\n        \"name\": \"_seller\",\r\n        \"type\": \"address\"\r\n      }\r\n    ],\r\n    \"name\": \"getSellerCars\",\r\n    \"outputs\": [\r\n      {\r\n        \"internalType\": \"uint256[]\",\r\n        \"name\": \"\",\r\n        \"type\": \"uint256[]\"\r\n      }\r\n    ],\r\n    \"stateMutability\": \"view\",\r\n    \"type\": \"function\"\r\n  },\r\n  {\r\n    \"inputs\": [\r\n      {\r\n        \"internalType\": \"string\",\r\n        \"name\": \"_make\",\r\n        \"type\": \"string\"\r\n      },\r\n      {\r\n        \"internalType\": \"string\",\r\n        \"name\": \"_model\",\r\n        \"type\": \"string\"\r\n      },\r\n      {\r\n        \"internalType\": \"string\",\r\n        \"name\": \"_imageUrl\",\r\n        \"type\": \"string\"\r\n      },\r\n      {\r\n        \"internalType\": \"string\",\r\n        \"name\": \"_year\",\r\n        \"type\": \"string\"\r\n      },\r\n      {\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"_price\",\r\n        \"type\": \"uint256\"\r\n      },\r\n      {\r\n        \"internalType\": \"string\",\r\n        \"name\": \"description\",\r\n        \"type\": \"string\"\r\n      }\r\n    ],\r\n    \"name\": \"listCar\",\r\n    \"outputs\": [],\r\n    \"stateMutability\": \"nonpayable\",\r\n    \"type\": \"function\"\r\n  },\r\n  {\r\n    \"inputs\": [],\r\n    \"name\": \"nextCarId\",\r\n    \"outputs\": [\r\n      {\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"\",\r\n        \"type\": \"uint256\"\r\n      }\r\n    ],\r\n    \"stateMutability\": \"view\",\r\n    \"type\": \"function\"\r\n  },\r\n  {\r\n    \"inputs\": [\r\n      {\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"carId\",\r\n        \"type\": \"uint256\"\r\n      }\r\n    ],\r\n    \"name\": \"removeCar\",\r\n    \"outputs\": [],\r\n    \"stateMutability\": \"nonpayable\",\r\n    \"type\": \"function\"\r\n  },\r\n  {\r\n    \"inputs\": [\r\n      {\r\n        \"internalType\": \"address\",\r\n        \"name\": \"\",\r\n        \"type\": \"address\"\r\n      },\r\n      {\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"\",\r\n        \"type\": \"uint256\"\r\n      }\r\n    ],\r\n    \"name\": \"sellerCars\",\r\n    \"outputs\": [\r\n      {\r\n        \"internalType\": \"uint256\",\r\n        \"name\": \"\",\r\n        \"type\": \"uint256\"\r\n      }\r\n    ],\r\n    \"stateMutability\": \"view\",\r\n    \"type\": \"function\"\r\n  }\r\n]\r\n","// Currently in sync with Node.js lib/assert.js\n// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b\n\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nvar _require = require('./internal/errors'),\n  _require$codes = _require.codes,\n  ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,\n  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;\nvar AssertionError = require('./internal/assert/assertion_error');\nvar _require2 = require('util/'),\n  inspect = _require2.inspect;\nvar _require$types = require('util/').types,\n  isPromise = _require$types.isPromise,\n  isRegExp = _require$types.isRegExp;\nvar objectAssign = require('object.assign/polyfill')();\nvar objectIs = require('object-is/polyfill')();\nvar RegExpPrototypeTest = require('call-bind/callBound')('RegExp.prototype.test');\nvar errorCache = new Map();\nvar isDeepEqual;\nvar isDeepStrictEqual;\nvar parseExpressionAt;\nvar findNodeAround;\nvar decoder;\nfunction lazyLoadComparison() {\n  var comparison = require('./internal/util/comparisons');\n  isDeepEqual = comparison.isDeepEqual;\n  isDeepStrictEqual = comparison.isDeepStrictEqual;\n}\n\n// Escape control characters but not \\n and \\t to keep the line breaks and\n// indentation intact.\n// eslint-disable-next-line no-control-regex\nvar escapeSequencesRegExp = /[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f]/g;\nvar meta = [\"\\\\u0000\", \"\\\\u0001\", \"\\\\u0002\", \"\\\\u0003\", \"\\\\u0004\", \"\\\\u0005\", \"\\\\u0006\", \"\\\\u0007\", '\\\\b', '', '', \"\\\\u000b\", '\\\\f', '', \"\\\\u000e\", \"\\\\u000f\", \"\\\\u0010\", \"\\\\u0011\", \"\\\\u0012\", \"\\\\u0013\", \"\\\\u0014\", \"\\\\u0015\", \"\\\\u0016\", \"\\\\u0017\", \"\\\\u0018\", \"\\\\u0019\", \"\\\\u001a\", \"\\\\u001b\", \"\\\\u001c\", \"\\\\u001d\", \"\\\\u001e\", \"\\\\u001f\"];\nvar escapeFn = function escapeFn(str) {\n  return meta[str.charCodeAt(0)];\n};\nvar warned = false;\n\n// The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\nvar NO_EXCEPTION_SENTINEL = {};\n\n// All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided. All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction innerFail(obj) {\n  if (obj.message instanceof Error) throw obj.message;\n  throw new AssertionError(obj);\n}\nfunction fail(actual, expected, message, operator, stackStartFn) {\n  var argsLen = arguments.length;\n  var internalMessage;\n  if (argsLen === 0) {\n    internalMessage = 'Failed';\n  } else if (argsLen === 1) {\n    message = actual;\n    actual = undefined;\n  } else {\n    if (warned === false) {\n      warned = true;\n      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);\n      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');\n    }\n    if (argsLen === 2) operator = '!=';\n  }\n  if (message instanceof Error) throw message;\n  var errArgs = {\n    actual: actual,\n    expected: expected,\n    operator: operator === undefined ? 'fail' : operator,\n    stackStartFn: stackStartFn || fail\n  };\n  if (message !== undefined) {\n    errArgs.message = message;\n  }\n  var err = new AssertionError(errArgs);\n  if (internalMessage) {\n    err.message = internalMessage;\n    err.generatedMessage = true;\n  }\n  throw err;\n}\nassert.fail = fail;\n\n// The AssertionError is defined in internal/error.\nassert.AssertionError = AssertionError;\nfunction innerOk(fn, argLen, value, message) {\n  if (!value) {\n    var generatedMessage = false;\n    if (argLen === 0) {\n      generatedMessage = true;\n      message = 'No value argument passed to `assert.ok()`';\n    } else if (message instanceof Error) {\n      throw message;\n    }\n    var err = new AssertionError({\n      actual: value,\n      expected: true,\n      message: message,\n      operator: '==',\n      stackStartFn: fn\n    });\n    err.generatedMessage = generatedMessage;\n    throw err;\n  }\n}\n\n// Pure assertion tests whether a value is truthy, as determined\n// by !!value.\nfunction ok() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  innerOk.apply(void 0, [ok, args.length].concat(args));\n}\nassert.ok = ok;\n\n// The equality assertion tests shallow, coercive equality with ==.\n/* eslint-disable no-restricted-properties */\nassert.equal = function equal(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  // eslint-disable-next-line eqeqeq\n  if (actual != expected) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: '==',\n      stackStartFn: equal\n    });\n  }\n};\n\n// The non-equality assertion tests for whether two objects are not\n// equal with !=.\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  // eslint-disable-next-line eqeqeq\n  if (actual == expected) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: '!=',\n      stackStartFn: notEqual\n    });\n  }\n};\n\n// The equivalence assertion tests a deep equality relation.\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  if (isDeepEqual === undefined) lazyLoadComparison();\n  if (!isDeepEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'deepEqual',\n      stackStartFn: deepEqual\n    });\n  }\n};\n\n// The non-equivalence assertion tests for any deep inequality.\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  if (isDeepEqual === undefined) lazyLoadComparison();\n  if (isDeepEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'notDeepEqual',\n      stackStartFn: notDeepEqual\n    });\n  }\n};\n/* eslint-enable */\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  if (isDeepEqual === undefined) lazyLoadComparison();\n  if (!isDeepStrictEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'deepStrictEqual',\n      stackStartFn: deepStrictEqual\n    });\n  }\n};\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  if (isDeepEqual === undefined) lazyLoadComparison();\n  if (isDeepStrictEqual(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'notDeepStrictEqual',\n      stackStartFn: notDeepStrictEqual\n    });\n  }\n}\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  if (!objectIs(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'strictEqual',\n      stackStartFn: strictEqual\n    });\n  }\n};\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (arguments.length < 2) {\n    throw new ERR_MISSING_ARGS('actual', 'expected');\n  }\n  if (objectIs(actual, expected)) {\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: 'notStrictEqual',\n      stackStartFn: notStrictEqual\n    });\n  }\n};\nvar Comparison = /*#__PURE__*/_createClass(function Comparison(obj, keys, actual) {\n  var _this = this;\n  _classCallCheck(this, Comparison);\n  keys.forEach(function (key) {\n    if (key in obj) {\n      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {\n        _this[key] = actual[key];\n      } else {\n        _this[key] = obj[key];\n      }\n    }\n  });\n});\nfunction compareExceptionKey(actual, expected, key, message, keys, fn) {\n  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {\n    if (!message) {\n      // Create placeholder objects to create a nice output.\n      var a = new Comparison(actual, keys);\n      var b = new Comparison(expected, keys, actual);\n      var err = new AssertionError({\n        actual: a,\n        expected: b,\n        operator: 'deepStrictEqual',\n        stackStartFn: fn\n      });\n      err.actual = actual;\n      err.expected = expected;\n      err.operator = fn.name;\n      throw err;\n    }\n    innerFail({\n      actual: actual,\n      expected: expected,\n      message: message,\n      operator: fn.name,\n      stackStartFn: fn\n    });\n  }\n}\nfunction expectedException(actual, expected, msg, fn) {\n  if (typeof expected !== 'function') {\n    if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);\n    // assert.doesNotThrow does not accept objects.\n    if (arguments.length === 2) {\n      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);\n    }\n\n    // Handle primitives properly.\n    if (_typeof(actual) !== 'object' || actual === null) {\n      var err = new AssertionError({\n        actual: actual,\n        expected: expected,\n        message: msg,\n        operator: 'deepStrictEqual',\n        stackStartFn: fn\n      });\n      err.operator = fn.name;\n      throw err;\n    }\n    var keys = Object.keys(expected);\n    // Special handle errors to make sure the name and the message are compared\n    // as well.\n    if (expected instanceof Error) {\n      keys.push('name', 'message');\n    } else if (keys.length === 0) {\n      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');\n    }\n    if (isDeepEqual === undefined) lazyLoadComparison();\n    keys.forEach(function (key) {\n      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {\n        return;\n      }\n      compareExceptionKey(actual, expected, key, msg, keys, fn);\n    });\n    return true;\n  }\n  // Guard instanceof against arrow functions as they don't have a prototype.\n  if (expected.prototype !== undefined && actual instanceof expected) {\n    return true;\n  }\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n  return expected.call({}, actual) === true;\n}\nfunction getActual(fn) {\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);\n  }\n  try {\n    fn();\n  } catch (e) {\n    return e;\n  }\n  return NO_EXCEPTION_SENTINEL;\n}\nfunction checkIsPromise(obj) {\n  // Accept native ES6 promises and promises that are implemented in a similar\n  // way. Do not accept thenables that use a function as `obj` and that have no\n  // `catch` handler.\n\n  // TODO: thenables are checked up until they have the correct methods,\n  // but according to documentation, the `then` method should receive\n  // the `fulfill` and `reject` arguments as well or it may be never resolved.\n\n  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';\n}\nfunction waitForActual(promiseFn) {\n  return Promise.resolve().then(function () {\n    var resultPromise;\n    if (typeof promiseFn === 'function') {\n      // Return a rejected promise if `promiseFn` throws synchronously.\n      resultPromise = promiseFn();\n      // Fail in case no promise is returned.\n      if (!checkIsPromise(resultPromise)) {\n        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);\n      }\n    } else if (checkIsPromise(promiseFn)) {\n      resultPromise = promiseFn;\n    } else {\n      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);\n    }\n    return Promise.resolve().then(function () {\n      return resultPromise;\n    }).then(function () {\n      return NO_EXCEPTION_SENTINEL;\n    }).catch(function (e) {\n      return e;\n    });\n  });\n}\nfunction expectsError(stackStartFn, actual, error, message) {\n  if (typeof error === 'string') {\n    if (arguments.length === 4) {\n      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);\n    }\n    if (_typeof(actual) === 'object' && actual !== null) {\n      if (actual.message === error) {\n        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', \"The error message \\\"\".concat(actual.message, \"\\\" is identical to the message.\"));\n      }\n    } else if (actual === error) {\n      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', \"The error \\\"\".concat(actual, \"\\\" is identical to the message.\"));\n    }\n    message = error;\n    error = undefined;\n  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);\n  }\n  if (actual === NO_EXCEPTION_SENTINEL) {\n    var details = '';\n    if (error && error.name) {\n      details += \" (\".concat(error.name, \")\");\n    }\n    details += message ? \": \".concat(message) : '.';\n    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';\n    innerFail({\n      actual: undefined,\n      expected: error,\n      operator: stackStartFn.name,\n      message: \"Missing expected \".concat(fnType).concat(details),\n      stackStartFn: stackStartFn\n    });\n  }\n  if (error && !expectedException(actual, error, message, stackStartFn)) {\n    throw actual;\n  }\n}\nfunction expectsNoError(stackStartFn, actual, error, message) {\n  if (actual === NO_EXCEPTION_SENTINEL) return;\n  if (typeof error === 'string') {\n    message = error;\n    error = undefined;\n  }\n  if (!error || expectedException(actual, error)) {\n    var details = message ? \": \".concat(message) : '.';\n    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';\n    innerFail({\n      actual: actual,\n      expected: error,\n      operator: stackStartFn.name,\n      message: \"Got unwanted \".concat(fnType).concat(details, \"\\n\") + \"Actual message: \\\"\".concat(actual && actual.message, \"\\\"\"),\n      stackStartFn: stackStartFn\n    });\n  }\n  throw actual;\n}\nassert.throws = function throws(promiseFn) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));\n};\nassert.rejects = function rejects(promiseFn) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n  return waitForActual(promiseFn).then(function (result) {\n    return expectsError.apply(void 0, [rejects, result].concat(args));\n  });\n};\nassert.doesNotThrow = function doesNotThrow(fn) {\n  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));\n};\nassert.doesNotReject = function doesNotReject(fn) {\n  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n  return waitForActual(fn).then(function (result) {\n    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));\n  });\n};\nassert.ifError = function ifError(err) {\n  if (err !== null && err !== undefined) {\n    var message = 'ifError got unwanted exception: ';\n    if (_typeof(err) === 'object' && typeof err.message === 'string') {\n      if (err.message.length === 0 && err.constructor) {\n        message += err.constructor.name;\n      } else {\n        message += err.message;\n      }\n    } else {\n      message += inspect(err);\n    }\n    var newErr = new AssertionError({\n      actual: err,\n      expected: null,\n      operator: 'ifError',\n      message: message,\n      stackStartFn: ifError\n    });\n\n    // Make sure we actually have a stack trace!\n    var origStack = err.stack;\n    if (typeof origStack === 'string') {\n      // This will remove any duplicated frames from the error frames taken\n      // from within `ifError` and add the original error frames to the newly\n      // created ones.\n      var tmp2 = origStack.split('\\n');\n      tmp2.shift();\n      // Filter all frames existing in err.stack.\n      var tmp1 = newErr.stack.split('\\n');\n      for (var i = 0; i < tmp2.length; i++) {\n        // Find the first occurrence of the frame.\n        var pos = tmp1.indexOf(tmp2[i]);\n        if (pos !== -1) {\n          // Only keep new frames.\n          tmp1 = tmp1.slice(0, pos);\n          break;\n        }\n      }\n      newErr.stack = \"\".concat(tmp1.join('\\n'), \"\\n\").concat(tmp2.join('\\n'));\n    }\n    throw newErr;\n  }\n};\n\n// Currently in sync with Node.js lib/assert.js\n// https://github.com/nodejs/node/commit/2a871df3dfb8ea663ef5e1f8f62701ec51384ecb\nfunction internalMatch(string, regexp, message, fn, fnName) {\n  if (!isRegExp(regexp)) {\n    throw new ERR_INVALID_ARG_TYPE('regexp', 'RegExp', regexp);\n  }\n  var match = fnName === 'match';\n  if (typeof string !== 'string' || RegExpPrototypeTest(regexp, string) !== match) {\n    if (message instanceof Error) {\n      throw message;\n    }\n    var generatedMessage = !message;\n\n    // 'The input was expected to not match the regular expression ' +\n    message = message || (typeof string !== 'string' ? 'The \"string\" argument must be of type string. Received type ' + \"\".concat(_typeof(string), \" (\").concat(inspect(string), \")\") : (match ? 'The input did not match the regular expression ' : 'The input was expected to not match the regular expression ') + \"\".concat(inspect(regexp), \". Input:\\n\\n\").concat(inspect(string), \"\\n\"));\n    var err = new AssertionError({\n      actual: string,\n      expected: regexp,\n      message: message,\n      operator: fnName,\n      stackStartFn: fn\n    });\n    err.generatedMessage = generatedMessage;\n    throw err;\n  }\n}\nassert.match = function match(string, regexp, message) {\n  internalMatch(string, regexp, message, match, 'match');\n};\nassert.doesNotMatch = function doesNotMatch(string, regexp, message) {\n  internalMatch(string, regexp, message, doesNotMatch, 'doesNotMatch');\n};\n\n// Expose a strict only variant of assert\nfunction strict() {\n  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    args[_key6] = arguments[_key6];\n  }\n  innerOk.apply(void 0, [strict, args.length].concat(args));\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;","// Currently in sync with Node.js lib/internal/assert/assertion_error.js\n// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c\n\n'use strict';\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar _require = require('util/'),\n  inspect = _require.inspect;\nvar _require2 = require('../errors'),\n  ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n  return str.substring(this_len - search.length, this_len) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat\nfunction repeat(str, count) {\n  count = Math.floor(count);\n  if (str.length == 0 || count == 0) return '';\n  var maxCount = str.length * count;\n  count = Math.floor(Math.log(count) / Math.log(2));\n  while (count) {\n    str += str;\n    count--;\n  }\n  str += str.substring(0, maxCount - str.length);\n  return str;\n}\nvar blue = '';\nvar green = '';\nvar red = '';\nvar white = '';\nvar kReadableOperator = {\n  deepStrictEqual: 'Expected values to be strictly deep-equal:',\n  strictEqual: 'Expected values to be strictly equal:',\n  strictEqualObject: 'Expected \"actual\" to be reference-equal to \"expected\":',\n  deepEqual: 'Expected values to be loosely deep-equal:',\n  equal: 'Expected values to be loosely equal:',\n  notDeepStrictEqual: 'Expected \"actual\" not to be strictly deep-equal to:',\n  notStrictEqual: 'Expected \"actual\" to be strictly unequal to:',\n  notStrictEqualObject: 'Expected \"actual\" not to be reference-equal to \"expected\":',\n  notDeepEqual: 'Expected \"actual\" not to be loosely deep-equal to:',\n  notEqual: 'Expected \"actual\" to be loosely unequal to:',\n  notIdentical: 'Values identical but not reference-equal:'\n};\n\n// Comparing short primitives should just show === / !== instead of using the\n// diff.\nvar kMaxShortLength = 10;\nfunction copyError(source) {\n  var keys = Object.keys(source);\n  var target = Object.create(Object.getPrototypeOf(source));\n  keys.forEach(function (key) {\n    target[key] = source[key];\n  });\n  Object.defineProperty(target, 'message', {\n    value: source.message\n  });\n  return target;\n}\nfunction inspectValue(val) {\n  // The util.inspect default values could be changed. This makes sure the\n  // error messages contain the necessary information nevertheless.\n  return inspect(val, {\n    compact: false,\n    customInspect: false,\n    depth: 1000,\n    maxArrayLength: Infinity,\n    // Assert compares only enumerable properties (with a few exceptions).\n    showHidden: false,\n    // Having a long line as error is better than wrapping the line for\n    // comparison for now.\n    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we\n    // have meta information about the inspected properties (i.e., know where\n    // in what line the property starts and ends).\n    breakLength: Infinity,\n    // Assert does not detect proxies currently.\n    showProxy: false,\n    sorted: true,\n    // Inspect getters as we also check them when comparing entries.\n    getters: true\n  });\n}\nfunction createErrDiff(actual, expected, operator) {\n  var other = '';\n  var res = '';\n  var lastPos = 0;\n  var end = '';\n  var skipped = false;\n  var actualInspected = inspectValue(actual);\n  var actualLines = actualInspected.split('\\n');\n  var expectedLines = inspectValue(expected).split('\\n');\n  var i = 0;\n  var indicator = '';\n\n  // In case both values are objects explicitly mark them as not reference equal\n  // for the `strictEqual` operator.\n  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {\n    operator = 'strictEqualObject';\n  }\n\n  // If \"actual\" and \"expected\" fit on a single line and they are not strictly\n  // equal, check further special handling.\n  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {\n    var inputLength = actualLines[0].length + expectedLines[0].length;\n    // If the character length of \"actual\" and \"expected\" together is less than\n    // kMaxShortLength and if neither is an object and at least one of them is\n    // not `zero`, use the strict equal comparison to visualize the output.\n    if (inputLength <= kMaxShortLength) {\n      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {\n        // -0 === +0\n        return \"\".concat(kReadableOperator[operator], \"\\n\\n\") + \"\".concat(actualLines[0], \" !== \").concat(expectedLines[0], \"\\n\");\n      }\n    } else if (operator !== 'strictEqualObject') {\n      // If the stderr is a tty and the input length is lower than the current\n      // columns per line, add a mismatch indicator below the output. If it is\n      // not a tty, use a default value of 80 characters.\n      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;\n      if (inputLength < maxLength) {\n        while (actualLines[0][i] === expectedLines[0][i]) {\n          i++;\n        }\n        // Ignore the first characters.\n        if (i > 2) {\n          // Add position indicator for the first mismatch in case it is a\n          // single line and the input length is less than the column length.\n          indicator = \"\\n  \".concat(repeat(' ', i), \"^\");\n          i = 0;\n        }\n      }\n    }\n  }\n\n  // Remove all ending lines that match (this optimizes the output for\n  // readability by reducing the number of total changed lines).\n  var a = actualLines[actualLines.length - 1];\n  var b = expectedLines[expectedLines.length - 1];\n  while (a === b) {\n    if (i++ < 2) {\n      end = \"\\n  \".concat(a).concat(end);\n    } else {\n      other = a;\n    }\n    actualLines.pop();\n    expectedLines.pop();\n    if (actualLines.length === 0 || expectedLines.length === 0) break;\n    a = actualLines[actualLines.length - 1];\n    b = expectedLines[expectedLines.length - 1];\n  }\n  var maxLines = Math.max(actualLines.length, expectedLines.length);\n  // Strict equal with identical objects that are not identical by reference.\n  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })\n  if (maxLines === 0) {\n    // We have to get the result again. The lines were all removed before.\n    var _actualLines = actualInspected.split('\\n');\n\n    // Only remove lines in case it makes sense to collapse those.\n    // TODO: Accept env to always show the full error.\n    if (_actualLines.length > 30) {\n      _actualLines[26] = \"\".concat(blue, \"...\").concat(white);\n      while (_actualLines.length > 27) {\n        _actualLines.pop();\n      }\n    }\n    return \"\".concat(kReadableOperator.notIdentical, \"\\n\\n\").concat(_actualLines.join('\\n'), \"\\n\");\n  }\n  if (i > 3) {\n    end = \"\\n\".concat(blue, \"...\").concat(white).concat(end);\n    skipped = true;\n  }\n  if (other !== '') {\n    end = \"\\n  \".concat(other).concat(end);\n    other = '';\n  }\n  var printedLines = 0;\n  var msg = kReadableOperator[operator] + \"\\n\".concat(green, \"+ actual\").concat(white, \" \").concat(red, \"- expected\").concat(white);\n  var skippedMsg = \" \".concat(blue, \"...\").concat(white, \" Lines skipped\");\n  for (i = 0; i < maxLines; i++) {\n    // Only extra expected lines exist\n    var cur = i - lastPos;\n    if (actualLines.length < i + 1) {\n      // If the last diverging line is more than one line above and the\n      // current line is at least line three, add some of the former lines and\n      // also add dots to indicate skipped entries.\n      if (cur > 1 && i > 2) {\n        if (cur > 4) {\n          res += \"\\n\".concat(blue, \"...\").concat(white);\n          skipped = true;\n        } else if (cur > 3) {\n          res += \"\\n  \".concat(expectedLines[i - 2]);\n          printedLines++;\n        }\n        res += \"\\n  \".concat(expectedLines[i - 1]);\n        printedLines++;\n      }\n      // Mark the current line as the last diverging one.\n      lastPos = i;\n      // Add the expected line to the cache.\n      other += \"\\n\".concat(red, \"-\").concat(white, \" \").concat(expectedLines[i]);\n      printedLines++;\n      // Only extra actual lines exist\n    } else if (expectedLines.length < i + 1) {\n      // If the last diverging line is more than one line above and the\n      // current line is at least line three, add some of the former lines and\n      // also add dots to indicate skipped entries.\n      if (cur > 1 && i > 2) {\n        if (cur > 4) {\n          res += \"\\n\".concat(blue, \"...\").concat(white);\n          skipped = true;\n        } else if (cur > 3) {\n          res += \"\\n  \".concat(actualLines[i - 2]);\n          printedLines++;\n        }\n        res += \"\\n  \".concat(actualLines[i - 1]);\n        printedLines++;\n      }\n      // Mark the current line as the last diverging one.\n      lastPos = i;\n      // Add the actual line to the result.\n      res += \"\\n\".concat(green, \"+\").concat(white, \" \").concat(actualLines[i]);\n      printedLines++;\n      // Lines diverge\n    } else {\n      var expectedLine = expectedLines[i];\n      var actualLine = actualLines[i];\n      // If the lines diverge, specifically check for lines that only diverge by\n      // a trailing comma. In that case it is actually identical and we should\n      // mark it as such.\n      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine);\n      // If the expected line has a trailing comma but is otherwise identical,\n      // add a comma at the end of the actual line. Otherwise the output could\n      // look weird as in:\n      //\n      //   [\n      //     1         // No comma at the end!\n      // +   2\n      //   ]\n      //\n      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {\n        divergingLines = false;\n        actualLine += ',';\n      }\n      if (divergingLines) {\n        // If the last diverging line is more than one line above and the\n        // current line is at least line three, add some of the former lines and\n        // also add dots to indicate skipped entries.\n        if (cur > 1 && i > 2) {\n          if (cur > 4) {\n            res += \"\\n\".concat(blue, \"...\").concat(white);\n            skipped = true;\n          } else if (cur > 3) {\n            res += \"\\n  \".concat(actualLines[i - 2]);\n            printedLines++;\n          }\n          res += \"\\n  \".concat(actualLines[i - 1]);\n          printedLines++;\n        }\n        // Mark the current line as the last diverging one.\n        lastPos = i;\n        // Add the actual line to the result and cache the expected diverging\n        // line so consecutive diverging lines show up as +++--- and not +-+-+-.\n        res += \"\\n\".concat(green, \"+\").concat(white, \" \").concat(actualLine);\n        other += \"\\n\".concat(red, \"-\").concat(white, \" \").concat(expectedLine);\n        printedLines += 2;\n        // Lines are identical\n      } else {\n        // Add all cached information to the result before adding other things\n        // and reset the cache.\n        res += other;\n        other = '';\n        // If the last diverging line is exactly one line above or if it is the\n        // very first line, add the line to the result.\n        if (cur === 1 || i === 0) {\n          res += \"\\n  \".concat(actualLine);\n          printedLines++;\n        }\n      }\n    }\n    // Inspected object to big (Show ~20 rows max)\n    if (printedLines > 20 && i < maxLines - 2) {\n      return \"\".concat(msg).concat(skippedMsg, \"\\n\").concat(res, \"\\n\").concat(blue, \"...\").concat(white).concat(other, \"\\n\") + \"\".concat(blue, \"...\").concat(white);\n    }\n  }\n  return \"\".concat(msg).concat(skipped ? skippedMsg : '', \"\\n\").concat(res).concat(other).concat(end).concat(indicator);\n}\nvar AssertionError = /*#__PURE__*/function (_Error, _inspect$custom) {\n  _inherits(AssertionError, _Error);\n  var _super = _createSuper(AssertionError);\n  function AssertionError(options) {\n    var _this;\n    _classCallCheck(this, AssertionError);\n    if (_typeof(options) !== 'object' || options === null) {\n      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n    }\n    var message = options.message,\n      operator = options.operator,\n      stackStartFn = options.stackStartFn;\n    var actual = options.actual,\n      expected = options.expected;\n    var limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n    if (message != null) {\n      _this = _super.call(this, String(message));\n    } else {\n      if (process.stderr && process.stderr.isTTY) {\n        // Reset on each call to make sure we handle dynamically set environment\n        // variables correct.\n        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {\n          blue = \"\\x1B[34m\";\n          green = \"\\x1B[32m\";\n          white = \"\\x1B[39m\";\n          red = \"\\x1B[31m\";\n        } else {\n          blue = '';\n          green = '';\n          white = '';\n          red = '';\n        }\n      }\n      // Prevent the error stack from being visible by duplicating the error\n      // in a very close way to the original in case both sides are actually\n      // instances of Error.\n      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {\n        actual = copyError(actual);\n        expected = copyError(expected);\n      }\n      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {\n        _this = _super.call(this, createErrDiff(actual, expected, operator));\n      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {\n        // In case the objects are equal but the operator requires unequal, show\n        // the first object and say A equals B\n        var base = kReadableOperator[operator];\n        var res = inspectValue(actual).split('\\n');\n\n        // In case \"actual\" is an object, it should not be reference equal.\n        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {\n          base = kReadableOperator.notStrictEqualObject;\n        }\n\n        // Only remove lines in case it makes sense to collapse those.\n        // TODO: Accept env to always show the full error.\n        if (res.length > 30) {\n          res[26] = \"\".concat(blue, \"...\").concat(white);\n          while (res.length > 27) {\n            res.pop();\n          }\n        }\n\n        // Only print a single input.\n        if (res.length === 1) {\n          _this = _super.call(this, \"\".concat(base, \" \").concat(res[0]));\n        } else {\n          _this = _super.call(this, \"\".concat(base, \"\\n\\n\").concat(res.join('\\n'), \"\\n\"));\n        }\n      } else {\n        var _res = inspectValue(actual);\n        var other = '';\n        var knownOperators = kReadableOperator[operator];\n        if (operator === 'notDeepEqual' || operator === 'notEqual') {\n          _res = \"\".concat(kReadableOperator[operator], \"\\n\\n\").concat(_res);\n          if (_res.length > 1024) {\n            _res = \"\".concat(_res.slice(0, 1021), \"...\");\n          }\n        } else {\n          other = \"\".concat(inspectValue(expected));\n          if (_res.length > 512) {\n            _res = \"\".concat(_res.slice(0, 509), \"...\");\n          }\n          if (other.length > 512) {\n            other = \"\".concat(other.slice(0, 509), \"...\");\n          }\n          if (operator === 'deepEqual' || operator === 'equal') {\n            _res = \"\".concat(knownOperators, \"\\n\\n\").concat(_res, \"\\n\\nshould equal\\n\\n\");\n          } else {\n            other = \" \".concat(operator, \" \").concat(other);\n          }\n        }\n        _this = _super.call(this, \"\".concat(_res).concat(other));\n      }\n    }\n    Error.stackTraceLimit = limit;\n    _this.generatedMessage = !message;\n    Object.defineProperty(_assertThisInitialized(_this), 'name', {\n      value: 'AssertionError [ERR_ASSERTION]',\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n    _this.code = 'ERR_ASSERTION';\n    _this.actual = actual;\n    _this.expected = expected;\n    _this.operator = operator;\n    if (Error.captureStackTrace) {\n      // eslint-disable-next-line no-restricted-syntax\n      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);\n    }\n    // Create error message including the error code in the name.\n    _this.stack;\n    // Reset the name.\n    _this.name = 'AssertionError';\n    return _possibleConstructorReturn(_this);\n  }\n  _createClass(AssertionError, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.name, \" [\").concat(this.code, \"]: \").concat(this.message);\n    }\n  }, {\n    key: _inspect$custom,\n    value: function value(recurseTimes, ctx) {\n      // This limits the `actual` and `expected` property default inspection to\n      // the minimum depth. Otherwise those values would be too verbose compared\n      // to the actual error message which contains a combined view of these two\n      // input values.\n      return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {\n        customInspect: false,\n        depth: 0\n      }));\n    }\n  }]);\n  return AssertionError;\n}( /*#__PURE__*/_wrapNativeSuper(Error), inspect.custom);\nmodule.exports = AssertionError;","// Currently in sync with Node.js lib/internal/errors.js\n// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f\n\n/* eslint node-core/documented-errors: \"error\" */\n/* eslint node-core/alphabetize-errors: \"error\" */\n/* eslint node-core/prefer-util-format-errors: \"error\" */\n\n'use strict';\n\n// The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change, the code should not.\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar codes = {};\n\n// Lazy loaded\nvar assert;\nvar util;\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n  var NodeError = /*#__PURE__*/function (_Base) {\n    _inherits(NodeError, _Base);\n    var _super = _createSuper(NodeError);\n    function NodeError(arg1, arg2, arg3) {\n      var _this;\n      _classCallCheck(this, NodeError);\n      _this = _super.call(this, getMessage(arg1, arg2, arg3));\n      _this.code = code;\n      return _this;\n    }\n    return _createClass(NodeError);\n  }(Base);\n  codes[code] = NodeError;\n}\n\n// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n  return str.substring(this_len - search.length, this_len) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\ncreateErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The \"%s\" argument is ambiguous. %s', TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  if (assert === undefined) assert = require('../assert');\n  assert(typeof name === 'string', \"'name' must be a string\");\n\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n  var msg;\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  // TODO(BridgeAR): Improve the output by showing `null` and similar.\n  msg += \". Received type \".concat(_typeof(actual));\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {\n  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';\n  if (util === undefined) util = require('util/');\n  var inspected = util.inspect(value);\n  if (inspected.length > 128) {\n    inspected = \"\".concat(inspected.slice(0, 128), \"...\");\n  }\n  return \"The argument '\".concat(name, \"' \").concat(reason, \". Received \").concat(inspected);\n}, TypeError, RangeError);\ncreateErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {\n  var type;\n  if (value && value.constructor && value.constructor.name) {\n    type = \"instance of \".concat(value.constructor.name);\n  } else {\n    type = \"type \".concat(_typeof(value));\n  }\n  return \"Expected \".concat(input, \" to be returned from the \\\"\").concat(name, \"\\\"\") + \" function but got \".concat(type, \".\");\n}, TypeError);\ncreateErrorType('ERR_MISSING_ARGS', function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (assert === undefined) assert = require('../assert');\n  assert(args.length > 0, 'At least one arg needs to be specified');\n  var msg = 'The ';\n  var len = args.length;\n  args = args.map(function (a) {\n    return \"\\\"\".concat(a, \"\\\"\");\n  });\n  switch (len) {\n    case 1:\n      msg += \"\".concat(args[0], \" argument\");\n      break;\n    case 2:\n      msg += \"\".concat(args[0], \" and \").concat(args[1], \" arguments\");\n      break;\n    default:\n      msg += args.slice(0, len - 1).join(', ');\n      msg += \", and \".concat(args[len - 1], \" arguments\");\n      break;\n  }\n  return \"\".concat(msg, \" must be specified\");\n}, TypeError);\nmodule.exports.codes = codes;","// Currently in sync with Node.js lib/internal/util/comparisons.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n'use strict';\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar regexFlagsSupported = /a/g.flags !== undefined;\nvar arrayFromSet = function arrayFromSet(set) {\n  var array = [];\n  set.forEach(function (value) {\n    return array.push(value);\n  });\n  return array;\n};\nvar arrayFromMap = function arrayFromMap(map) {\n  var array = [];\n  map.forEach(function (value, key) {\n    return array.push([key, value]);\n  });\n  return array;\n};\nvar objectIs = Object.is ? Object.is : require('object-is');\nvar objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {\n  return [];\n};\nvar numberIsNaN = Number.isNaN ? Number.isNaN : require('is-nan');\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\nvar hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\nvar propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);\nvar objectToString = uncurryThis(Object.prototype.toString);\nvar _require$types = require('util/').types,\n  isAnyArrayBuffer = _require$types.isAnyArrayBuffer,\n  isArrayBufferView = _require$types.isArrayBufferView,\n  isDate = _require$types.isDate,\n  isMap = _require$types.isMap,\n  isRegExp = _require$types.isRegExp,\n  isSet = _require$types.isSet,\n  isNativeError = _require$types.isNativeError,\n  isBoxedPrimitive = _require$types.isBoxedPrimitive,\n  isNumberObject = _require$types.isNumberObject,\n  isStringObject = _require$types.isStringObject,\n  isBooleanObject = _require$types.isBooleanObject,\n  isBigIntObject = _require$types.isBigIntObject,\n  isSymbolObject = _require$types.isSymbolObject,\n  isFloat32Array = _require$types.isFloat32Array,\n  isFloat64Array = _require$types.isFloat64Array;\nfunction isNonIndex(key) {\n  if (key.length === 0 || key.length > 10) return true;\n  for (var i = 0; i < key.length; i++) {\n    var code = key.charCodeAt(i);\n    if (code < 48 || code > 57) return true;\n  }\n  // The maximum size for an array is 2 ** 32 -1.\n  return key.length === 10 && key >= Math.pow(2, 32);\n}\nfunction getOwnNonIndexProperties(value) {\n  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));\n}\n\n// Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n  var x = a.length;\n  var y = b.length;\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nvar ONLY_ENUMERABLE = undefined;\nvar kStrict = true;\nvar kLoose = false;\nvar kNoIterator = 0;\nvar kIsArray = 1;\nvar kIsSet = 2;\nvar kIsMap = 3;\n\n// Check if they have the same source and flags\nfunction areSimilarRegExps(a, b) {\n  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);\n}\nfunction areSimilarFloatArrays(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  for (var offset = 0; offset < a.byteLength; offset++) {\n    if (a[offset] !== b[offset]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction areSimilarTypedArrays(a, b) {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;\n}\nfunction areEqualArrayBuffers(buf1, buf2) {\n  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;\n}\nfunction isEqualBoxedPrimitive(val1, val2) {\n  if (isNumberObject(val1)) {\n    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));\n  }\n  if (isStringObject(val1)) {\n    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);\n  }\n  if (isBooleanObject(val1)) {\n    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);\n  }\n  if (isBigIntObject(val1)) {\n    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);\n  }\n  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);\n}\n\n// Notes: Type tags are historical [[Class]] properties that can be set by\n// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS\n// and retrieved using Object.prototype.toString.call(obj) in JS\n// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n// for a list of tags pre-defined in the spec.\n// There are some unspecified tags in the wild too (e.g. typed array tags).\n// Since tags can be altered, they only serve fast failures\n//\n// Typed arrays and buffers are checked by comparing the content in their\n// underlying ArrayBuffer. This optimization requires that it's\n// reasonable to interpret their underlying memory in the same way,\n// which is checked by comparing their type tags.\n// (e.g. a Uint8Array and a Uint16Array with the same memory content\n// could still be different because they will be interpreted differently).\n//\n// For strict comparison, objects should have\n// a) The same built-in type tags\n// b) The same prototypes.\n\nfunction innerDeepEqual(val1, val2, strict, memos) {\n  // All identical values are equivalent, as determined by ===.\n  if (val1 === val2) {\n    if (val1 !== 0) return true;\n    return strict ? objectIs(val1, val2) : true;\n  }\n\n  // Check more closely if val1 and val2 are equal.\n  if (strict) {\n    if (_typeof(val1) !== 'object') {\n      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);\n    }\n    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {\n      return false;\n    }\n    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {\n      return false;\n    }\n  } else {\n    if (val1 === null || _typeof(val1) !== 'object') {\n      if (val2 === null || _typeof(val2) !== 'object') {\n        // eslint-disable-next-line eqeqeq\n        return val1 == val2;\n      }\n      return false;\n    }\n    if (val2 === null || _typeof(val2) !== 'object') {\n      return false;\n    }\n  }\n  var val1Tag = objectToString(val1);\n  var val2Tag = objectToString(val2);\n  if (val1Tag !== val2Tag) {\n    return false;\n  }\n  if (Array.isArray(val1)) {\n    // Check for sparse arrays and general fast path\n    if (val1.length !== val2.length) {\n      return false;\n    }\n    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);\n    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);\n    if (keys1.length !== keys2.length) {\n      return false;\n    }\n    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);\n  }\n  // [browserify] This triggers on certain types in IE (Map/Set) so we don't\n  // wan't to early return out of the rest of the checks. However we can check\n  // if the second value is one of these values and the first isn't.\n  if (val1Tag === '[object Object]') {\n    // return keyCheck(val1, val2, strict, memos, kNoIterator);\n    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {\n      return false;\n    }\n  }\n  if (isDate(val1)) {\n    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {\n      return false;\n    }\n  } else if (isRegExp(val1)) {\n    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {\n      return false;\n    }\n  } else if (isNativeError(val1) || val1 instanceof Error) {\n    // Do not compare the stack as it might differ even though the error itself\n    // is otherwise identical.\n    if (val1.message !== val2.message || val1.name !== val2.name) {\n      return false;\n    }\n  } else if (isArrayBufferView(val1)) {\n    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {\n      if (!areSimilarFloatArrays(val1, val2)) {\n        return false;\n      }\n    } else if (!areSimilarTypedArrays(val1, val2)) {\n      return false;\n    }\n    // Buffer.compare returns true, so val1.length === val2.length. If they both\n    // only contain numeric keys, we don't need to exam further than checking\n    // the symbols.\n    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);\n    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);\n    if (_keys.length !== _keys2.length) {\n      return false;\n    }\n    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);\n  } else if (isSet(val1)) {\n    if (!isSet(val2) || val1.size !== val2.size) {\n      return false;\n    }\n    return keyCheck(val1, val2, strict, memos, kIsSet);\n  } else if (isMap(val1)) {\n    if (!isMap(val2) || val1.size !== val2.size) {\n      return false;\n    }\n    return keyCheck(val1, val2, strict, memos, kIsMap);\n  } else if (isAnyArrayBuffer(val1)) {\n    if (!areEqualArrayBuffers(val1, val2)) {\n      return false;\n    }\n  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {\n    return false;\n  }\n  return keyCheck(val1, val2, strict, memos, kNoIterator);\n}\nfunction getEnumerables(val, keys) {\n  return keys.filter(function (k) {\n    return propertyIsEnumerable(val, k);\n  });\n}\nfunction keyCheck(val1, val2, strict, memos, iterationType, aKeys) {\n  // For all remaining Object pairs, including Array, objects and Maps,\n  // equivalence is determined by having:\n  // a) The same number of owned enumerable properties\n  // b) The same set of keys/indexes (although not necessarily the same order)\n  // c) Equivalent values for every corresponding key/index\n  // d) For Sets and Maps, equal contents\n  // Note: this accounts for both named and indexed properties on Arrays.\n  if (arguments.length === 5) {\n    aKeys = Object.keys(val1);\n    var bKeys = Object.keys(val2);\n\n    // The pair must have the same number of owned properties.\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n  }\n\n  // Cheap key test\n  var i = 0;\n  for (; i < aKeys.length; i++) {\n    if (!hasOwnProperty(val2, aKeys[i])) {\n      return false;\n    }\n  }\n  if (strict && arguments.length === 5) {\n    var symbolKeysA = objectGetOwnPropertySymbols(val1);\n    if (symbolKeysA.length !== 0) {\n      var count = 0;\n      for (i = 0; i < symbolKeysA.length; i++) {\n        var key = symbolKeysA[i];\n        if (propertyIsEnumerable(val1, key)) {\n          if (!propertyIsEnumerable(val2, key)) {\n            return false;\n          }\n          aKeys.push(key);\n          count++;\n        } else if (propertyIsEnumerable(val2, key)) {\n          return false;\n        }\n      }\n      var symbolKeysB = objectGetOwnPropertySymbols(val2);\n      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {\n        return false;\n      }\n    } else {\n      var _symbolKeysB = objectGetOwnPropertySymbols(val2);\n      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {\n        return false;\n      }\n    }\n  }\n  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {\n    return true;\n  }\n\n  // Use memos to handle cycles.\n  if (memos === undefined) {\n    memos = {\n      val1: new Map(),\n      val2: new Map(),\n      position: 0\n    };\n  } else {\n    // We prevent up to two map.has(x) calls by directly retrieving the value\n    // and checking for undefined. The map can only contain numbers, so it is\n    // safe to check for undefined only.\n    var val2MemoA = memos.val1.get(val1);\n    if (val2MemoA !== undefined) {\n      var val2MemoB = memos.val2.get(val2);\n      if (val2MemoB !== undefined) {\n        return val2MemoA === val2MemoB;\n      }\n    }\n    memos.position++;\n  }\n  memos.val1.set(val1, memos.position);\n  memos.val2.set(val2, memos.position);\n  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);\n  memos.val1.delete(val1);\n  memos.val2.delete(val2);\n  return areEq;\n}\nfunction setHasEqualElement(set, val1, strict, memo) {\n  // Go looking.\n  var setValues = arrayFromSet(set);\n  for (var i = 0; i < setValues.length; i++) {\n    var val2 = setValues[i];\n    if (innerDeepEqual(val1, val2, strict, memo)) {\n      // Remove the matching element to make sure we do not check that again.\n      set.delete(val2);\n      return true;\n    }\n  }\n  return false;\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using\n// Sadly it is not possible to detect corresponding values properly in case the\n// type is a string, number, bigint or boolean. The reason is that those values\n// can match lots of different string values (e.g., 1n == '+00001').\nfunction findLooseMatchingPrimitives(prim) {\n  switch (_typeof(prim)) {\n    case 'undefined':\n      return null;\n    case 'object':\n      // Only pass in null as object!\n      return undefined;\n    case 'symbol':\n      return false;\n    case 'string':\n      prim = +prim;\n    // Loose equal entries exist only if the string is possible to convert to\n    // a regular number and not NaN.\n    // Fall through\n    case 'number':\n      if (numberIsNaN(prim)) {\n        return false;\n      }\n  }\n  return true;\n}\nfunction setMightHaveLoosePrim(a, b, prim) {\n  var altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null) return altValue;\n  return b.has(altValue) && !a.has(altValue);\n}\nfunction mapMightHaveLoosePrim(a, b, prim, item, memo) {\n  var altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null) {\n    return altValue;\n  }\n  var curB = b.get(altValue);\n  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {\n    return false;\n  }\n  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);\n}\nfunction setEquiv(a, b, strict, memo) {\n  // This is a lazily initiated Set of entries which have to be compared\n  // pairwise.\n  var set = null;\n  var aValues = arrayFromSet(a);\n  for (var i = 0; i < aValues.length; i++) {\n    var val = aValues[i];\n    // Note: Checking for the objects first improves the performance for object\n    // heavy sets but it is a minor slow down for primitives. As they are fast\n    // to check this improves the worst case scenario instead.\n    if (_typeof(val) === 'object' && val !== null) {\n      if (set === null) {\n        set = new Set();\n      }\n      // If the specified value doesn't exist in the second set its an not null\n      // object (or non strict only: a not matching primitive) we'll need to go\n      // hunting for something thats deep-(strict-)equal to it. To make this\n      // O(n log n) complexity we have to copy these values in a new set first.\n      set.add(val);\n    } else if (!b.has(val)) {\n      if (strict) return false;\n\n      // Fast path to detect missing string, symbol, undefined and null values.\n      if (!setMightHaveLoosePrim(a, b, val)) {\n        return false;\n      }\n      if (set === null) {\n        set = new Set();\n      }\n      set.add(val);\n    }\n  }\n  if (set !== null) {\n    var bValues = arrayFromSet(b);\n    for (var _i = 0; _i < bValues.length; _i++) {\n      var _val = bValues[_i];\n      // We have to check if a primitive value is already\n      // matching and only if it's not, go hunting for it.\n      if (_typeof(_val) === 'object' && _val !== null) {\n        if (!setHasEqualElement(set, _val, strict, memo)) return false;\n      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {\n        return false;\n      }\n    }\n    return set.size === 0;\n  }\n  return true;\n}\nfunction mapHasEqualEntry(set, map, key1, item1, strict, memo) {\n  // To be able to handle cases like:\n  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])\n  // ... we need to consider *all* matching keys, not just the first we find.\n  var setValues = arrayFromSet(set);\n  for (var i = 0; i < setValues.length; i++) {\n    var key2 = setValues[i];\n    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {\n      set.delete(key2);\n      return true;\n    }\n  }\n  return false;\n}\nfunction mapEquiv(a, b, strict, memo) {\n  var set = null;\n  var aEntries = arrayFromMap(a);\n  for (var i = 0; i < aEntries.length; i++) {\n    var _aEntries$i = _slicedToArray(aEntries[i], 2),\n      key = _aEntries$i[0],\n      item1 = _aEntries$i[1];\n    if (_typeof(key) === 'object' && key !== null) {\n      if (set === null) {\n        set = new Set();\n      }\n      set.add(key);\n    } else {\n      // By directly retrieving the value we prevent another b.has(key) check in\n      // almost all possible cases.\n      var item2 = b.get(key);\n      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {\n        if (strict) return false;\n        // Fast path to detect missing string, symbol, undefined and null\n        // keys.\n        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;\n        if (set === null) {\n          set = new Set();\n        }\n        set.add(key);\n      }\n    }\n  }\n  if (set !== null) {\n    var bEntries = arrayFromMap(b);\n    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {\n      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),\n        _key = _bEntries$_i[0],\n        item = _bEntries$_i[1];\n      if (_typeof(_key) === 'object' && _key !== null) {\n        if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;\n      } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {\n        return false;\n      }\n    }\n    return set.size === 0;\n  }\n  return true;\n}\nfunction objEquiv(a, b, strict, keys, memos, iterationType) {\n  // Sets and maps don't have their entries accessible via normal object\n  // properties.\n  var i = 0;\n  if (iterationType === kIsSet) {\n    if (!setEquiv(a, b, strict, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsMap) {\n    if (!mapEquiv(a, b, strict, memos)) {\n      return false;\n    }\n  } else if (iterationType === kIsArray) {\n    for (; i < a.length; i++) {\n      if (hasOwnProperty(a, i)) {\n        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {\n          return false;\n        }\n      } else if (hasOwnProperty(b, i)) {\n        return false;\n      } else {\n        // Array is sparse.\n        var keysA = Object.keys(a);\n        for (; i < keysA.length; i++) {\n          var key = keysA[i];\n          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {\n            return false;\n          }\n        }\n        if (keysA.length !== Object.keys(b).length) {\n          return false;\n        }\n        return true;\n      }\n    }\n  }\n\n  // The pair must have equivalent values for every corresponding key.\n  // Possibly expensive deep test:\n  for (i = 0; i < keys.length; i++) {\n    var _key2 = keys[i];\n    if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isDeepEqual(val1, val2) {\n  return innerDeepEqual(val1, val2, kLoose);\n}\nfunction isDeepStrictEqual(val1, val2) {\n  return innerDeepEqual(val1, val2, kStrict);\n}\nmodule.exports = {\n  isDeepEqual: isDeepEqual,\n  isDeepStrictEqual: isDeepStrictEqual\n};","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBind = require('./');\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n","'use strict';\n\nvar bind = require('function-bind');\nvar GetIntrinsic = require('get-intrinsic');\nvar setFunctionLength = require('set-function-length');\n\nvar $TypeError = require('es-errors/type');\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $defineProperty = require('es-define-property');\nvar $max = GetIntrinsic('%Math.max%');\n\nmodule.exports = function callBind(originalFunction) {\n\tif (typeof originalFunction !== 'function') {\n\t\tthrow new $TypeError('a function is required');\n\t}\n\tvar func = $reflectApply(bind, $call, arguments);\n\treturn setFunctionLength(\n\t\tfunc,\n\t\t1 + $max(0, originalFunction.length - (arguments.length - 1)),\n\t\ttrue\n\t);\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n","'use strict';\n\nvar undefined;\n\nvar $Error = require('es-errors');\nvar $EvalError = require('es-errors/eval');\nvar $RangeError = require('es-errors/range');\nvar $ReferenceError = require('es-errors/ref');\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\nvar $URIError = require('es-errors/uri');\n\nvar $Function = Function;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\nvar hasProto = require('has-proto')();\n\nvar getProto = Object.getPrototypeOf || (\n\thasProto\n\t\t? function (x) { return x.__proto__; } // eslint-disable-line no-proto\n\t\t: null\n);\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t__proto__: null,\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': $Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': $EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': $RangeError,\n\t'%ReferenceError%': $ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': $URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t__proto__: null,\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('hasown');\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","/*global window, global*/\nvar util = require(\"util\")\nvar assert = require(\"assert\")\nfunction now() { return new Date().getTime() }\n\nvar slice = Array.prototype.slice\nvar console\nvar times = {}\n\nif (typeof global !== \"undefined\" && global.console) {\n    console = global.console\n} else if (typeof window !== \"undefined\" && window.console) {\n    console = window.console\n} else {\n    console = {}\n}\n\nvar functions = [\n    [log, \"log\"],\n    [info, \"info\"],\n    [warn, \"warn\"],\n    [error, \"error\"],\n    [time, \"time\"],\n    [timeEnd, \"timeEnd\"],\n    [trace, \"trace\"],\n    [dir, \"dir\"],\n    [consoleAssert, \"assert\"]\n]\n\nfor (var i = 0; i < functions.length; i++) {\n    var tuple = functions[i]\n    var f = tuple[0]\n    var name = tuple[1]\n\n    if (!console[name]) {\n        console[name] = f\n    }\n}\n\nmodule.exports = console\n\nfunction log() {}\n\nfunction info() {\n    console.log.apply(console, arguments)\n}\n\nfunction warn() {\n    console.log.apply(console, arguments)\n}\n\nfunction error() {\n    console.warn.apply(console, arguments)\n}\n\nfunction time(label) {\n    times[label] = now()\n}\n\nfunction timeEnd(label) {\n    var time = times[label]\n    if (!time) {\n        throw new Error(\"No such label: \" + label)\n    }\n\n    delete times[label]\n    var duration = now() - time\n    console.log(label + \": \" + duration + \"ms\")\n}\n\nfunction trace() {\n    var err = new Error()\n    err.name = \"Trace\"\n    err.message = util.format.apply(null, arguments)\n    console.error(err.stack)\n}\n\nfunction dir(object) {\n    console.log(util.inspect(object) + \"\\n\")\n}\n\nfunction consoleAssert(expression) {\n    if (!expression) {\n        var arr = slice.call(arguments, 1)\n        assert.ok(false, util.format.apply(null, arr))\n    }\n}\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/*\n! tailwindcss v3.4.1 | MIT License | https://tailwindcss.com\n*//*\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\n*/\n\n*,\n::before,\n::after {\n  box-sizing: border-box; /* 1 */\n  border-width: 0; /* 2 */\n  border-style: solid; /* 2 */\n  border-color: #e5e7eb; /* 2 */\n}\n\n::before,\n::after {\n  --tw-content: '';\n}\n\n/*\n1. Use a consistent sensible line-height in all browsers.\n2. Prevent adjustments of font size after orientation changes in iOS.\n3. Use a more readable tab size.\n4. Use the user's configured \\`sans\\` font-family by default.\n5. Use the user's configured \\`sans\\` font-feature-settings by default.\n6. Use the user's configured \\`sans\\` font-variation-settings by default.\n7. Disable tap highlights on iOS\n*/\n\nhtml,\n:host {\n  line-height: 1.5; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n  -moz-tab-size: 4; /* 3 */\n  -o-tab-size: 4;\n     tab-size: 4; /* 3 */\n  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"; /* 4 */\n  font-feature-settings: normal; /* 5 */\n  font-variation-settings: normal; /* 6 */\n  -webkit-tap-highlight-color: transparent; /* 7 */\n}\n\n/*\n1. Remove the margin in all browsers.\n2. Inherit line-height from \\`html\\` so users can set them as a class directly on the \\`html\\` element.\n*/\n\nbody {\n  margin: 0; /* 1 */\n  line-height: inherit; /* 2 */\n}\n\n/*\n1. Add the correct height in Firefox.\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\n3. Ensure horizontal rules are visible by default.\n*/\n\nhr {\n  height: 0; /* 1 */\n  color: inherit; /* 2 */\n  border-top-width: 1px; /* 3 */\n}\n\n/*\nAdd the correct text decoration in Chrome, Edge, and Safari.\n*/\n\nabbr:where([title]) {\n  text-decoration: underline;\n  -webkit-text-decoration: underline dotted;\n          text-decoration: underline dotted;\n}\n\n/*\nRemove the default font size and weight for headings.\n*/\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-size: inherit;\n  font-weight: inherit;\n}\n\n/*\nReset links to optimize for opt-in styling instead of opt-out.\n*/\n\na {\n  color: inherit;\n  text-decoration: inherit;\n}\n\n/*\nAdd the correct font weight in Edge and Safari.\n*/\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/*\n1. Use the user's configured \\`mono\\` font-family by default.\n2. Use the user's configured \\`mono\\` font-feature-settings by default.\n3. Use the user's configured \\`mono\\` font-variation-settings by default.\n4. Correct the odd \\`em\\` font sizing in all browsers.\n*/\n\ncode,\nkbd,\nsamp,\npre {\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace; /* 1 */\n  font-feature-settings: normal; /* 2 */\n  font-variation-settings: normal; /* 3 */\n  font-size: 1em; /* 4 */\n}\n\n/*\nAdd the correct font size in all browsers.\n*/\n\nsmall {\n  font-size: 80%;\n}\n\n/*\nPrevent \\`sub\\` and \\`sup\\` elements from affecting the line height in all browsers.\n*/\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/*\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\n3. Remove gaps between table borders by default.\n*/\n\ntable {\n  text-indent: 0; /* 1 */\n  border-color: inherit; /* 2 */\n  border-collapse: collapse; /* 3 */\n}\n\n/*\n1. Change the font styles in all browsers.\n2. Remove the margin in Firefox and Safari.\n3. Remove default padding in all browsers.\n*/\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-feature-settings: inherit; /* 1 */\n  font-variation-settings: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  font-weight: inherit; /* 1 */\n  line-height: inherit; /* 1 */\n  color: inherit; /* 1 */\n  margin: 0; /* 2 */\n  padding: 0; /* 3 */\n}\n\n/*\nRemove the inheritance of text transform in Edge and Firefox.\n*/\n\nbutton,\nselect {\n  text-transform: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Remove default button styles.\n*/\n\nbutton,\n[type='button'],\n[type='reset'],\n[type='submit'] {\n  -webkit-appearance: button; /* 1 */\n  background-color: transparent; /* 2 */\n  background-image: none; /* 2 */\n}\n\n/*\nUse the modern Firefox focus style for all focusable elements.\n*/\n\n:-moz-focusring {\n  outline: auto;\n}\n\n/*\nRemove the additional \\`:invalid\\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\n*/\n\n:-moz-ui-invalid {\n  box-shadow: none;\n}\n\n/*\nAdd the correct vertical alignment in Chrome and Firefox.\n*/\n\nprogress {\n  vertical-align: baseline;\n}\n\n/*\nCorrect the cursor style of increment and decrement buttons in Safari.\n*/\n\n::-webkit-inner-spin-button,\n::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/*\n1. Correct the odd appearance in Chrome and Safari.\n2. Correct the outline style in Safari.\n*/\n\n[type='search'] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/*\nRemove the inner padding in Chrome and Safari on macOS.\n*/\n\n::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Change font properties to \\`inherit\\` in Safari.\n*/\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/*\nAdd the correct display in Chrome and Safari.\n*/\n\nsummary {\n  display: list-item;\n}\n\n/*\nRemoves the default spacing and border for appropriate elements.\n*/\n\nblockquote,\ndl,\ndd,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\nhr,\nfigure,\np,\npre {\n  margin: 0;\n}\n\nfieldset {\n  margin: 0;\n  padding: 0;\n}\n\nlegend {\n  padding: 0;\n}\n\nol,\nul,\nmenu {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n\n/*\nReset default styling for dialogs.\n*/\ndialog {\n  padding: 0;\n}\n\n/*\nPrevent resizing textareas horizontally by default.\n*/\n\ntextarea {\n  resize: vertical;\n}\n\n/*\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\n2. Set the default placeholder color to the user's configured gray 400 color.\n*/\n\ninput::-moz-placeholder, textarea::-moz-placeholder {\n  opacity: 1; /* 1 */\n  color: #9ca3af; /* 2 */\n}\n\ninput::placeholder,\ntextarea::placeholder {\n  opacity: 1; /* 1 */\n  color: #9ca3af; /* 2 */\n}\n\n/*\nSet the default cursor for buttons.\n*/\n\nbutton,\n[role=\"button\"] {\n  cursor: pointer;\n}\n\n/*\nMake sure disabled buttons don't get the pointer cursor.\n*/\n:disabled {\n  cursor: default;\n}\n\n/*\n1. Make replaced elements \\`display: block\\` by default. (https://github.com/mozdevs/cssremedy/issues/14)\n2. Add \\`vertical-align: middle\\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\n   This can trigger a poorly considered lint error in some tools but is included by design.\n*/\n\nimg,\nsvg,\nvideo,\ncanvas,\naudio,\niframe,\nembed,\nobject {\n  display: block; /* 1 */\n  vertical-align: middle; /* 2 */\n}\n\n/*\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\n*/\n\nimg,\nvideo {\n  max-width: 100%;\n  height: auto;\n}\n\n/* Make elements with the HTML hidden attribute stay hidden by default */\n[hidden] {\n  display: none;\n}\n\n*, ::before, ::after {\n  --tw-border-spacing-x: 0;\n  --tw-border-spacing-y: 0;\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  --tw-pan-x:  ;\n  --tw-pan-y:  ;\n  --tw-pinch-zoom:  ;\n  --tw-scroll-snap-strictness: proximity;\n  --tw-gradient-from-position:  ;\n  --tw-gradient-via-position:  ;\n  --tw-gradient-to-position:  ;\n  --tw-ordinal:  ;\n  --tw-slashed-zero:  ;\n  --tw-numeric-figure:  ;\n  --tw-numeric-spacing:  ;\n  --tw-numeric-fraction:  ;\n  --tw-ring-inset:  ;\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgba(59, 130, 246, 0.5);\n  --tw-ring-offset-shadow: 0 0 rgba(0,0,0,0);\n  --tw-ring-shadow: 0 0 rgba(0,0,0,0);\n  --tw-shadow: 0 0 rgba(0,0,0,0);\n  --tw-shadow-colored: 0 0 rgba(0,0,0,0);\n  --tw-blur:  ;\n  --tw-brightness:  ;\n  --tw-contrast:  ;\n  --tw-grayscale:  ;\n  --tw-hue-rotate:  ;\n  --tw-invert:  ;\n  --tw-saturate:  ;\n  --tw-sepia:  ;\n  --tw-drop-shadow:  ;\n  --tw-backdrop-blur:  ;\n  --tw-backdrop-brightness:  ;\n  --tw-backdrop-contrast:  ;\n  --tw-backdrop-grayscale:  ;\n  --tw-backdrop-hue-rotate:  ;\n  --tw-backdrop-invert:  ;\n  --tw-backdrop-opacity:  ;\n  --tw-backdrop-saturate:  ;\n  --tw-backdrop-sepia:  ;\n}\n\n::backdrop {\n  --tw-border-spacing-x: 0;\n  --tw-border-spacing-y: 0;\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  --tw-pan-x:  ;\n  --tw-pan-y:  ;\n  --tw-pinch-zoom:  ;\n  --tw-scroll-snap-strictness: proximity;\n  --tw-gradient-from-position:  ;\n  --tw-gradient-via-position:  ;\n  --tw-gradient-to-position:  ;\n  --tw-ordinal:  ;\n  --tw-slashed-zero:  ;\n  --tw-numeric-figure:  ;\n  --tw-numeric-spacing:  ;\n  --tw-numeric-fraction:  ;\n  --tw-ring-inset:  ;\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgba(59, 130, 246, 0.5);\n  --tw-ring-offset-shadow: 0 0 rgba(0,0,0,0);\n  --tw-ring-shadow: 0 0 rgba(0,0,0,0);\n  --tw-shadow: 0 0 rgba(0,0,0,0);\n  --tw-shadow-colored: 0 0 rgba(0,0,0,0);\n  --tw-blur:  ;\n  --tw-brightness:  ;\n  --tw-contrast:  ;\n  --tw-grayscale:  ;\n  --tw-hue-rotate:  ;\n  --tw-invert:  ;\n  --tw-saturate:  ;\n  --tw-sepia:  ;\n  --tw-drop-shadow:  ;\n  --tw-backdrop-blur:  ;\n  --tw-backdrop-brightness:  ;\n  --tw-backdrop-contrast:  ;\n  --tw-backdrop-grayscale:  ;\n  --tw-backdrop-hue-rotate:  ;\n  --tw-backdrop-invert:  ;\n  --tw-backdrop-opacity:  ;\n  --tw-backdrop-saturate:  ;\n  --tw-backdrop-sepia:  ;\n}\r\n.sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\r\n.visible {\n  visibility: visible;\n}\r\n.collapse {\n  visibility: collapse;\n}\r\n.static {\n  position: static;\n}\r\n.fixed {\n  position: fixed;\n}\r\n.absolute {\n  position: absolute;\n}\r\n.relative {\n  position: relative;\n}\r\n.inset-0 {\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n}\r\n.left-0 {\n  left: 0px;\n}\r\n.top-0 {\n  top: 0px;\n}\r\n.z-10 {\n  z-index: 10;\n}\r\n.z-50 {\n  z-index: 50;\n}\r\n.mx-auto {\n  margin-left: auto;\n  margin-right: auto;\n}\r\n.mb-3 {\n  margin-bottom: 0.75rem;\n}\r\n.mb-4 {\n  margin-bottom: 1rem;\n}\r\n.mb-5 {\n  margin-bottom: 1.25rem;\n}\r\n.mr-2 {\n  margin-right: 0.5rem;\n}\r\n.mt-12 {\n  margin-top: 3rem;\n}\r\n.mt-2 {\n  margin-top: 0.5rem;\n}\r\n.mt-20 {\n  margin-top: 5rem;\n}\r\n.mt-3 {\n  margin-top: 0.75rem;\n}\r\n.mt-8 {\n  margin-top: 2rem;\n}\r\n.mt-auto {\n  margin-top: auto;\n}\r\n.\\\\!block {\n  display: block !important;\n}\r\n.block {\n  display: block;\n}\r\n.inline-block {\n  display: inline-block;\n}\r\n.flex {\n  display: flex;\n}\r\n.table {\n  display: table;\n}\r\n.grid {\n  display: grid;\n}\r\n.contents {\n  display: contents;\n}\r\n.hidden {\n  display: none;\n}\r\n.h-14 {\n  height: 3.5rem;\n}\r\n.h-20 {\n  height: 5rem;\n}\r\n.h-32 {\n  height: 8rem;\n}\r\n.h-6 {\n  height: 1.5rem;\n}\r\n.h-full {\n  height: 100%;\n}\r\n.h-screen {\n  height: 100vh;\n}\r\n.min-h-screen {\n  min-height: 100vh;\n}\r\n.w-24 {\n  width: 6rem;\n}\r\n.w-6 {\n  width: 1.5rem;\n}\r\n.w-\\\\[16rem\\\\] {\n  width: 16rem;\n}\r\n.w-\\\\[25\\\\%\\\\] {\n  width: 25%;\n}\r\n.w-\\\\[4\\\\.8125rem\\\\] {\n  width: 4.8125rem;\n}\r\n.w-full {\n  width: 100%;\n}\r\n.max-w-7xl {\n  max-width: 80rem;\n}\r\n.border-collapse {\n  border-collapse: collapse;\n}\r\n.transform {\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\r\n.resize-none {\n  resize: none;\n}\r\n.resize {\n  resize: both;\n}\r\n.grid-cols-3 {\n  grid-template-columns: repeat(3, minmax(0, 1fr));\n}\r\n.flex-col {\n  flex-direction: column;\n}\r\n.items-center {\n  align-items: center;\n}\r\n.justify-center {\n  justify-content: center;\n}\r\n.justify-between {\n  justify-content: space-between;\n}\r\n.gap-4 {\n  gap: 1rem;\n}\r\n.space-x-6 > :not([hidden]) ~ :not([hidden]) {\n  --tw-space-x-reverse: 0;\n  margin-right: calc(1.5rem * 0);\n  margin-right: calc(1.5rem * var(--tw-space-x-reverse));\n  margin-left: calc(1.5rem * (1 - 0));\n  margin-left: calc(1.5rem * (1 - var(--tw-space-x-reverse)));\n  margin-left: calc(1.5rem * calc(1 - 0));\n  margin-left: calc(1.5rem * calc(1 - var(--tw-space-x-reverse)));\n}\r\n.overflow-hidden {\n  overflow: hidden;\n}\r\n.overflow-y-hidden {\n  overflow-y: hidden;\n}\r\n.rounded {\n  border-radius: 0.25rem;\n}\r\n.rounded-lg {\n  border-radius: 0.5rem;\n}\r\n.rounded-md {\n  border-radius: 0.375rem;\n}\r\n.rounded-sm {\n  border-radius: 0.125rem;\n}\r\n.rounded-b-lg {\n  border-bottom-right-radius: 0.5rem;\n  border-bottom-left-radius: 0.5rem;\n}\r\n.border {\n  border-width: 1px;\n}\r\n.border-b {\n  border-bottom-width: 1px;\n}\r\n.border-t {\n  border-top-width: 1px;\n}\r\n.border-solid {\n  border-style: solid;\n}\r\n.border-\\\\[\\\\#282828\\\\] {\n  --tw-border-opacity: 1;\n  border-color: rgba(40, 40, 40, 1);\n  border-color: rgba(40, 40, 40, var(--tw-border-opacity));\n}\r\n.border-\\\\[\\\\#d1d1d1\\\\] {\n  --tw-border-opacity: 1;\n  border-color: rgba(209, 209, 209, 1);\n  border-color: rgba(209, 209, 209, var(--tw-border-opacity));\n}\r\n.border-black {\n  --tw-border-opacity: 1;\n  border-color: rgba(0, 0, 0, 1);\n  border-color: rgba(0, 0, 0, var(--tw-border-opacity));\n}\r\n.border-blue-500 {\n  --tw-border-opacity: 1;\n  border-color: rgba(59, 130, 246, 1);\n  border-color: rgba(59, 130, 246, var(--tw-border-opacity));\n}\r\n.border-b-\\\\[\\\\#d9d9d9\\\\] {\n  --tw-border-opacity: 1;\n  border-bottom-color: rgba(217, 217, 217, 1);\n  border-bottom-color: rgba(217, 217, 217, var(--tw-border-opacity));\n}\r\n.bg-\\\\[\\\\#e4e4e4\\\\] {\n  --tw-bg-opacity: 1;\n  background-color: rgba(228, 228, 228, 1);\n  background-color: rgba(228, 228, 228, var(--tw-bg-opacity));\n}\r\n.bg-blue-400 {\n  --tw-bg-opacity: 1;\n  background-color: rgba(96, 165, 250, 1);\n  background-color: rgba(96, 165, 250, var(--tw-bg-opacity));\n}\r\n.bg-blue-500 {\n  --tw-bg-opacity: 1;\n  background-color: rgba(59, 130, 246, 1);\n  background-color: rgba(59, 130, 246, var(--tw-bg-opacity));\n}\r\n.bg-dark-grey {\n  --tw-bg-opacity: 1;\n  background-color: rgba(77, 77, 77, 1);\n  background-color: rgba(77, 77, 77, var(--tw-bg-opacity));\n}\r\n.bg-gray-100 {\n  --tw-bg-opacity: 1;\n  background-color: rgba(243, 244, 246, 1);\n  background-color: rgba(243, 244, 246, var(--tw-bg-opacity));\n}\r\n.bg-gray-200 {\n  --tw-bg-opacity: 1;\n  background-color: rgba(229, 231, 235, 1);\n  background-color: rgba(229, 231, 235, var(--tw-bg-opacity));\n}\r\n.bg-gray-900 {\n  --tw-bg-opacity: 1;\n  background-color: rgba(17, 24, 39, 1);\n  background-color: rgba(17, 24, 39, var(--tw-bg-opacity));\n}\r\n.bg-green-500 {\n  --tw-bg-opacity: 1;\n  background-color: rgba(34, 197, 94, 1);\n  background-color: rgba(34, 197, 94, var(--tw-bg-opacity));\n}\r\n.bg-modal-background {\n  background-color: rgba(21.57,25.49,31.76,0.5);\n}\r\n.bg-red-400 {\n  --tw-bg-opacity: 1;\n  background-color: rgba(248, 113, 113, 1);\n  background-color: rgba(248, 113, 113, var(--tw-bg-opacity));\n}\r\n.bg-red-500 {\n  --tw-bg-opacity: 1;\n  background-color: rgba(239, 68, 68, 1);\n  background-color: rgba(239, 68, 68, var(--tw-bg-opacity));\n}\r\n.bg-white {\n  --tw-bg-opacity: 1;\n  background-color: rgba(255, 255, 255, 1);\n  background-color: rgba(255, 255, 255, var(--tw-bg-opacity));\n}\r\n.bg-yellow-400 {\n  --tw-bg-opacity: 1;\n  background-color: rgba(250, 204, 21, 1);\n  background-color: rgba(250, 204, 21, var(--tw-bg-opacity));\n}\r\n.bg-yellow-500 {\n  --tw-bg-opacity: 1;\n  background-color: rgba(234, 179, 8, 1);\n  background-color: rgba(234, 179, 8, var(--tw-bg-opacity));\n}\r\n.p-2 {\n  padding: 0.5rem;\n}\r\n.p-5 {\n  padding: 1.25rem;\n}\r\n.p-6 {\n  padding: 1.5rem;\n}\r\n.px-10 {\n  padding-left: 2.5rem;\n  padding-right: 2.5rem;\n}\r\n.px-2 {\n  padding-left: 0.5rem;\n  padding-right: 0.5rem;\n}\r\n.px-3 {\n  padding-left: 0.75rem;\n  padding-right: 0.75rem;\n}\r\n.px-4 {\n  padding-left: 1rem;\n  padding-right: 1rem;\n}\r\n.px-5 {\n  padding-left: 1.25rem;\n  padding-right: 1.25rem;\n}\r\n.py-2 {\n  padding-top: 0.5rem;\n  padding-bottom: 0.5rem;\n}\r\n.py-3 {\n  padding-top: 0.75rem;\n  padding-bottom: 0.75rem;\n}\r\n.py-6 {\n  padding-top: 1.5rem;\n  padding-bottom: 1.5rem;\n}\r\n.py-\\\\[0\\\\.1875rem\\\\] {\n  padding-top: 0.1875rem;\n  padding-bottom: 0.1875rem;\n}\r\n.pb-20 {\n  padding-bottom: 5rem;\n}\r\n.pb-4 {\n  padding-bottom: 1rem;\n}\r\n.pt-4 {\n  padding-top: 1rem;\n}\r\n.pt-5 {\n  padding-top: 1.25rem;\n}\r\n.text-left {\n  text-align: left;\n}\r\n.text-center {\n  text-align: center;\n}\r\n.text-right {\n  text-align: right;\n}\r\n.text-2xl {\n  font-size: 1.5rem;\n  line-height: 2rem;\n}\r\n.text-3xl {\n  font-size: 1.875rem;\n  line-height: 2.25rem;\n}\r\n.text-\\\\[1\\\\.25rem\\\\] {\n  font-size: 1.25rem;\n}\r\n.text-\\\\[1\\\\.75rem\\\\] {\n  font-size: 1.75rem;\n}\r\n.text-base {\n  font-size: 1rem;\n  line-height: 1.5rem;\n}\r\n.text-lg {\n  font-size: 1.125rem;\n  line-height: 1.75rem;\n}\r\n.text-sm {\n  font-size: 0.875rem;\n  line-height: 1.25rem;\n}\r\n.text-xl {\n  font-size: 1.25rem;\n  line-height: 1.75rem;\n}\r\n.font-bold {\n  font-weight: 700;\n}\r\n.font-medium {\n  font-weight: 500;\n}\r\n.font-semibold {\n  font-weight: 600;\n}\r\n.italic {\n  font-style: italic;\n}\r\n.text-\\\\[\\\\#282828\\\\] {\n  --tw-text-opacity: 1;\n  color: rgba(40, 40, 40, 1);\n  color: rgba(40, 40, 40, var(--tw-text-opacity));\n}\r\n.text-black {\n  --tw-text-opacity: 1;\n  color: rgba(0, 0, 0, 1);\n  color: rgba(0, 0, 0, var(--tw-text-opacity));\n}\r\n.text-white {\n  --tw-text-opacity: 1;\n  color: rgba(255, 255, 255, 1);\n  color: rgba(255, 255, 255, var(--tw-text-opacity));\n}\r\n.underline {\n  text-decoration-line: underline;\n}\r\n.opacity-75 {\n  opacity: 0.75;\n}\r\n.shadow-xl {\n  --tw-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);\n  --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);\n  box-shadow: 0 0 rgba(0,0,0,0), 0 0 rgba(0,0,0,0), 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 rgba(0,0,0,0)), var(--tw-ring-shadow, 0 0 rgba(0,0,0,0)), var(--tw-shadow);\n}\r\n.outline-none {\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n}\r\n.outline {\n  outline-style: solid;\n}\r\n.invert {\n  --tw-invert: invert(100%);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) invert(100%) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\r\n.filter {\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\r\n.transition-all {\n  transition-property: all;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms;\n}\r\n.transition-opacity {\n  transition-property: opacity;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms;\n}\r\n.hover\\\\:border-0:hover {\n  border-width: 0px;\n}\r\n.hover\\\\:bg-blue-700:hover {\n  --tw-bg-opacity: 1;\n  background-color: rgba(29, 78, 216, 1);\n  background-color: rgba(29, 78, 216, var(--tw-bg-opacity));\n}\r\n.hover\\\\:bg-gray-700:hover {\n  --tw-bg-opacity: 1;\n  background-color: rgba(55, 65, 81, 1);\n  background-color: rgba(55, 65, 81, var(--tw-bg-opacity));\n}\r\n.hover\\\\:bg-green-400:hover {\n  --tw-bg-opacity: 1;\n  background-color: rgba(74, 222, 128, 1);\n  background-color: rgba(74, 222, 128, var(--tw-bg-opacity));\n}\r\n.hover\\\\:text-white:hover {\n  --tw-text-opacity: 1;\n  color: rgba(255, 255, 255, 1);\n  color: rgba(255, 255, 255, var(--tw-text-opacity));\n}`, \"\",{\"version\":3,\"sources\":[\"webpack://./src/style.css\"],\"names\":[],\"mappings\":\"AAAA;;CAAc,CAAd;;;CAAc;;AAAd;;;EAAA,sBAAc,EAAd,MAAc;EAAd,eAAc,EAAd,MAAc;EAAd,mBAAc,EAAd,MAAc;EAAd,qBAAc,EAAd,MAAc;AAAA;;AAAd;;EAAA,gBAAc;AAAA;;AAAd;;;;;;;;CAAc;;AAAd;;EAAA,gBAAc,EAAd,MAAc;EAAd,8BAAc,EAAd,MAAc;EAAd,gBAAc,EAAd,MAAc;EAAd,cAAc;KAAd,WAAc,EAAd,MAAc;EAAd,8LAAc,EAAd,MAAc;EAAd,6BAAc,EAAd,MAAc;EAAd,+BAAc,EAAd,MAAc;EAAd,wCAAc,EAAd,MAAc;AAAA;;AAAd;;;CAAc;;AAAd;EAAA,SAAc,EAAd,MAAc;EAAd,oBAAc,EAAd,MAAc;AAAA;;AAAd;;;;CAAc;;AAAd;EAAA,SAAc,EAAd,MAAc;EAAd,cAAc,EAAd,MAAc;EAAd,qBAAc,EAAd,MAAc;AAAA;;AAAd;;CAAc;;AAAd;EAAA,0BAAc;EAAd,yCAAc;UAAd,iCAAc;AAAA;;AAAd;;CAAc;;AAAd;;;;;;EAAA,kBAAc;EAAd,oBAAc;AAAA;;AAAd;;CAAc;;AAAd;EAAA,cAAc;EAAd,wBAAc;AAAA;;AAAd;;CAAc;;AAAd;;EAAA,mBAAc;AAAA;;AAAd;;;;;CAAc;;AAAd;;;;EAAA,+GAAc,EAAd,MAAc;EAAd,6BAAc,EAAd,MAAc;EAAd,+BAAc,EAAd,MAAc;EAAd,cAAc,EAAd,MAAc;AAAA;;AAAd;;CAAc;;AAAd;EAAA,cAAc;AAAA;;AAAd;;CAAc;;AAAd;;EAAA,cAAc;EAAd,cAAc;EAAd,kBAAc;EAAd,wBAAc;AAAA;;AAAd;EAAA,eAAc;AAAA;;AAAd;EAAA,WAAc;AAAA;;AAAd;;;;CAAc;;AAAd;EAAA,cAAc,EAAd,MAAc;EAAd,qBAAc,EAAd,MAAc;EAAd,yBAAc,EAAd,MAAc;AAAA;;AAAd;;;;CAAc;;AAAd;;;;;EAAA,oBAAc,EAAd,MAAc;EAAd,8BAAc,EAAd,MAAc;EAAd,gCAAc,EAAd,MAAc;EAAd,eAAc,EAAd,MAAc;EAAd,oBAAc,EAAd,MAAc;EAAd,oBAAc,EAAd,MAAc;EAAd,cAAc,EAAd,MAAc;EAAd,SAAc,EAAd,MAAc;EAAd,UAAc,EAAd,MAAc;AAAA;;AAAd;;CAAc;;AAAd;;EAAA,oBAAc;AAAA;;AAAd;;;CAAc;;AAAd;;;;EAAA,0BAAc,EAAd,MAAc;EAAd,6BAAc,EAAd,MAAc;EAAd,sBAAc,EAAd,MAAc;AAAA;;AAAd;;CAAc;;AAAd;EAAA,aAAc;AAAA;;AAAd;;CAAc;;AAAd;EAAA,gBAAc;AAAA;;AAAd;;CAAc;;AAAd;EAAA,wBAAc;AAAA;;AAAd;;CAAc;;AAAd;;EAAA,YAAc;AAAA;;AAAd;;;CAAc;;AAAd;EAAA,6BAAc,EAAd,MAAc;EAAd,oBAAc,EAAd,MAAc;AAAA;;AAAd;;CAAc;;AAAd;EAAA,wBAAc;AAAA;;AAAd;;;CAAc;;AAAd;EAAA,0BAAc,EAAd,MAAc;EAAd,aAAc,EAAd,MAAc;AAAA;;AAAd;;CAAc;;AAAd;EAAA,kBAAc;AAAA;;AAAd;;CAAc;;AAAd;;;;;;;;;;;;;EAAA,SAAc;AAAA;;AAAd;EAAA,SAAc;EAAd,UAAc;AAAA;;AAAd;EAAA,UAAc;AAAA;;AAAd;;;EAAA,gBAAc;EAAd,SAAc;EAAd,UAAc;AAAA;;AAAd;;CAAc;AAAd;EAAA,UAAc;AAAA;;AAAd;;CAAc;;AAAd;EAAA,gBAAc;AAAA;;AAAd;;;CAAc;;AAAd;EAAA,UAAc,EAAd,MAAc;EAAd,cAAc,EAAd,MAAc;AAAA;;AAAd;;EAAA,UAAc,EAAd,MAAc;EAAd,cAAc,EAAd,MAAc;AAAA;;AAAd;;CAAc;;AAAd;;EAAA,eAAc;AAAA;;AAAd;;CAAc;AAAd;EAAA,eAAc;AAAA;;AAAd;;;;CAAc;;AAAd;;;;;;;;EAAA,cAAc,EAAd,MAAc;EAAd,sBAAc,EAAd,MAAc;AAAA;;AAAd;;CAAc;;AAAd;;EAAA,eAAc;EAAd,YAAc;AAAA;;AAAd,wEAAc;AAAd;EAAA,aAAc;AAAA;;AAAd;EAAA,wBAAc;EAAd,wBAAc;EAAd,mBAAc;EAAd,mBAAc;EAAd,cAAc;EAAd,cAAc;EAAd,cAAc;EAAd,eAAc;EAAd,eAAc;EAAd,aAAc;EAAd,aAAc;EAAd,kBAAc;EAAd,sCAAc;EAAd,8BAAc;EAAd,6BAAc;EAAd,4BAAc;EAAd,eAAc;EAAd,oBAAc;EAAd,sBAAc;EAAd,uBAAc;EAAd,wBAAc;EAAd,kBAAc;EAAd,2BAAc;EAAd,4BAAc;EAAd,wCAAc;EAAd,0CAAc;EAAd,mCAAc;EAAd,8BAAc;EAAd,sCAAc;EAAd,YAAc;EAAd,kBAAc;EAAd,gBAAc;EAAd,iBAAc;EAAd,kBAAc;EAAd,cAAc;EAAd,gBAAc;EAAd,aAAc;EAAd,mBAAc;EAAd,qBAAc;EAAd,2BAAc;EAAd,yBAAc;EAAd,0BAAc;EAAd,2BAAc;EAAd,uBAAc;EAAd,wBAAc;EAAd,yBAAc;EAAd;AAAc;;AAAd;EAAA,wBAAc;EAAd,wBAAc;EAAd,mBAAc;EAAd,mBAAc;EAAd,cAAc;EAAd,cAAc;EAAd,cAAc;EAAd,eAAc;EAAd,eAAc;EAAd,aAAc;EAAd,aAAc;EAAd,kBAAc;EAAd,sCAAc;EAAd,8BAAc;EAAd,6BAAc;EAAd,4BAAc;EAAd,eAAc;EAAd,oBAAc;EAAd,sBAAc;EAAd,uBAAc;EAAd,wBAAc;EAAd,kBAAc;EAAd,2BAAc;EAAd,4BAAc;EAAd,wCAAc;EAAd,0CAAc;EAAd,mCAAc;EAAd,8BAAc;EAAd,sCAAc;EAAd,YAAc;EAAd,kBAAc;EAAd,gBAAc;EAAd,iBAAc;EAAd,kBAAc;EAAd,cAAc;EAAd,gBAAc;EAAd,aAAc;EAAd,mBAAc;EAAd,qBAAc;EAAd,2BAAc;EAAd,yBAAc;EAAd,0BAAc;EAAd,2BAAc;EAAd,uBAAc;EAAd,wBAAc;EAAd,yBAAc;EAAd;AAAc;AAEd;EAAA,kBAAmB;EAAnB,UAAmB;EAAnB,WAAmB;EAAnB,UAAmB;EAAnB,YAAmB;EAAnB,gBAAmB;EAAnB,sBAAmB;EAAnB,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,QAAmB;EAAnB,UAAmB;EAAnB,WAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,iBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,uBAAmB;EAAnB,8BAAmB;EAAnB,sDAAmB;EAAnB,mCAAmB;EAAnB,2DAAmB;EAAnB,uCAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,kCAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,sBAAmB;EAAnB,iCAAmB;EAAnB;AAAmB;AAAnB;EAAA,sBAAmB;EAAnB,oCAAmB;EAAnB;AAAmB;AAAnB;EAAA,sBAAmB;EAAnB,8BAAmB;EAAnB;AAAmB;AAAnB;EAAA,sBAAmB;EAAnB,mCAAmB;EAAnB;AAAmB;AAAnB;EAAA,sBAAmB;EAAnB,2CAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,wCAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,uCAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,uCAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,qCAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,wCAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,wCAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,qCAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,sCAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,wCAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,sCAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,wCAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,uCAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,sCAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,oBAAmB;EAAnB;AAAmB;AAAnB;EAAA,oBAAmB;EAAnB;AAAmB;AAAnB;EAAA,qBAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB;AAAmB;AAAnB;EAAA,qBAAmB;EAAnB;AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,oBAAmB;EAAnB;AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,sBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,iBAAmB;EAAnB;AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,eAAmB;EAAnB;AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,mBAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,oBAAmB;EAAnB,0BAAmB;EAAnB;AAAmB;AAAnB;EAAA,oBAAmB;EAAnB,uBAAmB;EAAnB;AAAmB;AAAnB;EAAA,oBAAmB;EAAnB,6BAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,oFAAmB;EAAnB,oGAAmB;EAAnB,yHAAmB;EAAnB;AAAmB;AAAnB;EAAA,8BAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,yBAAmB;EAAnB,6KAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,wBAAmB;EAAnB,wDAAmB;EAAnB;AAAmB;AAAnB;EAAA,4BAAmB;EAAnB,wDAAmB;EAAnB;AAAmB;AAFnB;EAAA;AAEoB;AAFpB;EAAA,kBAEoB;EAFpB,sCAEoB;EAFpB;AAEoB;AAFpB;EAAA,kBAEoB;EAFpB,qCAEoB;EAFpB;AAEoB;AAFpB;EAAA,kBAEoB;EAFpB,uCAEoB;EAFpB;AAEoB;AAFpB;EAAA,oBAEoB;EAFpB,6BAEoB;EAFpB;AAEoB\",\"sourcesContent\":[\"@tailwind base;\\r\\n@tailwind components;\\r\\n@tailwind utilities;\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    return [content].concat([sourceMapping]).join(\"\\n\");\n  }\n  return [content].join(\"\\n\");\n};","'use strict';\n\nvar $defineProperty = require('es-define-property');\n\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\n\nvar gopd = require('gopd');\n\n/** @type {import('.')} */\nmodule.exports = function defineDataProperty(\n\tobj,\n\tproperty,\n\tvalue\n) {\n\tif (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {\n\t\tthrow new $TypeError('`obj` must be an object or a function`');\n\t}\n\tif (typeof property !== 'string' && typeof property !== 'symbol') {\n\t\tthrow new $TypeError('`property` must be a string or a symbol`');\n\t}\n\tif (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {\n\t\tthrow new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {\n\t\tthrow new $TypeError('`nonWritable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {\n\t\tthrow new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 6 && typeof arguments[6] !== 'boolean') {\n\t\tthrow new $TypeError('`loose`, if provided, must be a boolean');\n\t}\n\n\tvar nonEnumerable = arguments.length > 3 ? arguments[3] : null;\n\tvar nonWritable = arguments.length > 4 ? arguments[4] : null;\n\tvar nonConfigurable = arguments.length > 5 ? arguments[5] : null;\n\tvar loose = arguments.length > 6 ? arguments[6] : false;\n\n\t/* @type {false | TypedPropertyDescriptor<unknown>} */\n\tvar desc = !!gopd && gopd(obj, property);\n\n\tif ($defineProperty) {\n\t\t$defineProperty(obj, property, {\n\t\t\tconfigurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,\n\t\t\tenumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,\n\t\t\tvalue: value,\n\t\t\twritable: nonWritable === null && desc ? desc.writable : !nonWritable\n\t\t});\n\t} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {\n\t\t// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable\n\t\tobj[property] = value; // eslint-disable-line no-param-reassign\n\t} else {\n\t\tthrow new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');\n\t}\n};\n","'use strict';\n\nvar keys = require('object-keys');\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar defineDataProperty = require('define-data-property');\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar supportsDescriptors = require('has-property-descriptors')();\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object) {\n\t\tif (predicate === true) {\n\t\t\tif (object[name] === value) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (!isFunction(predicate) || !predicate()) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (supportsDescriptors) {\n\t\tdefineDataProperty(object, name, value, true);\n\t} else {\n\t\tdefineDataProperty(object, name, value);\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\n/** @type {import('.')} */\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = false;\n\t}\n}\n\nmodule.exports = $defineProperty;\n","'use strict';\n\nvar undefined;\n\nvar $Error = require('es-errors');\nvar $EvalError = require('es-errors/eval');\nvar $RangeError = require('es-errors/range');\nvar $ReferenceError = require('es-errors/ref');\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\nvar $URIError = require('es-errors/uri');\n\nvar $Function = Function;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\nvar hasProto = require('has-proto')();\n\nvar getProto = Object.getPrototypeOf || (\n\thasProto\n\t\t? function (x) { return x.__proto__; } // eslint-disable-line no-proto\n\t\t: null\n);\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t__proto__: null,\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': $Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': $EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': $RangeError,\n\t'%ReferenceError%': $ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': $URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t__proto__: null,\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('hasown');\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\n/** @type {import('./eval')} */\nmodule.exports = EvalError;\n","'use strict';\n\n/** @type {import('.')} */\nmodule.exports = Error;\n","'use strict';\n\n/** @type {import('./range')} */\nmodule.exports = RangeError;\n","'use strict';\n\n/** @type {import('./ref')} */\nmodule.exports = ReferenceError;\n","'use strict';\n\n/** @type {import('./syntax')} */\nmodule.exports = SyntaxError;\n","'use strict';\n\n/** @type {import('./type')} */\nmodule.exports = TypeError;\n","'use strict';\n\n/** @type {import('./uri')} */\nmodule.exports = URIError;\n","'use strict';\n\nvar isCallable = require('is-callable');\n\nvar toStr = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar forEachArray = function forEachArray(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            if (receiver == null) {\n                iterator(array[i], i, array);\n            } else {\n                iterator.call(receiver, array[i], i, array);\n            }\n        }\n    }\n};\n\nvar forEachString = function forEachString(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        if (receiver == null) {\n            iterator(string.charAt(i), i, string);\n        } else {\n            iterator.call(receiver, string.charAt(i), i, string);\n        }\n    }\n};\n\nvar forEachObject = function forEachObject(object, iterator, receiver) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            if (receiver == null) {\n                iterator(object[k], k, object);\n            } else {\n                iterator.call(receiver, object[k], k, object);\n            }\n        }\n    }\n};\n\nvar forEach = function forEach(list, iterator, thisArg) {\n    if (!isCallable(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    var receiver;\n    if (arguments.length >= 3) {\n        receiver = thisArg;\n    }\n\n    if (toStr.call(list) === '[object Array]') {\n        forEachArray(list, iterator, receiver);\n    } else if (typeof list === 'string') {\n        forEachString(list, iterator, receiver);\n    } else {\n        forEachObject(list, iterator, receiver);\n    }\n};\n\nmodule.exports = forEach;\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar toStr = Object.prototype.toString;\nvar max = Math.max;\nvar funcType = '[object Function]';\n\nvar concatty = function concatty(a, b) {\n    var arr = [];\n\n    for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n    }\n\n    return arr;\n};\n\nvar slicy = function slicy(arrLike, offset) {\n    var arr = [];\n    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n    }\n    return arr;\n};\n\nvar joiny = function (arr, joiner) {\n    var str = '';\n    for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n            str += joiner;\n        }\n    }\n    return str;\n};\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                concatty(args, arguments)\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            concatty(args, arguments)\n        );\n\n    };\n\n    var boundLength = max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = '$' + i;\n    }\n\n    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","'use strict';\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\nvar hasProto = require('has-proto')();\n\nvar getProto = Object.getPrototypeOf || (\n\thasProto\n\t\t? function (x) { return x.__proto__; } // eslint-disable-line no-proto\n\t\t: null\n);\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('hasown');\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\n\nvar hasPropertyDescriptors = function hasPropertyDescriptors() {\n\tif ($defineProperty) {\n\t\ttry {\n\t\t\t$defineProperty({}, 'a', { value: 1 });\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\t// IE 8 has a broken defineProperty\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n};\n\nhasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {\n\t// node v0.6 has a bug where array lengths can be Set but not Defined\n\tif (!hasPropertyDescriptors()) {\n\t\treturn null;\n\t}\n\ttry {\n\t\treturn $defineProperty([], 'length', { value: 1 }).length !== 1;\n\t} catch (e) {\n\t\t// In Firefox 4-22, defining length on an array throws an exception.\n\t\treturn true;\n\t}\n};\n\nmodule.exports = hasPropertyDescriptors;\n","'use strict';\n\nvar test = {\n\tfoo: {}\n};\n\nvar $Object = Object;\n\nmodule.exports = function hasProto() {\n\treturn { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);\n};\n","'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n","'use strict';\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\nvar hasSymbols = require('has-symbols/shams');\n\n/** @type {import('.')} */\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n","'use strict';\n\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = require('function-bind');\n\n/** @type {(o: {}, p: PropertyKey) => p is keyof o} */\nmodule.exports = bind.call(call, $hasOwn);\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n","'use strict';\n\nvar fnToStr = Function.prototype.toString;\nvar reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;\nvar badArrayLike;\nvar isCallableMarker;\nif (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {\n\ttry {\n\t\tbadArrayLike = Object.defineProperty({}, 'length', {\n\t\t\tget: function () {\n\t\t\t\tthrow isCallableMarker;\n\t\t\t}\n\t\t});\n\t\tisCallableMarker = {};\n\t\t// eslint-disable-next-line no-throw-literal\n\t\treflectApply(function () { throw 42; }, null, badArrayLike);\n\t} catch (_) {\n\t\tif (_ !== isCallableMarker) {\n\t\t\treflectApply = null;\n\t\t}\n\t}\n} else {\n\treflectApply = null;\n}\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar objectClass = '[object Object]';\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar ddaClass = '[object HTMLAllCollection]'; // IE 11\nvar ddaClass2 = '[object HTML document.all class]';\nvar ddaClass3 = '[object HTMLCollection]'; // IE 9-10\nvar hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`\n\nvar isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing\n\nvar isDDA = function isDocumentDotAll() { return false; };\nif (typeof document === 'object') {\n\t// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly\n\tvar all = document.all;\n\tif (toStr.call(all) === toStr.call(document.all)) {\n\t\tisDDA = function isDocumentDotAll(value) {\n\t\t\t/* globals document: false */\n\t\t\t// in IE 6-8, typeof document.all is \"object\" and it's truthy\n\t\t\tif ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {\n\t\t\t\ttry {\n\t\t\t\t\tvar str = toStr.call(value);\n\t\t\t\t\treturn (\n\t\t\t\t\t\tstr === ddaClass\n\t\t\t\t\t\t|| str === ddaClass2\n\t\t\t\t\t\t|| str === ddaClass3 // opera 12.16\n\t\t\t\t\t\t|| str === objectClass // IE 6-8\n\t\t\t\t\t) && value('') == null; // eslint-disable-line eqeqeq\n\t\t\t\t} catch (e) { /**/ }\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t}\n}\n\nmodule.exports = reflectApply\n\t? function isCallable(value) {\n\t\tif (isDDA(value)) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\ttry {\n\t\t\treflectApply(value, null, badArrayLike);\n\t\t} catch (e) {\n\t\t\tif (e !== isCallableMarker) { return false; }\n\t\t}\n\t\treturn !isES6ClassFn(value) && tryFunctionObject(value);\n\t}\n\t: function isCallable(value) {\n\t\tif (isDDA(value)) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\tif (hasToStringTag) { return tryFunctionObject(value); }\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tvar strClass = toStr.call(value);\n\t\tif (strClass !== fnClass && strClass !== genClass && !(/^\\[object HTML/).test(strClass)) { return false; }\n\t\treturn tryFunctionObject(value);\n\t};\n","'use strict';\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n","'use strict';\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\nmodule.exports = function isNaN(value) {\n\treturn value !== value;\n};\n","'use strict';\n\nvar callBind = require('call-bind');\nvar define = require('define-properties');\n\nvar implementation = require('./implementation');\nvar getPolyfill = require('./polyfill');\nvar shim = require('./shim');\n\nvar polyfill = callBind(getPolyfill(), Number);\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\ndefine(polyfill, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = polyfill;\n","'use strict';\n\nvar bind = require('function-bind');\nvar GetIntrinsic = require('get-intrinsic');\nvar setFunctionLength = require('set-function-length');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tif (typeof originalFunction !== 'function') {\n\t\tthrow new $TypeError('a function is required');\n\t}\n\tvar func = $reflectApply(bind, $call, arguments);\n\treturn setFunctionLength(\n\t\tfunc,\n\t\t1 + $max(0, originalFunction.length - (arguments.length - 1)),\n\t\ttrue\n\t);\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n","'use strict';\n\nvar hasPropertyDescriptors = require('has-property-descriptors')();\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $defineProperty = hasPropertyDescriptors && GetIntrinsic('%Object.defineProperty%', true);\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = false;\n\t}\n}\n\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar gopd = require('gopd');\n\n/** @type {(obj: Record<PropertyKey, unknown>, property: PropertyKey, value: unknown, nonEnumerable?: boolean | null, nonWritable?: boolean | null, nonConfigurable?: boolean | null, loose?: boolean) => void} */\nmodule.exports = function defineDataProperty(\n\tobj,\n\tproperty,\n\tvalue\n) {\n\tif (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {\n\t\tthrow new $TypeError('`obj` must be an object or a function`');\n\t}\n\tif (typeof property !== 'string' && typeof property !== 'symbol') {\n\t\tthrow new $TypeError('`property` must be a string or a symbol`');\n\t}\n\tif (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {\n\t\tthrow new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {\n\t\tthrow new $TypeError('`nonWritable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {\n\t\tthrow new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');\n\t}\n\tif (arguments.length > 6 && typeof arguments[6] !== 'boolean') {\n\t\tthrow new $TypeError('`loose`, if provided, must be a boolean');\n\t}\n\n\tvar nonEnumerable = arguments.length > 3 ? arguments[3] : null;\n\tvar nonWritable = arguments.length > 4 ? arguments[4] : null;\n\tvar nonConfigurable = arguments.length > 5 ? arguments[5] : null;\n\tvar loose = arguments.length > 6 ? arguments[6] : false;\n\n\t/* @type {false | TypedPropertyDescriptor<unknown>} */\n\tvar desc = !!gopd && gopd(obj, property);\n\n\tif ($defineProperty) {\n\t\t$defineProperty(obj, property, {\n\t\t\tconfigurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,\n\t\t\tenumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,\n\t\t\tvalue: value,\n\t\t\twritable: nonWritable === null && desc ? desc.writable : !nonWritable\n\t\t});\n\t} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {\n\t\t// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable\n\t\tobj[property] = value; // eslint-disable-line no-param-reassign\n\t} else {\n\t\tthrow new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');\n\t}\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar define = require('define-data-property');\nvar hasDescriptors = require('has-property-descriptors')();\nvar gOPD = require('gopd');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $floor = GetIntrinsic('%Math.floor%');\n\nmodule.exports = function setFunctionLength(fn, length) {\n\tif (typeof fn !== 'function') {\n\t\tthrow new $TypeError('`fn` is not a function');\n\t}\n\tif (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {\n\t\tthrow new $TypeError('`length` must be a positive 32-bit integer');\n\t}\n\n\tvar loose = arguments.length > 2 && !!arguments[2];\n\n\tvar functionLengthIsConfigurable = true;\n\tvar functionLengthIsWritable = true;\n\tif ('length' in fn && gOPD) {\n\t\tvar desc = gOPD(fn, 'length');\n\t\tif (desc && !desc.configurable) {\n\t\t\tfunctionLengthIsConfigurable = false;\n\t\t}\n\t\tif (desc && !desc.writable) {\n\t\t\tfunctionLengthIsWritable = false;\n\t\t}\n\t}\n\n\tif (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {\n\t\tif (hasDescriptors) {\n\t\t\tdefine(fn, 'length', length, true, true);\n\t\t} else {\n\t\t\tdefine(fn, 'length', length);\n\t\t}\n\t}\n\treturn fn;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = function getPolyfill() {\n\tif (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {\n\t\treturn Number.isNaN;\n\t}\n\treturn implementation;\n};\n","'use strict';\n\nvar define = require('define-properties');\nvar getPolyfill = require('./polyfill');\n\n/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */\n\nmodule.exports = function shimNumberIsNaN() {\n\tvar polyfill = getPolyfill();\n\tdefine(Number, { isNaN: polyfill }, {\n\t\tisNaN: function testIsNaN() {\n\t\t\treturn Number.isNaN !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n","'use strict';\n\nvar whichTypedArray = require('which-typed-array');\n\n/** @type {import('.')} */\nmodule.exports = function isTypedArray(value) {\n\treturn !!whichTypedArray(value);\n};\n","'use strict';\n\nvar numberIsNaN = function (value) {\n\treturn value !== value;\n};\n\nmodule.exports = function is(a, b) {\n\tif (a === 0 && b === 0) {\n\t\treturn 1 / a === 1 / b;\n\t}\n\tif (a === b) {\n\t\treturn true;\n\t}\n\tif (numberIsNaN(a) && numberIsNaN(b)) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n","'use strict';\n\nvar define = require('define-properties');\nvar callBind = require('call-bind');\n\nvar implementation = require('./implementation');\nvar getPolyfill = require('./polyfill');\nvar shim = require('./shim');\n\nvar polyfill = callBind(getPolyfill(), Object);\n\ndefine(polyfill, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = polyfill;\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = function getPolyfill() {\n\treturn typeof Object.is === 'function' ? Object.is : implementation;\n};\n","'use strict';\n\nvar getPolyfill = require('./polyfill');\nvar define = require('define-properties');\n\nmodule.exports = function shimObjectIs() {\n\tvar polyfill = getPolyfill();\n\tdefine(Object, { is: polyfill }, {\n\t\tis: function testObjectIs() {\n\t\t\treturn Object.is !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n","'use strict';\n\nvar keysShim;\nif (!Object.keys) {\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar isArgs = require('./isArguments'); // eslint-disable-line global-require\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$applicationCache: true,\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$onmozfullscreenchange: true,\n\t\t$onmozfullscreenerror: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}\nmodule.exports = keysShim;\n","'use strict';\n\nvar slice = Array.prototype.slice;\nvar isArgs = require('./isArguments');\n\nvar origKeys = Object.keys;\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');\n\nvar originalKeys = Object.keys;\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\tvar args = Object.keys(arguments);\n\t\t\treturn args && args.length === arguments.length;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t}\n\t\t\t\treturn originalKeys(object);\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n","'use strict';\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n","'use strict';\n\n// modified from https://github.com/es-shims/es6-shim\nvar objectKeys = require('object-keys');\nvar hasSymbols = require('has-symbols/shams')();\nvar callBound = require('call-bind/callBound');\nvar toObject = Object;\nvar $push = callBound('Array.prototype.push');\nvar $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');\nvar originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;\n\n// eslint-disable-next-line no-unused-vars\nmodule.exports = function assign(target, source1) {\n\tif (target == null) { throw new TypeError('target must be an object'); }\n\tvar to = toObject(target); // step 1\n\tif (arguments.length === 1) {\n\t\treturn to; // step 2\n\t}\n\tfor (var s = 1; s < arguments.length; ++s) {\n\t\tvar from = toObject(arguments[s]); // step 3.a.i\n\n\t\t// step 3.a.ii:\n\t\tvar keys = objectKeys(from);\n\t\tvar getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);\n\t\tif (getSymbols) {\n\t\t\tvar syms = getSymbols(from);\n\t\t\tfor (var j = 0; j < syms.length; ++j) {\n\t\t\t\tvar key = syms[j];\n\t\t\t\tif ($propIsEnumerable(from, key)) {\n\t\t\t\t\t$push(keys, key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// step 3.a.iii:\n\t\tfor (var i = 0; i < keys.length; ++i) {\n\t\t\tvar nextKey = keys[i];\n\t\t\tif ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2\n\t\t\t\tvar propValue = from[nextKey]; // step 3.a.iii.2.a\n\t\t\t\tto[nextKey] = propValue; // step 3.a.iii.2.b\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to; // step 4\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nvar lacksProperEnumerationOrder = function () {\n\tif (!Object.assign) {\n\t\treturn false;\n\t}\n\t/*\n\t * v8, specifically in node 4.x, has a bug with incorrect property enumeration order\n\t * note: this does not detect the bug unless there's 20 characters\n\t */\n\tvar str = 'abcdefghijklmnopqrst';\n\tvar letters = str.split('');\n\tvar map = {};\n\tfor (var i = 0; i < letters.length; ++i) {\n\t\tmap[letters[i]] = letters[i];\n\t}\n\tvar obj = Object.assign({}, map);\n\tvar actual = '';\n\tfor (var k in obj) {\n\t\tactual += k;\n\t}\n\treturn str !== actual;\n};\n\nvar assignHasPendingExceptions = function () {\n\tif (!Object.assign || !Object.preventExtensions) {\n\t\treturn false;\n\t}\n\t/*\n\t * Firefox 37 still has \"pending exception\" logic in its Object.assign implementation,\n\t * which is 72% slower than our shim, and Firefox 40's native implementation.\n\t */\n\tvar thrower = Object.preventExtensions({ 1: 2 });\n\ttry {\n\t\tObject.assign(thrower, 'xy');\n\t} catch (e) {\n\t\treturn thrower[1] === 'y';\n\t}\n\treturn false;\n};\n\nmodule.exports = function getPolyfill() {\n\tif (!Object.assign) {\n\t\treturn implementation;\n\t}\n\tif (lacksProperEnumerationOrder()) {\n\t\treturn implementation;\n\t}\n\tif (assignHasPendingExceptions()) {\n\t\treturn implementation;\n\t}\n\treturn Object.assign;\n};\n","'use strict';\n\n/** @type {import('.')} */\nmodule.exports = [\n\t'Float32Array',\n\t'Float64Array',\n\t'Int8Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'BigInt64Array',\n\t'BigUint64Array'\n];\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar define = require('define-data-property');\nvar hasDescriptors = require('has-property-descriptors')();\nvar gOPD = require('gopd');\n\nvar $TypeError = require('es-errors/type');\nvar $floor = GetIntrinsic('%Math.floor%');\n\n/** @type {import('.')} */\nmodule.exports = function setFunctionLength(fn, length) {\n\tif (typeof fn !== 'function') {\n\t\tthrow new $TypeError('`fn` is not a function');\n\t}\n\tif (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {\n\t\tthrow new $TypeError('`length` must be a positive 32-bit integer');\n\t}\n\n\tvar loose = arguments.length > 2 && !!arguments[2];\n\n\tvar functionLengthIsConfigurable = true;\n\tvar functionLengthIsWritable = true;\n\tif ('length' in fn && gOPD) {\n\t\tvar desc = gOPD(fn, 'length');\n\t\tif (desc && !desc.configurable) {\n\t\t\tfunctionLengthIsConfigurable = false;\n\t\t}\n\t\tif (desc && !desc.writable) {\n\t\t\tfunctionLengthIsWritable = false;\n\t\t}\n\t}\n\n\tif (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {\n\t\tif (hasDescriptors) {\n\t\t\tdefine(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);\n\t\t} else {\n\t\t\tdefine(/** @type {Parameters<define>[0]} */ (fn), 'length', length);\n\t\t}\n\t}\n\treturn fn;\n};\n","'use strict';\n\nvar undefined;\n\nvar $Error = require('es-errors');\nvar $EvalError = require('es-errors/eval');\nvar $RangeError = require('es-errors/range');\nvar $ReferenceError = require('es-errors/ref');\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\nvar $URIError = require('es-errors/uri');\n\nvar $Function = Function;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\nvar hasProto = require('has-proto')();\n\nvar getProto = Object.getPrototypeOf || (\n\thasProto\n\t\t? function (x) { return x.__proto__; } // eslint-disable-line no-proto\n\t\t: null\n);\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t__proto__: null,\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': $Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': $EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': $RangeError,\n\t'%ReferenceError%': $ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': $URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t__proto__: null,\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('hasown');\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar $defineProperty = require('es-define-property');\n\nvar hasPropertyDescriptors = function hasPropertyDescriptors() {\n\treturn !!$defineProperty;\n};\n\nhasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {\n\t// node v0.6 has a bug where array lengths can be Set but not Defined\n\tif (!$defineProperty) {\n\t\treturn null;\n\t}\n\ttry {\n\t\treturn $defineProperty([], 'length', { value: 1 }).length !== 1;\n\t} catch (e) {\n\t\t// In Firefox 4-22, defining length on an array throws an exception.\n\t\treturn true;\n\t}\n};\n\nmodule.exports = hasPropertyDescriptors;\n","\n      import API from \"!../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!../node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!../node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!../node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!../node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!../node_modules/css-loader/dist/cjs.js!../node_modules/postcss-loader/dist/cjs.js!./style.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\n\n      options.insert = insertFn.bind(null, \"head\");\n    \noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!../node_modules/css-loader/dist/cjs.js!../node_modules/postcss-loader/dist/cjs.js!./style.css\";\n       export default content && content.locals ? content.locals : undefined;\n","\"use strict\";\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","\"use strict\";\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce = typeof __webpack_nonce__ !== \"undefined\" ? __webpack_nonce__ : null;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n'use strict';\n\nvar isArgumentsObject = require('is-arguments');\nvar isGeneratorFunction = require('is-generator-function');\nvar whichTypedArray = require('which-typed-array');\nvar isTypedArray = require('is-typed-array');\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (process.env.NODE_DEBUG) {\n  var debugEnv = process.env.NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').slice(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.slice(1, -1);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = require('./support/types');\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","'use strict';\n\nvar forEach = require('for-each');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBind = require('call-bind');\nvar callBound = require('call-bind/callBound');\nvar gOPD = require('gopd');\n\n/** @type {(O: object) => string} */\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\n\n/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n/** @typedef {(receiver: import('.').TypedArray) => string | typeof Uint8Array.prototype.slice.call | typeof Uint8Array.prototype.set.call} Getter */\n/** @type {{ [k in `\\$${import('.').TypedArrayName}`]?: Getter } & { __proto__: null }} */\nvar cache = { __proto__: null };\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t// @ts-expect-error TS won't narrow inside a closure\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t// @ts-expect-error TS won't narrow inside a closure\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\t// @ts-expect-error TODO: fix\n\t\t\tcache['$' + typedArray] = callBind(descriptor.get);\n\t\t}\n\t});\n} else {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tvar fn = arr.slice || arr.set;\n\t\tif (fn) {\n\t\t\t// @ts-expect-error TODO: fix\n\t\t\tcache['$' + typedArray] = callBind(fn);\n\t\t}\n\t});\n}\n\n/** @type {(value: object) => false | import('.').TypedArrayName} */\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\t/** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;\n\tforEach(\n\t\t// eslint-disable-next-line no-extra-parens\n\t\t/** @type {Record<`\\$${TypedArrayName}`, Getter>} */ /** @type {any} */ (cache),\n\t\t/** @type {(getter: Getter, name: `\\$${import('.').TypedArrayName}`) => void} */\n\t\tfunction (getter, typedArray) {\n\t\t\tif (!found) {\n\t\t\t\ttry {\n\t\t\t\t// @ts-expect-error TODO: fix\n\t\t\t\t\tif ('$' + getter(value) === typedArray) {\n\t\t\t\t\t\tfound = $slice(typedArray, 1);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) { /**/ }\n\t\t\t}\n\t\t}\n\t);\n\treturn found;\n};\n\n/** @type {(value: object) => false | import('.').TypedArrayName} */\nvar trySlices = function tryAllSlices(value) {\n\t/** @type {ReturnType<typeof tryAllSlices>} */ var found = false;\n\tforEach(\n\t\t// eslint-disable-next-line no-extra-parens\n\t\t/** @type {Record<`\\$${TypedArrayName}`, Getter>} */ /** @type {any} */ (cache),\n\t\t/** @type {(getter: typeof cache, name: `\\$${import('.').TypedArrayName}`) => void} */ function (getter, name) {\n\t\t\tif (!found) {\n\t\t\t\ttry {\n\t\t\t\t\t// @ts-expect-error TODO: fix\n\t\t\t\t\tgetter(value);\n\t\t\t\t\tfound = $slice(name, 1);\n\t\t\t\t} catch (e) { /**/ }\n\t\t\t}\n\t\t}\n\t);\n\treturn found;\n};\n\n/** @type {import('.')} */\nmodule.exports = function whichTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag) {\n\t\t/** @type {string} */\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\tif ($indexOf(typedArrays, tag) > -1) {\n\t\t\treturn tag;\n\t\t}\n\t\tif (tag !== 'Object') {\n\t\t\treturn false;\n\t\t}\n\t\t// node < 0.6 hits here on real Typed Arrays\n\t\treturn trySlices(value);\n\t}\n\tif (!gOPD) { return null; } // unknown engine\n\treturn tryTypedArrays(value);\n};\n","const __$G =\r\n    typeof globalThis !== \"undefined\"\r\n        ? globalThis\r\n        : typeof window !== \"undefined\"\r\n          ? window\r\n          : typeof global !== \"undefined\"\r\n            ? global\r\n            : typeof self !== \"undefined\"\r\n              ? self\r\n              : {}\r\nconst version = \"6.9.1\"\r\nfunction checkType(value, type, name) {\r\n    const types = type.split(\"|\").map((t) => t.trim())\r\n    for (let i = 0; i < types.length; i++) {\r\n        switch (type) {\r\n            case \"any\":\r\n                return\r\n            case \"bigint\":\r\n            case \"boolean\":\r\n            case \"number\":\r\n            case \"string\":\r\n                if (typeof value === type) {\r\n                    return\r\n                }\r\n        }\r\n    }\r\n    const error = new Error(`invalid value for type ${type}`)\r\n    error.code = \"INVALID_ARGUMENT\"\r\n    error.argument = `value.${name}`\r\n    error.value = value\r\n    throw error\r\n}\r\nasync function resolveProperties(value) {\r\n    const keys = Object.keys(value)\r\n    const results = await Promise.all(\r\n        keys.map((k) => Promise.resolve(value[k])),\r\n    )\r\n    return results.reduce((accum, v, index) => {\r\n        accum[keys[index]] = v\r\n        return accum\r\n    }, {})\r\n}\r\nfunction defineProperties(target, values, types) {\r\n    for (let key in values) {\r\n        let value = values[key]\r\n        const type = types ? types[key] : null\r\n        if (type) {\r\n            checkType(value, type, key)\r\n        }\r\n        Object.defineProperty(target, key, {\r\n            enumerable: true,\r\n            value: value,\r\n            writable: false,\r\n        })\r\n    }\r\n}\r\nfunction stringify$1(value) {\r\n    if (value == null) {\r\n        return \"null\"\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return \"[ \" + value.map(stringify$1).join(\", \") + \" ]\"\r\n    }\r\n    if (value instanceof Uint8Array) {\r\n        const HEX = \"0123456789abcdef\"\r\n        let result = \"0x\"\r\n        for (let i = 0; i < value.length; i++) {\r\n            result += HEX[value[i] >> 4]\r\n            result += HEX[value[i] & 15]\r\n        }\r\n        return result\r\n    }\r\n    if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\r\n        return stringify$1(value.toJSON())\r\n    }\r\n    switch (typeof value) {\r\n        case \"boolean\":\r\n        case \"symbol\":\r\n            return value.toString()\r\n        case \"bigint\":\r\n            return BigInt(value).toString()\r\n        case \"number\":\r\n            return value.toString()\r\n        case \"string\":\r\n            return JSON.stringify(value)\r\n        case \"object\": {\r\n            const keys = Object.keys(value)\r\n            keys.sort()\r\n            return (\r\n                \"{ \" +\r\n                keys\r\n                    .map((k) => `${stringify$1(k)}: ${stringify$1(value[k])}`)\r\n                    .join(\", \") +\r\n                \" }\"\r\n            )\r\n        }\r\n    }\r\n    return `[ COULD NOT SERIALIZE ]`\r\n}\r\nfunction isError(error, code) {\r\n    return error && error.code === code\r\n}\r\nfunction isCallException(error) {\r\n    return isError(error, \"CALL_EXCEPTION\")\r\n}\r\nfunction makeError(message, code, info) {\r\n    let shortMessage = message\r\n    {\r\n        const details = []\r\n        if (info) {\r\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\r\n                throw new Error(\r\n                    `value will overwrite populated values: ${stringify$1(\r\n                        info,\r\n                    )}`,\r\n                )\r\n            }\r\n            for (const key in info) {\r\n                if (key === \"shortMessage\") {\r\n                    continue\r\n                }\r\n                const value = info[key]\r\n                details.push(key + \"=\" + stringify$1(value))\r\n            }\r\n        }\r\n        details.push(`code=${code}`)\r\n        details.push(`version=${version}`)\r\n        if (details.length) {\r\n            message += \" (\" + details.join(\", \") + \")\"\r\n        }\r\n    }\r\n    let error\r\n    switch (code) {\r\n        case \"INVALID_ARGUMENT\":\r\n            error = new TypeError(message)\r\n            break\r\n        case \"NUMERIC_FAULT\":\r\n        case \"BUFFER_OVERRUN\":\r\n            error = new RangeError(message)\r\n            break\r\n        default:\r\n            error = new Error(message)\r\n    }\r\n    defineProperties(error, {\r\n        code: code,\r\n    })\r\n    if (info) {\r\n        Object.assign(error, info)\r\n    }\r\n    if (error.shortMessage == null) {\r\n        defineProperties(error, {\r\n            shortMessage: shortMessage,\r\n        })\r\n    }\r\n    return error\r\n}\r\nfunction assert(check, message, code, info) {\r\n    if (!check) {\r\n        throw makeError(message, code, info)\r\n    }\r\n}\r\nfunction assertArgument(check, message, name, value) {\r\n    assert(check, message, \"INVALID_ARGUMENT\", {\r\n        argument: name,\r\n        value: value,\r\n    })\r\n}\r\nfunction assertArgumentCount(count, expectedCount, message) {\r\n    if (message == null) {\r\n        message = \"\"\r\n    }\r\n    if (message) {\r\n        message = \": \" + message\r\n    }\r\n    assert(\r\n        count >= expectedCount,\r\n        \"missing arguemnt\" + message,\r\n        \"MISSING_ARGUMENT\",\r\n        {\r\n            count: count,\r\n            expectedCount: expectedCount,\r\n        },\r\n    )\r\n    assert(\r\n        count <= expectedCount,\r\n        \"too many arguemnts\" + message,\r\n        \"UNEXPECTED_ARGUMENT\",\r\n        {\r\n            count: count,\r\n            expectedCount: expectedCount,\r\n        },\r\n    )\r\n}\r\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\r\n    try {\r\n        if (\"test\".normalize(form) !== \"test\") {\r\n            throw new Error(\"bad\")\r\n        }\r\n        if (form === \"NFD\") {\r\n            const check = String.fromCharCode(233).normalize(\"NFD\")\r\n            const expected = String.fromCharCode(101, 769)\r\n            if (check !== expected) {\r\n                throw new Error(\"broken\")\r\n            }\r\n        }\r\n        accum.push(form)\r\n    } catch (error) {}\r\n    return accum\r\n}, [])\r\nfunction assertNormalize(form) {\r\n    assert(\r\n        _normalizeForms.indexOf(form) >= 0,\r\n        \"platform missing String.prototype.normalize\",\r\n        \"UNSUPPORTED_OPERATION\",\r\n        {\r\n            operation: \"String.prototype.normalize\",\r\n            info: {\r\n                form: form,\r\n            },\r\n        },\r\n    )\r\n}\r\nfunction assertPrivate(givenGuard, guard, className) {\r\n    if (className == null) {\r\n        className = \"\"\r\n    }\r\n    if (givenGuard !== guard) {\r\n        let method = className,\r\n            operation = \"new\"\r\n        if (className) {\r\n            method += \".\"\r\n            operation += \" \" + className\r\n        }\r\n        assert(\r\n            false,\r\n            `private constructor; use ${method}from* methods`,\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: operation,\r\n            },\r\n        )\r\n    }\r\n}\r\nfunction _getBytes(value, name, copy) {\r\n    if (value instanceof Uint8Array) {\r\n        if (copy) {\r\n            return new Uint8Array(value)\r\n        }\r\n        return value\r\n    }\r\n    if (typeof value === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\r\n        const result = new Uint8Array((value.length - 2) / 2)\r\n        let offset = 2\r\n        for (let i = 0; i < result.length; i++) {\r\n            result[i] = parseInt(value.substring(offset, offset + 2), 16)\r\n            offset += 2\r\n        }\r\n        return result\r\n    }\r\n    assertArgument(false, \"invalid BytesLike value\", name || \"value\", value)\r\n}\r\nfunction getBytes(value, name) {\r\n    return _getBytes(value, name, false)\r\n}\r\nfunction getBytesCopy(value, name) {\r\n    return _getBytes(value, name, true)\r\n}\r\nfunction isHexString(value, length) {\r\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\r\n        return false\r\n    }\r\n    if (typeof length === \"number\" && value.length !== 2 + 2 * length) {\r\n        return false\r\n    }\r\n    if (length === true && value.length % 2 !== 0) {\r\n        return false\r\n    }\r\n    return true\r\n}\r\nfunction isBytesLike(value) {\r\n    return isHexString(value, true) || value instanceof Uint8Array\r\n}\r\nconst HexCharacters = \"0123456789abcdef\"\r\nfunction hexlify(data) {\r\n    const bytes = getBytes(data)\r\n    let result = \"0x\"\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        const v = bytes[i]\r\n        result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15]\r\n    }\r\n    return result\r\n}\r\nfunction concat(datas) {\r\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\")\r\n}\r\nfunction dataLength(data) {\r\n    if (isHexString(data, true)) {\r\n        return (data.length - 2) / 2\r\n    }\r\n    return getBytes(data).length\r\n}\r\nfunction dataSlice(data, start, end) {\r\n    const bytes = getBytes(data)\r\n    if (end != null && end > bytes.length) {\r\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\r\n            buffer: bytes,\r\n            length: bytes.length,\r\n            offset: end,\r\n        })\r\n    }\r\n    return hexlify(\r\n        bytes.slice(\r\n            start == null ? 0 : start,\r\n            end == null ? bytes.length : end,\r\n        ),\r\n    )\r\n}\r\nfunction stripZerosLeft(data) {\r\n    let bytes = hexlify(data).substring(2)\r\n    while (bytes.startsWith(\"00\")) {\r\n        bytes = bytes.substring(2)\r\n    }\r\n    return \"0x\" + bytes\r\n}\r\nfunction zeroPad(data, length, left) {\r\n    const bytes = getBytes(data)\r\n    assert(\r\n        length >= bytes.length,\r\n        \"padding exceeds data length\",\r\n        \"BUFFER_OVERRUN\",\r\n        {\r\n            buffer: new Uint8Array(bytes),\r\n            length: length,\r\n            offset: length + 1,\r\n        },\r\n    )\r\n    const result = new Uint8Array(length)\r\n    result.fill(0)\r\n    if (left) {\r\n        result.set(bytes, length - bytes.length)\r\n    } else {\r\n        result.set(bytes, 0)\r\n    }\r\n    return hexlify(result)\r\n}\r\nfunction zeroPadValue(data, length) {\r\n    return zeroPad(data, length, true)\r\n}\r\nfunction zeroPadBytes(data, length) {\r\n    return zeroPad(data, length, false)\r\n}\r\nconst BN_0$a = BigInt(0)\r\nconst BN_1$5 = BigInt(1)\r\nconst maxValue = 9007199254740991\r\nfunction fromTwos(_value, _width) {\r\n    const value = getUint(_value, \"value\")\r\n    const width = BigInt(getNumber(_width, \"width\"))\r\n    assert(value >> width === BN_0$a, \"overflow\", \"NUMERIC_FAULT\", {\r\n        operation: \"fromTwos\",\r\n        fault: \"overflow\",\r\n        value: _value,\r\n    })\r\n    if (value >> (width - BN_1$5)) {\r\n        const mask = (BN_1$5 << width) - BN_1$5\r\n        return -((~value & mask) + BN_1$5)\r\n    }\r\n    return value\r\n}\r\nfunction toTwos(_value, _width) {\r\n    let value = getBigInt(_value, \"value\")\r\n    const width = BigInt(getNumber(_width, \"width\"))\r\n    const limit = BN_1$5 << (width - BN_1$5)\r\n    if (value < BN_0$a) {\r\n        value = -value\r\n        assert(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\r\n            operation: \"toTwos\",\r\n            fault: \"overflow\",\r\n            value: _value,\r\n        })\r\n        const mask = (BN_1$5 << width) - BN_1$5\r\n        return (~value & mask) + BN_1$5\r\n    } else {\r\n        assert(value < limit, \"too high\", \"NUMERIC_FAULT\", {\r\n            operation: \"toTwos\",\r\n            fault: \"overflow\",\r\n            value: _value,\r\n        })\r\n    }\r\n    return value\r\n}\r\nfunction mask(_value, _bits) {\r\n    const value = getUint(_value, \"value\")\r\n    const bits = BigInt(getNumber(_bits, \"bits\"))\r\n    return value & ((BN_1$5 << bits) - BN_1$5)\r\n}\r\nfunction getBigInt(value, name) {\r\n    switch (typeof value) {\r\n        case \"bigint\":\r\n            return value\r\n        case \"number\":\r\n            assertArgument(\r\n                Number.isInteger(value),\r\n                \"underflow\",\r\n                name || \"value\",\r\n                value,\r\n            )\r\n            assertArgument(\r\n                value >= -maxValue && value <= maxValue,\r\n                \"overflow\",\r\n                name || \"value\",\r\n                value,\r\n            )\r\n            return BigInt(value)\r\n        case \"string\":\r\n            try {\r\n                if (value === \"\") {\r\n                    throw new Error(\"empty string\")\r\n                }\r\n                if (value[0] === \"-\" && value[1] !== \"-\") {\r\n                    return -BigInt(value.substring(1))\r\n                }\r\n                return BigInt(value)\r\n            } catch (e) {\r\n                assertArgument(\r\n                    false,\r\n                    `invalid BigNumberish string: ${e.message}`,\r\n                    name || \"value\",\r\n                    value,\r\n                )\r\n            }\r\n    }\r\n    assertArgument(false, \"invalid BigNumberish value\", name || \"value\", value)\r\n}\r\nfunction getUint(value, name) {\r\n    const result = getBigInt(value, name)\r\n    assert(\r\n        result >= BN_0$a,\r\n        \"unsigned value cannot be negative\",\r\n        \"NUMERIC_FAULT\",\r\n        {\r\n            fault: \"overflow\",\r\n            operation: \"getUint\",\r\n            value: value,\r\n        },\r\n    )\r\n    return result\r\n}\r\nconst Nibbles$1 = \"0123456789abcdef\"\r\nfunction toBigInt(value) {\r\n    if (value instanceof Uint8Array) {\r\n        let result = \"0x0\"\r\n        for (const v of value) {\r\n            result += Nibbles$1[v >> 4]\r\n            result += Nibbles$1[v & 15]\r\n        }\r\n        return BigInt(result)\r\n    }\r\n    return getBigInt(value)\r\n}\r\nfunction getNumber(value, name) {\r\n    switch (typeof value) {\r\n        case \"bigint\":\r\n            assertArgument(\r\n                value >= -maxValue && value <= maxValue,\r\n                \"overflow\",\r\n                name || \"value\",\r\n                value,\r\n            )\r\n            return Number(value)\r\n        case \"number\":\r\n            assertArgument(\r\n                Number.isInteger(value),\r\n                \"underflow\",\r\n                name || \"value\",\r\n                value,\r\n            )\r\n            assertArgument(\r\n                value >= -maxValue && value <= maxValue,\r\n                \"overflow\",\r\n                name || \"value\",\r\n                value,\r\n            )\r\n            return value\r\n        case \"string\":\r\n            try {\r\n                if (value === \"\") {\r\n                    throw new Error(\"empty string\")\r\n                }\r\n                return getNumber(BigInt(value), name)\r\n            } catch (e) {\r\n                assertArgument(\r\n                    false,\r\n                    `invalid numeric string: ${e.message}`,\r\n                    name || \"value\",\r\n                    value,\r\n                )\r\n            }\r\n    }\r\n    assertArgument(false, \"invalid numeric value\", name || \"value\", value)\r\n}\r\nfunction toNumber(value) {\r\n    return getNumber(toBigInt(value))\r\n}\r\nfunction toBeHex(_value, _width) {\r\n    const value = getUint(_value, \"value\")\r\n    let result = value.toString(16)\r\n    if (_width == null) {\r\n        if (result.length % 2) {\r\n            result = \"0\" + result\r\n        }\r\n    } else {\r\n        const width = getNumber(_width, \"width\")\r\n        assert(\r\n            width * 2 >= result.length,\r\n            `value exceeds width (${width} bytes)`,\r\n            \"NUMERIC_FAULT\",\r\n            {\r\n                operation: \"toBeHex\",\r\n                fault: \"overflow\",\r\n                value: _value,\r\n            },\r\n        )\r\n        while (result.length < width * 2) {\r\n            result = \"0\" + result\r\n        }\r\n    }\r\n    return \"0x\" + result\r\n}\r\nfunction toBeArray(_value) {\r\n    const value = getUint(_value, \"value\")\r\n    if (value === BN_0$a) {\r\n        return new Uint8Array([])\r\n    }\r\n    let hex = value.toString(16)\r\n    if (hex.length % 2) {\r\n        hex = \"0\" + hex\r\n    }\r\n    const result = new Uint8Array(hex.length / 2)\r\n    for (let i = 0; i < result.length; i++) {\r\n        const offset = i * 2\r\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16)\r\n    }\r\n    return result\r\n}\r\nfunction toQuantity(value) {\r\n    let result = hexlify(\r\n        isBytesLike(value) ? value : toBeArray(value),\r\n    ).substring(2)\r\n    while (result.startsWith(\"0\")) {\r\n        result = result.substring(1)\r\n    }\r\n    if (result === \"\") {\r\n        result = \"0\"\r\n    }\r\n    return \"0x\" + result\r\n}\r\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\r\nlet Lookup = null\r\nfunction getAlpha(letter) {\r\n    if (Lookup == null) {\r\n        Lookup = {}\r\n        for (let i = 0; i < Alphabet.length; i++) {\r\n            Lookup[Alphabet[i]] = BigInt(i)\r\n        }\r\n    }\r\n    const result = Lookup[letter]\r\n    assertArgument(result != null, `invalid base58 value`, \"letter\", letter)\r\n    return result\r\n}\r\nconst BN_0$9 = BigInt(0)\r\nconst BN_58 = BigInt(58)\r\nfunction encodeBase58(_value) {\r\n    let value = toBigInt(getBytes(_value))\r\n    let result = \"\"\r\n    while (value) {\r\n        result = Alphabet[Number(value % BN_58)] + result\r\n        value /= BN_58\r\n    }\r\n    return result\r\n}\r\nfunction decodeBase58(value) {\r\n    let result = BN_0$9\r\n    for (let i = 0; i < value.length; i++) {\r\n        result *= BN_58\r\n        result += getAlpha(value[i])\r\n    }\r\n    return result\r\n}\r\nfunction decodeBase64(textData) {\r\n    textData = atob(textData)\r\n    const data = new Uint8Array(textData.length)\r\n    for (let i = 0; i < textData.length; i++) {\r\n        data[i] = textData.charCodeAt(i)\r\n    }\r\n    return getBytes(data)\r\n}\r\nfunction encodeBase64(_data) {\r\n    const data = getBytes(_data)\r\n    let textData = \"\"\r\n    for (let i = 0; i < data.length; i++) {\r\n        textData += String.fromCharCode(data[i])\r\n    }\r\n    return btoa(textData)\r\n}\r\nclass EventPayload {\r\n    filter\r\n    emitter\r\n    #listener\r\n    constructor(emitter, listener, filter) {\r\n        this.#listener = listener\r\n        defineProperties(this, {\r\n            emitter: emitter,\r\n            filter: filter,\r\n        })\r\n    }\r\n    async removeListener() {\r\n        if (this.#listener == null) {\r\n            return\r\n        }\r\n        await this.emitter.off(this.filter, this.#listener)\r\n    }\r\n}\r\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\r\n    assertArgument(\r\n        false,\r\n        `invalid codepoint at offset ${offset}; ${reason}`,\r\n        \"bytes\",\r\n        bytes,\r\n    )\r\n}\r\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\r\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\r\n        let i = 0\r\n        for (let o = offset + 1; o < bytes.length; o++) {\r\n            if (bytes[o] >> 6 !== 2) {\r\n                break\r\n            }\r\n            i++\r\n        }\r\n        return i\r\n    }\r\n    if (reason === \"OVERRUN\") {\r\n        return bytes.length - offset - 1\r\n    }\r\n    return 0\r\n}\r\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\r\n    if (reason === \"OVERLONG\") {\r\n        assertArgument(\r\n            typeof badCodepoint === \"number\",\r\n            \"invalid bad code point for replacement\",\r\n            \"badCodepoint\",\r\n            badCodepoint,\r\n        )\r\n        output.push(badCodepoint)\r\n        return 0\r\n    }\r\n    output.push(65533)\r\n    return ignoreFunc(reason, offset, bytes)\r\n}\r\nconst Utf8ErrorFuncs = Object.freeze({\r\n    error: errorFunc,\r\n    ignore: ignoreFunc,\r\n    replace: replaceFunc,\r\n})\r\nfunction getUtf8CodePoints(_bytes, onError) {\r\n    if (onError == null) {\r\n        onError = Utf8ErrorFuncs.error\r\n    }\r\n    const bytes = getBytes(_bytes, \"bytes\")\r\n    const result = []\r\n    let i = 0\r\n    while (i < bytes.length) {\r\n        const c = bytes[i++]\r\n        if (c >> 7 === 0) {\r\n            result.push(c)\r\n            continue\r\n        }\r\n        let extraLength = null\r\n        let overlongMask = null\r\n        if ((c & 224) === 192) {\r\n            extraLength = 1\r\n            overlongMask = 127\r\n        } else if ((c & 240) === 224) {\r\n            extraLength = 2\r\n            overlongMask = 2047\r\n        } else if ((c & 248) === 240) {\r\n            extraLength = 3\r\n            overlongMask = 65535\r\n        } else {\r\n            if ((c & 192) === 128) {\r\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result)\r\n            } else {\r\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result)\r\n            }\r\n            continue\r\n        }\r\n        if (i - 1 + extraLength >= bytes.length) {\r\n            i += onError(\"OVERRUN\", i - 1, bytes, result)\r\n            continue\r\n        }\r\n        let res = c & ((1 << (8 - extraLength - 1)) - 1)\r\n        for (let j = 0; j < extraLength; j++) {\r\n            let nextChar = bytes[i]\r\n            if ((nextChar & 192) != 128) {\r\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result)\r\n                res = null\r\n                break\r\n            }\r\n            res = (res << 6) | (nextChar & 63)\r\n            i++\r\n        }\r\n        if (res === null) {\r\n            continue\r\n        }\r\n        if (res > 1114111) {\r\n            i += onError(\r\n                \"OUT_OF_RANGE\",\r\n                i - 1 - extraLength,\r\n                bytes,\r\n                result,\r\n                res,\r\n            )\r\n            continue\r\n        }\r\n        if (res >= 55296 && res <= 57343) {\r\n            i += onError(\r\n                \"UTF16_SURROGATE\",\r\n                i - 1 - extraLength,\r\n                bytes,\r\n                result,\r\n                res,\r\n            )\r\n            continue\r\n        }\r\n        if (res <= overlongMask) {\r\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res)\r\n            continue\r\n        }\r\n        result.push(res)\r\n    }\r\n    return result\r\n}\r\nfunction toUtf8Bytes(str, form) {\r\n    if (form != null) {\r\n        assertNormalize(form)\r\n        str = str.normalize(form)\r\n    }\r\n    let result = []\r\n    for (let i = 0; i < str.length; i++) {\r\n        const c = str.charCodeAt(i)\r\n        if (c < 128) {\r\n            result.push(c)\r\n        } else if (c < 2048) {\r\n            result.push((c >> 6) | 192)\r\n            result.push((c & 63) | 128)\r\n        } else if ((c & 64512) == 55296) {\r\n            i++\r\n            const c2 = str.charCodeAt(i)\r\n            assertArgument(\r\n                i < str.length && (c2 & 64512) === 56320,\r\n                \"invalid surrogate pair\",\r\n                \"str\",\r\n                str,\r\n            )\r\n            const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023)\r\n            result.push((pair >> 18) | 240)\r\n            result.push(((pair >> 12) & 63) | 128)\r\n            result.push(((pair >> 6) & 63) | 128)\r\n            result.push((pair & 63) | 128)\r\n        } else {\r\n            result.push((c >> 12) | 224)\r\n            result.push(((c >> 6) & 63) | 128)\r\n            result.push((c & 63) | 128)\r\n        }\r\n    }\r\n    return new Uint8Array(result)\r\n}\r\nfunction _toUtf8String(codePoints) {\r\n    return codePoints\r\n        .map((codePoint) => {\r\n            if (codePoint <= 65535) {\r\n                return String.fromCharCode(codePoint)\r\n            }\r\n            codePoint -= 65536\r\n            return String.fromCharCode(\r\n                ((codePoint >> 10) & 1023) + 55296,\r\n                (codePoint & 1023) + 56320,\r\n            )\r\n        })\r\n        .join(\"\")\r\n}\r\nfunction toUtf8String(bytes, onError) {\r\n    return _toUtf8String(getUtf8CodePoints(bytes, onError))\r\n}\r\nfunction toUtf8CodePoints(str, form) {\r\n    return getUtf8CodePoints(toUtf8Bytes(str, form))\r\n}\r\nfunction createGetUrl(options) {\r\n    async function getUrl(req, _signal) {\r\n        const protocol = req.url.split(\":\")[0].toLowerCase()\r\n        assert(\r\n            protocol === \"http\" || protocol === \"https\",\r\n            `unsupported protocol ${protocol}`,\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                info: {\r\n                    protocol: protocol,\r\n                },\r\n                operation: \"request\",\r\n            },\r\n        )\r\n        assert(\r\n            protocol === \"https\" ||\r\n                !req.credentials ||\r\n                req.allowInsecureAuthentication,\r\n            \"insecure authorized connections unsupported\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"request\",\r\n            },\r\n        )\r\n        let signal = undefined\r\n        if (_signal) {\r\n            const controller = new AbortController()\r\n            signal = controller.signal\r\n            _signal.addListener(() => {\r\n                controller.abort()\r\n            })\r\n        }\r\n        const init = {\r\n            method: req.method,\r\n            headers: new Headers(Array.from(req)),\r\n            body: req.body || undefined,\r\n            signal: signal,\r\n        }\r\n        const resp = await fetch(req.url, init)\r\n        const headers = {}\r\n        resp.headers.forEach((value, key) => {\r\n            headers[key.toLowerCase()] = value\r\n        })\r\n        const respBody = await resp.arrayBuffer()\r\n        const body = respBody == null ? null : new Uint8Array(respBody)\r\n        return {\r\n            statusCode: resp.status,\r\n            statusMessage: resp.statusText,\r\n            headers: headers,\r\n            body: body,\r\n        }\r\n    }\r\n    return getUrl\r\n}\r\nconst MAX_ATTEMPTS = 12\r\nconst SLOT_INTERVAL = 250\r\nlet defaultGetUrlFunc = createGetUrl()\r\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\")\r\nconst reIpfs = new RegExp(\"^ipfs://(ipfs/)?(.*)$\", \"i\")\r\nlet locked$5 = false\r\nasync function dataGatewayFunc(url, signal) {\r\n    try {\r\n        const match = url.match(reData)\r\n        if (!match) {\r\n            throw new Error(\"invalid data\")\r\n        }\r\n        return new FetchResponse(\r\n            200,\r\n            \"OK\",\r\n            {\r\n                \"content-type\": match[1] || \"text/plain\",\r\n            },\r\n            match[2] ? decodeBase64(match[3]) : unpercent(match[3]),\r\n        )\r\n    } catch (error) {\r\n        return new FetchResponse(\r\n            599,\r\n            \"BAD REQUEST (invalid data: URI)\",\r\n            {},\r\n            null,\r\n            new FetchRequest(url),\r\n        )\r\n    }\r\n}\r\nfunction getIpfsGatewayFunc(baseUrl) {\r\n    async function gatewayIpfs(url, signal) {\r\n        try {\r\n            const match = url.match(reIpfs)\r\n            if (!match) {\r\n                throw new Error(\"invalid link\")\r\n            }\r\n            return new FetchRequest(`${baseUrl}${match[2]}`)\r\n        } catch (error) {\r\n            return new FetchResponse(\r\n                599,\r\n                \"BAD REQUEST (invalid IPFS URI)\",\r\n                {},\r\n                null,\r\n                new FetchRequest(url),\r\n            )\r\n        }\r\n    }\r\n    return gatewayIpfs\r\n}\r\nconst Gateways = {\r\n    data: dataGatewayFunc,\r\n    ipfs: getIpfsGatewayFunc(\"https://gateway.ipfs.io/ipfs/\"),\r\n}\r\nconst fetchSignals = new WeakMap()\r\nclass FetchCancelSignal {\r\n    #listeners\r\n    #cancelled\r\n    constructor(request) {\r\n        this.#listeners = []\r\n        this.#cancelled = false\r\n        fetchSignals.set(request, () => {\r\n            if (this.#cancelled) {\r\n                return\r\n            }\r\n            this.#cancelled = true\r\n            for (const listener of this.#listeners) {\r\n                setTimeout(() => {\r\n                    listener()\r\n                }, 0)\r\n            }\r\n            this.#listeners = []\r\n        })\r\n    }\r\n    addListener(listener) {\r\n        assert(\r\n            !this.#cancelled,\r\n            \"singal already cancelled\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"fetchCancelSignal.addCancelListener\",\r\n            },\r\n        )\r\n        this.#listeners.push(listener)\r\n    }\r\n    get cancelled() {\r\n        return this.#cancelled\r\n    }\r\n    checkSignal() {\r\n        assert(!this.cancelled, \"cancelled\", \"CANCELLED\", {})\r\n    }\r\n}\r\nfunction checkSignal(signal) {\r\n    if (signal == null) {\r\n        throw new Error(\"missing signal; should not happen\")\r\n    }\r\n    signal.checkSignal()\r\n    return signal\r\n}\r\nclass FetchRequest {\r\n    #allowInsecure\r\n    #gzip\r\n    #headers\r\n    #method\r\n    #timeout\r\n    #url\r\n    #body\r\n    #bodyType\r\n    #creds\r\n    #preflight\r\n    #process\r\n    #retry\r\n    #signal\r\n    #throttle\r\n    #getUrlFunc\r\n    get url() {\r\n        return this.#url\r\n    }\r\n    set url(url) {\r\n        this.#url = String(url)\r\n    }\r\n    get body() {\r\n        if (this.#body == null) {\r\n            return null\r\n        }\r\n        return new Uint8Array(this.#body)\r\n    }\r\n    set body(body) {\r\n        if (body == null) {\r\n            this.#body = undefined\r\n            this.#bodyType = undefined\r\n        } else if (typeof body === \"string\") {\r\n            this.#body = toUtf8Bytes(body)\r\n            this.#bodyType = \"text/plain\"\r\n        } else if (body instanceof Uint8Array) {\r\n            this.#body = body\r\n            this.#bodyType = \"application/octet-stream\"\r\n        } else if (typeof body === \"object\") {\r\n            this.#body = toUtf8Bytes(JSON.stringify(body))\r\n            this.#bodyType = \"application/json\"\r\n        } else {\r\n            throw new Error(\"invalid body\")\r\n        }\r\n    }\r\n    hasBody() {\r\n        return this.#body != null\r\n    }\r\n    get method() {\r\n        if (this.#method) {\r\n            return this.#method\r\n        }\r\n        if (this.hasBody()) {\r\n            return \"POST\"\r\n        }\r\n        return \"GET\"\r\n    }\r\n    set method(method) {\r\n        if (method == null) {\r\n            method = \"\"\r\n        }\r\n        this.#method = String(method).toUpperCase()\r\n    }\r\n    get headers() {\r\n        const headers = Object.assign({}, this.#headers)\r\n        if (this.#creds) {\r\n            headers[\"authorization\"] = `Basic ${encodeBase64(\r\n                toUtf8Bytes(this.#creds),\r\n            )}`\r\n        }\r\n        if (this.allowGzip) {\r\n            headers[\"accept-encoding\"] = \"gzip\"\r\n        }\r\n        if (headers[\"content-type\"] == null && this.#bodyType) {\r\n            headers[\"content-type\"] = this.#bodyType\r\n        }\r\n        if (this.body) {\r\n            headers[\"content-length\"] = String(this.body.length)\r\n        }\r\n        return headers\r\n    }\r\n    getHeader(key) {\r\n        return this.headers[key.toLowerCase()]\r\n    }\r\n    setHeader(key, value) {\r\n        this.#headers[String(key).toLowerCase()] = String(value)\r\n    }\r\n    clearHeaders() {\r\n        this.#headers = {}\r\n    }\r\n    [Symbol.iterator]() {\r\n        const headers = this.headers\r\n        const keys = Object.keys(headers)\r\n        let index = 0\r\n        return {\r\n            next: () => {\r\n                if (index < keys.length) {\r\n                    const key = keys[index++]\r\n                    return {\r\n                        value: [key, headers[key]],\r\n                        done: false,\r\n                    }\r\n                }\r\n                return {\r\n                    value: undefined,\r\n                    done: true,\r\n                }\r\n            },\r\n        }\r\n    }\r\n    get credentials() {\r\n        return this.#creds || null\r\n    }\r\n    setCredentials(username, password) {\r\n        assertArgument(\r\n            !username.match(/:/),\r\n            \"invalid basic authentication username\",\r\n            \"username\",\r\n            \"[REDACTED]\",\r\n        )\r\n        this.#creds = `${username}:${password}`\r\n    }\r\n    get allowGzip() {\r\n        return this.#gzip\r\n    }\r\n    set allowGzip(value) {\r\n        this.#gzip = !!value\r\n    }\r\n    get allowInsecureAuthentication() {\r\n        return !!this.#allowInsecure\r\n    }\r\n    set allowInsecureAuthentication(value) {\r\n        this.#allowInsecure = !!value\r\n    }\r\n    get timeout() {\r\n        return this.#timeout\r\n    }\r\n    set timeout(timeout) {\r\n        assertArgument(\r\n            timeout >= 0,\r\n            \"timeout must be non-zero\",\r\n            \"timeout\",\r\n            timeout,\r\n        )\r\n        this.#timeout = timeout\r\n    }\r\n    get preflightFunc() {\r\n        return this.#preflight || null\r\n    }\r\n    set preflightFunc(preflight) {\r\n        this.#preflight = preflight\r\n    }\r\n    get processFunc() {\r\n        return this.#process || null\r\n    }\r\n    set processFunc(process) {\r\n        this.#process = process\r\n    }\r\n    get retryFunc() {\r\n        return this.#retry || null\r\n    }\r\n    set retryFunc(retry) {\r\n        this.#retry = retry\r\n    }\r\n    get getUrlFunc() {\r\n        return this.#getUrlFunc || defaultGetUrlFunc\r\n    }\r\n    set getUrlFunc(value) {\r\n        this.#getUrlFunc = value\r\n    }\r\n    constructor(url) {\r\n        this.#url = String(url)\r\n        this.#allowInsecure = false\r\n        this.#gzip = true\r\n        this.#headers = {}\r\n        this.#method = \"\"\r\n        this.#timeout = 3e5\r\n        this.#throttle = {\r\n            slotInterval: SLOT_INTERVAL,\r\n            maxAttempts: MAX_ATTEMPTS,\r\n        }\r\n        this.#getUrlFunc = null\r\n    }\r\n    toString() {\r\n        return `<FetchRequest method=${JSON.stringify(\r\n            this.method,\r\n        )} url=${JSON.stringify(this.url)} headers=${JSON.stringify(\r\n            this.headers,\r\n        )} body=${this.#body ? hexlify(this.#body) : \"null\"}>`\r\n    }\r\n    setThrottleParams(params) {\r\n        if (params.slotInterval != null) {\r\n            this.#throttle.slotInterval = params.slotInterval\r\n        }\r\n        if (params.maxAttempts != null) {\r\n            this.#throttle.maxAttempts = params.maxAttempts\r\n        }\r\n    }\r\n    async #send(attempt, expires, delay, _request, _response) {\r\n        if (attempt >= this.#throttle.maxAttempts) {\r\n            return _response.makeServerError(\"exceeded maximum retry limit\")\r\n        }\r\n        assert(getTime$2() <= expires, \"timeout\", \"TIMEOUT\", {\r\n            operation: \"request.send\",\r\n            reason: \"timeout\",\r\n            request: _request,\r\n        })\r\n        if (delay > 0) {\r\n            await wait(delay)\r\n        }\r\n        let req = this.clone()\r\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase()\r\n        if (scheme in Gateways) {\r\n            const result = await Gateways[scheme](\r\n                req.url,\r\n                checkSignal(_request.#signal),\r\n            )\r\n            if (result instanceof FetchResponse) {\r\n                let response = result\r\n                if (this.processFunc) {\r\n                    checkSignal(_request.#signal)\r\n                    try {\r\n                        response = await this.processFunc(req, response)\r\n                    } catch (error) {\r\n                        if (\r\n                            error.throttle == null ||\r\n                            typeof error.stall !== \"number\"\r\n                        ) {\r\n                            response\r\n                                .makeServerError(\r\n                                    \"error in post-processing function\",\r\n                                    error,\r\n                                )\r\n                                .assertOk()\r\n                        }\r\n                    }\r\n                }\r\n                return response\r\n            }\r\n            req = result\r\n        }\r\n        if (this.preflightFunc) {\r\n            req = await this.preflightFunc(req)\r\n        }\r\n        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal))\r\n        let response = new FetchResponse(\r\n            resp.statusCode,\r\n            resp.statusMessage,\r\n            resp.headers,\r\n            resp.body,\r\n            _request,\r\n        )\r\n        if (response.statusCode === 301 || response.statusCode === 302) {\r\n            try {\r\n                const location = response.headers.location || \"\"\r\n                return req\r\n                    .redirect(location)\r\n                    .#send(attempt + 1, expires, 0, _request, response)\r\n            } catch (error) {}\r\n            return response\r\n        } else if (response.statusCode === 429) {\r\n            if (\r\n                this.retryFunc == null ||\r\n                (await this.retryFunc(req, response, attempt))\r\n            ) {\r\n                const retryAfter = response.headers[\"retry-after\"]\r\n                let delay =\r\n                    this.#throttle.slotInterval *\r\n                    Math.trunc(Math.random() * Math.pow(2, attempt))\r\n                if (\r\n                    typeof retryAfter === \"string\" &&\r\n                    retryAfter.match(/^[1-9][0-9]*$/)\r\n                ) {\r\n                    delay = parseInt(retryAfter)\r\n                }\r\n                return req\r\n                    .clone()\r\n                    .#send(attempt + 1, expires, delay, _request, response)\r\n            }\r\n        }\r\n        if (this.processFunc) {\r\n            checkSignal(_request.#signal)\r\n            try {\r\n                response = await this.processFunc(req, response)\r\n            } catch (error) {\r\n                if (error.throttle == null || typeof error.stall !== \"number\") {\r\n                    response\r\n                        .makeServerError(\r\n                            \"error in post-processing function\",\r\n                            error,\r\n                        )\r\n                        .assertOk()\r\n                }\r\n                let delay =\r\n                    this.#throttle.slotInterval *\r\n                    Math.trunc(Math.random() * Math.pow(2, attempt))\r\n                if (error.stall >= 0) {\r\n                    delay = error.stall\r\n                }\r\n                return req\r\n                    .clone()\r\n                    .#send(attempt + 1, expires, delay, _request, response)\r\n            }\r\n        }\r\n        return response\r\n    }\r\n    send() {\r\n        assert(\r\n            this.#signal == null,\r\n            \"request already sent\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"fetchRequest.send\",\r\n            },\r\n        )\r\n        this.#signal = new FetchCancelSignal(this)\r\n        return this.#send(\r\n            0,\r\n            getTime$2() + this.timeout,\r\n            0,\r\n            this,\r\n            new FetchResponse(0, \"\", {}, null, this),\r\n        )\r\n    }\r\n    cancel() {\r\n        assert(\r\n            this.#signal != null,\r\n            \"request has not been sent\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"fetchRequest.cancel\",\r\n            },\r\n        )\r\n        const signal = fetchSignals.get(this)\r\n        if (!signal) {\r\n            throw new Error(\"missing signal; should not happen\")\r\n        }\r\n        signal()\r\n    }\r\n    redirect(location) {\r\n        const current = this.url.split(\":\")[0].toLowerCase()\r\n        const target = location.split(\":\")[0].toLowerCase()\r\n        assert(\r\n            this.method === \"GET\" &&\r\n                (current !== \"https\" || target !== \"http\") &&\r\n                location.match(/^https?:/),\r\n            `unsupported redirect`,\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: `redirect(${this.method} ${JSON.stringify(\r\n                    this.url,\r\n                )} => ${JSON.stringify(location)})`,\r\n            },\r\n        )\r\n        const req = new FetchRequest(location)\r\n        req.method = \"GET\"\r\n        req.allowGzip = this.allowGzip\r\n        req.timeout = this.timeout\r\n        req.#headers = Object.assign({}, this.#headers)\r\n        if (this.#body) {\r\n            req.#body = new Uint8Array(this.#body)\r\n        }\r\n        req.#bodyType = this.#bodyType\r\n        return req\r\n    }\r\n    clone() {\r\n        const clone = new FetchRequest(this.url)\r\n        clone.#method = this.#method\r\n        if (this.#body) {\r\n            clone.#body = this.#body\r\n        }\r\n        clone.#bodyType = this.#bodyType\r\n        clone.#headers = Object.assign({}, this.#headers)\r\n        clone.#creds = this.#creds\r\n        if (this.allowGzip) {\r\n            clone.allowGzip = true\r\n        }\r\n        clone.timeout = this.timeout\r\n        if (this.allowInsecureAuthentication) {\r\n            clone.allowInsecureAuthentication = true\r\n        }\r\n        clone.#preflight = this.#preflight\r\n        clone.#process = this.#process\r\n        clone.#retry = this.#retry\r\n        clone.#getUrlFunc = this.#getUrlFunc\r\n        return clone\r\n    }\r\n    static lockConfig() {\r\n        locked$5 = true\r\n    }\r\n    static getGateway(scheme) {\r\n        return Gateways[scheme.toLowerCase()] || null\r\n    }\r\n    static registerGateway(scheme, func) {\r\n        scheme = scheme.toLowerCase()\r\n        if (scheme === \"http\" || scheme === \"https\") {\r\n            throw new Error(`cannot intercept ${scheme}; use registerGetUrl`)\r\n        }\r\n        if (locked$5) {\r\n            throw new Error(\"gateways locked\")\r\n        }\r\n        Gateways[scheme] = func\r\n    }\r\n    static registerGetUrl(getUrl) {\r\n        if (locked$5) {\r\n            throw new Error(\"gateways locked\")\r\n        }\r\n        defaultGetUrlFunc = getUrl\r\n    }\r\n    static createGetUrlFunc(options) {\r\n        return createGetUrl()\r\n    }\r\n    static createDataGateway() {\r\n        return dataGatewayFunc\r\n    }\r\n    static createIpfsGatewayFunc(baseUrl) {\r\n        return getIpfsGatewayFunc(baseUrl)\r\n    }\r\n}\r\nclass FetchResponse {\r\n    #statusCode\r\n    #statusMessage\r\n    #headers\r\n    #body\r\n    #request\r\n    #error\r\n    toString() {\r\n        return `<FetchResponse status=${this.statusCode} body=${\r\n            this.#body ? hexlify(this.#body) : \"null\"\r\n        }>`\r\n    }\r\n    get statusCode() {\r\n        return this.#statusCode\r\n    }\r\n    get statusMessage() {\r\n        return this.#statusMessage\r\n    }\r\n    get headers() {\r\n        return Object.assign({}, this.#headers)\r\n    }\r\n    get body() {\r\n        return this.#body == null ? null : new Uint8Array(this.#body)\r\n    }\r\n    get bodyText() {\r\n        try {\r\n            return this.#body == null ? \"\" : toUtf8String(this.#body)\r\n        } catch (error) {\r\n            assert(\r\n                false,\r\n                \"response body is not valid UTF-8 data\",\r\n                \"UNSUPPORTED_OPERATION\",\r\n                {\r\n                    operation: \"bodyText\",\r\n                    info: {\r\n                        response: this,\r\n                    },\r\n                },\r\n            )\r\n        }\r\n    }\r\n    get bodyJson() {\r\n        try {\r\n            return JSON.parse(this.bodyText)\r\n        } catch (error) {\r\n            assert(\r\n                false,\r\n                \"response body is not valid JSON\",\r\n                \"UNSUPPORTED_OPERATION\",\r\n                {\r\n                    operation: \"bodyJson\",\r\n                    info: {\r\n                        response: this,\r\n                    },\r\n                },\r\n            )\r\n        }\r\n    }\r\n    [Symbol.iterator]() {\r\n        const headers = this.headers\r\n        const keys = Object.keys(headers)\r\n        let index = 0\r\n        return {\r\n            next: () => {\r\n                if (index < keys.length) {\r\n                    const key = keys[index++]\r\n                    return {\r\n                        value: [key, headers[key]],\r\n                        done: false,\r\n                    }\r\n                }\r\n                return {\r\n                    value: undefined,\r\n                    done: true,\r\n                }\r\n            },\r\n        }\r\n    }\r\n    constructor(statusCode, statusMessage, headers, body, request) {\r\n        this.#statusCode = statusCode\r\n        this.#statusMessage = statusMessage\r\n        this.#headers = Object.keys(headers).reduce((accum, k) => {\r\n            accum[k.toLowerCase()] = String(headers[k])\r\n            return accum\r\n        }, {})\r\n        this.#body = body == null ? null : new Uint8Array(body)\r\n        this.#request = request || null\r\n        this.#error = {\r\n            message: \"\",\r\n        }\r\n    }\r\n    makeServerError(message, error) {\r\n        let statusMessage\r\n        if (!message) {\r\n            message = `${this.statusCode} ${this.statusMessage}`\r\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`\r\n        } else {\r\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`\r\n        }\r\n        const response = new FetchResponse(\r\n            599,\r\n            statusMessage,\r\n            this.headers,\r\n            this.body,\r\n            this.#request || undefined,\r\n        )\r\n        response.#error = {\r\n            message: message,\r\n            error: error,\r\n        }\r\n        return response\r\n    }\r\n    throwThrottleError(message, stall) {\r\n        if (stall == null) {\r\n            stall = -1\r\n        } else {\r\n            assertArgument(\r\n                Number.isInteger(stall) && stall >= 0,\r\n                \"invalid stall timeout\",\r\n                \"stall\",\r\n                stall,\r\n            )\r\n        }\r\n        const error = new Error(message || \"throttling requests\")\r\n        defineProperties(error, {\r\n            stall: stall,\r\n            throttle: true,\r\n        })\r\n        throw error\r\n    }\r\n    getHeader(key) {\r\n        return this.headers[key.toLowerCase()]\r\n    }\r\n    hasBody() {\r\n        return this.#body != null\r\n    }\r\n    get request() {\r\n        return this.#request\r\n    }\r\n    ok() {\r\n        return (\r\n            this.#error.message === \"\" &&\r\n            this.statusCode >= 200 &&\r\n            this.statusCode < 300\r\n        )\r\n    }\r\n    assertOk() {\r\n        if (this.ok()) {\r\n            return\r\n        }\r\n        let { message, error } = this.#error\r\n        if (message === \"\") {\r\n            message = `server response ${this.statusCode} ${this.statusMessage}`\r\n        }\r\n        assert(false, message, \"SERVER_ERROR\", {\r\n            request: this.request || \"unknown request\",\r\n            response: this,\r\n            error: error,\r\n        })\r\n    }\r\n}\r\nfunction getTime$2() {\r\n    return new Date().getTime()\r\n}\r\nfunction unpercent(value) {\r\n    return toUtf8Bytes(\r\n        value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\r\n            return String.fromCharCode(parseInt(code, 16))\r\n        }),\r\n    )\r\n}\r\nfunction wait(delay) {\r\n    return new Promise((resolve) => setTimeout(resolve, delay))\r\n}\r\nconst BN_N1 = BigInt(-1)\r\nconst BN_0$8 = BigInt(0)\r\nconst BN_1$4 = BigInt(1)\r\nconst BN_5 = BigInt(5)\r\nconst _guard$5 = {}\r\nlet Zeros$1 = \"0000\"\r\nwhile (Zeros$1.length < 80) {\r\n    Zeros$1 += Zeros$1\r\n}\r\nfunction getTens(decimals) {\r\n    let result = Zeros$1\r\n    while (result.length < decimals) {\r\n        result += result\r\n    }\r\n    return BigInt(\"1\" + result.substring(0, decimals))\r\n}\r\nfunction checkValue(val, format, safeOp) {\r\n    const width = BigInt(format.width)\r\n    if (format.signed) {\r\n        const limit = BN_1$4 << (width - BN_1$4)\r\n        assert(\r\n            safeOp == null || (val >= -limit && val < limit),\r\n            \"overflow\",\r\n            \"NUMERIC_FAULT\",\r\n            {\r\n                operation: safeOp,\r\n                fault: \"overflow\",\r\n                value: val,\r\n            },\r\n        )\r\n        if (val > BN_0$8) {\r\n            val = fromTwos(mask(val, width), width)\r\n        } else {\r\n            val = -fromTwos(mask(-val, width), width)\r\n        }\r\n    } else {\r\n        const limit = BN_1$4 << width\r\n        assert(\r\n            safeOp == null || (val >= 0 && val < limit),\r\n            \"overflow\",\r\n            \"NUMERIC_FAULT\",\r\n            {\r\n                operation: safeOp,\r\n                fault: \"overflow\",\r\n                value: val,\r\n            },\r\n        )\r\n        val = ((val % limit) + limit) % limit & (limit - BN_1$4)\r\n    }\r\n    return val\r\n}\r\nfunction getFormat(value) {\r\n    if (typeof value === \"number\") {\r\n        value = `fixed128x${value}`\r\n    }\r\n    let signed = true\r\n    let width = 128\r\n    let decimals = 18\r\n    if (typeof value === \"string\") {\r\n        if (value === \"fixed\");\r\n        else if (value === \"ufixed\") {\r\n            signed = false\r\n        } else {\r\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/)\r\n            assertArgument(match, \"invalid fixed format\", \"format\", value)\r\n            signed = match[1] !== \"u\"\r\n            width = parseInt(match[2])\r\n            decimals = parseInt(match[3])\r\n        }\r\n    } else if (value) {\r\n        const v = value\r\n        const check = (key, type, defaultValue) => {\r\n            if (v[key] == null) {\r\n                return defaultValue\r\n            }\r\n            assertArgument(\r\n                typeof v[key] === type,\r\n                \"invalid fixed format (\" + key + \" not \" + type + \")\",\r\n                \"format.\" + key,\r\n                v[key],\r\n            )\r\n            return v[key]\r\n        }\r\n        signed = check(\"signed\", \"boolean\", signed)\r\n        width = check(\"width\", \"number\", width)\r\n        decimals = check(\"decimals\", \"number\", decimals)\r\n    }\r\n    assertArgument(\r\n        width % 8 === 0,\r\n        \"invalid FixedNumber width (not byte aligned)\",\r\n        \"format.width\",\r\n        width,\r\n    )\r\n    assertArgument(\r\n        decimals <= 80,\r\n        \"invalid FixedNumber decimals (too large)\",\r\n        \"format.decimals\",\r\n        decimals,\r\n    )\r\n    const name =\r\n        (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals)\r\n    return {\r\n        signed: signed,\r\n        width: width,\r\n        decimals: decimals,\r\n        name: name,\r\n    }\r\n}\r\nfunction toString(val, decimals) {\r\n    let negative = \"\"\r\n    if (val < BN_0$8) {\r\n        negative = \"-\"\r\n        val *= BN_N1\r\n    }\r\n    let str = val.toString()\r\n    if (decimals === 0) {\r\n        return negative + str\r\n    }\r\n    while (str.length <= decimals) {\r\n        str = Zeros$1 + str\r\n    }\r\n    const index = str.length - decimals\r\n    str = str.substring(0, index) + \".\" + str.substring(index)\r\n    while (str[0] === \"0\" && str[1] !== \".\") {\r\n        str = str.substring(1)\r\n    }\r\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\r\n        str = str.substring(0, str.length - 1)\r\n    }\r\n    return negative + str\r\n}\r\nclass FixedNumber {\r\n    format\r\n    #format\r\n    #val\r\n    #tens\r\n    _value\r\n    constructor(guard, value, format) {\r\n        assertPrivate(guard, _guard$5, \"FixedNumber\")\r\n        this.#val = value\r\n        this.#format = format\r\n        const _value = toString(value, format.decimals)\r\n        defineProperties(this, {\r\n            format: format.name,\r\n            _value: _value,\r\n        })\r\n        this.#tens = getTens(format.decimals)\r\n    }\r\n    get signed() {\r\n        return this.#format.signed\r\n    }\r\n    get width() {\r\n        return this.#format.width\r\n    }\r\n    get decimals() {\r\n        return this.#format.decimals\r\n    }\r\n    get value() {\r\n        return this.#val\r\n    }\r\n    #checkFormat(other) {\r\n        assertArgument(\r\n            this.format === other.format,\r\n            \"incompatible format; use fixedNumber.toFormat\",\r\n            \"other\",\r\n            other,\r\n        )\r\n    }\r\n    #checkValue(val, safeOp) {\r\n        val = checkValue(val, this.#format, safeOp)\r\n        return new FixedNumber(_guard$5, val, this.#format)\r\n    }\r\n    #add(o, safeOp) {\r\n        this.#checkFormat(o)\r\n        return this.#checkValue(this.#val + o.#val, safeOp)\r\n    }\r\n    addUnsafe(other) {\r\n        return this.#add(other)\r\n    }\r\n    add(other) {\r\n        return this.#add(other, \"add\")\r\n    }\r\n    #sub(o, safeOp) {\r\n        this.#checkFormat(o)\r\n        return this.#checkValue(this.#val - o.#val, safeOp)\r\n    }\r\n    subUnsafe(other) {\r\n        return this.#sub(other)\r\n    }\r\n    sub(other) {\r\n        return this.#sub(other, \"sub\")\r\n    }\r\n    #mul(o, safeOp) {\r\n        this.#checkFormat(o)\r\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp)\r\n    }\r\n    mulUnsafe(other) {\r\n        return this.#mul(other)\r\n    }\r\n    mul(other) {\r\n        return this.#mul(other, \"mul\")\r\n    }\r\n    mulSignal(other) {\r\n        this.#checkFormat(other)\r\n        const value = this.#val * other.#val\r\n        assert(\r\n            value % this.#tens === BN_0$8,\r\n            \"precision lost during signalling mul\",\r\n            \"NUMERIC_FAULT\",\r\n            {\r\n                operation: \"mulSignal\",\r\n                fault: \"underflow\",\r\n                value: this,\r\n            },\r\n        )\r\n        return this.#checkValue(value / this.#tens, \"mulSignal\")\r\n    }\r\n    #div(o, safeOp) {\r\n        assert(o.#val !== BN_0$8, \"division by zero\", \"NUMERIC_FAULT\", {\r\n            operation: \"div\",\r\n            fault: \"divide-by-zero\",\r\n            value: this,\r\n        })\r\n        this.#checkFormat(o)\r\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp)\r\n    }\r\n    divUnsafe(other) {\r\n        return this.#div(other)\r\n    }\r\n    div(other) {\r\n        return this.#div(other, \"div\")\r\n    }\r\n    divSignal(other) {\r\n        assert(other.#val !== BN_0$8, \"division by zero\", \"NUMERIC_FAULT\", {\r\n            operation: \"div\",\r\n            fault: \"divide-by-zero\",\r\n            value: this,\r\n        })\r\n        this.#checkFormat(other)\r\n        const value = this.#val * this.#tens\r\n        assert(\r\n            value % other.#val === BN_0$8,\r\n            \"precision lost during signalling div\",\r\n            \"NUMERIC_FAULT\",\r\n            {\r\n                operation: \"divSignal\",\r\n                fault: \"underflow\",\r\n                value: this,\r\n            },\r\n        )\r\n        return this.#checkValue(value / other.#val, \"divSignal\")\r\n    }\r\n    cmp(other) {\r\n        let a = this.value,\r\n            b = other.value\r\n        const delta = this.decimals - other.decimals\r\n        if (delta > 0) {\r\n            b *= getTens(delta)\r\n        } else if (delta < 0) {\r\n            a *= getTens(-delta)\r\n        }\r\n        if (a < b) {\r\n            return -1\r\n        }\r\n        if (a > b) {\r\n            return 1\r\n        }\r\n        return 0\r\n    }\r\n    eq(other) {\r\n        return this.cmp(other) === 0\r\n    }\r\n    lt(other) {\r\n        return this.cmp(other) < 0\r\n    }\r\n    lte(other) {\r\n        return this.cmp(other) <= 0\r\n    }\r\n    gt(other) {\r\n        return this.cmp(other) > 0\r\n    }\r\n    gte(other) {\r\n        return this.cmp(other) >= 0\r\n    }\r\n    floor() {\r\n        let val = this.#val\r\n        if (this.#val < BN_0$8) {\r\n            val -= this.#tens - BN_1$4\r\n        }\r\n        val = (this.#val / this.#tens) * this.#tens\r\n        return this.#checkValue(val, \"floor\")\r\n    }\r\n    ceiling() {\r\n        let val = this.#val\r\n        if (this.#val > BN_0$8) {\r\n            val += this.#tens - BN_1$4\r\n        }\r\n        val = (this.#val / this.#tens) * this.#tens\r\n        return this.#checkValue(val, \"ceiling\")\r\n    }\r\n    round(decimals) {\r\n        if (decimals == null) {\r\n            decimals = 0\r\n        }\r\n        if (decimals >= this.decimals) {\r\n            return this\r\n        }\r\n        const delta = this.decimals - decimals\r\n        const bump = BN_5 * getTens(delta - 1)\r\n        let value = this.value + bump\r\n        const tens = getTens(delta)\r\n        value = (value / tens) * tens\r\n        checkValue(value, this.#format, \"round\")\r\n        return new FixedNumber(_guard$5, value, this.#format)\r\n    }\r\n    isZero() {\r\n        return this.#val === BN_0$8\r\n    }\r\n    isNegative() {\r\n        return this.#val < BN_0$8\r\n    }\r\n    toString() {\r\n        return this._value\r\n    }\r\n    toUnsafeFloat() {\r\n        return parseFloat(this.toString())\r\n    }\r\n    toFormat(format) {\r\n        return FixedNumber.fromString(this.toString(), format)\r\n    }\r\n    static fromValue(_value, _decimals, _format) {\r\n        const decimals = _decimals == null ? 0 : getNumber(_decimals)\r\n        const format = getFormat(_format)\r\n        let value = getBigInt(_value, \"value\")\r\n        const delta = decimals - format.decimals\r\n        if (delta > 0) {\r\n            const tens = getTens(delta)\r\n            assert(\r\n                value % tens === BN_0$8,\r\n                \"value loses precision for format\",\r\n                \"NUMERIC_FAULT\",\r\n                {\r\n                    operation: \"fromValue\",\r\n                    fault: \"underflow\",\r\n                    value: _value,\r\n                },\r\n            )\r\n            value /= tens\r\n        } else if (delta < 0) {\r\n            value *= getTens(-delta)\r\n        }\r\n        checkValue(value, format, \"fromValue\")\r\n        return new FixedNumber(_guard$5, value, format)\r\n    }\r\n    static fromString(_value, _format) {\r\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/)\r\n        assertArgument(\r\n            match && match[2].length + match[3].length > 0,\r\n            \"invalid FixedNumber string value\",\r\n            \"value\",\r\n            _value,\r\n        )\r\n        const format = getFormat(_format)\r\n        let whole = match[2] || \"0\",\r\n            decimal = match[3] || \"\"\r\n        while (decimal.length < format.decimals) {\r\n            decimal += Zeros$1\r\n        }\r\n        assert(\r\n            decimal.substring(format.decimals).match(/^0*$/),\r\n            \"too many decimals for format\",\r\n            \"NUMERIC_FAULT\",\r\n            {\r\n                operation: \"fromString\",\r\n                fault: \"underflow\",\r\n                value: _value,\r\n            },\r\n        )\r\n        decimal = decimal.substring(0, format.decimals)\r\n        const value = BigInt(match[1] + whole + decimal)\r\n        checkValue(value, format, \"fromString\")\r\n        return new FixedNumber(_guard$5, value, format)\r\n    }\r\n    static fromBytes(_value, _format) {\r\n        let value = toBigInt(getBytes(_value, \"value\"))\r\n        const format = getFormat(_format)\r\n        if (format.signed) {\r\n            value = fromTwos(value, format.width)\r\n        }\r\n        checkValue(value, format, \"fromBytes\")\r\n        return new FixedNumber(_guard$5, value, format)\r\n    }\r\n}\r\nfunction hexlifyByte(value) {\r\n    let result = value.toString(16)\r\n    while (result.length < 2) {\r\n        result = \"0\" + result\r\n    }\r\n    return \"0x\" + result\r\n}\r\nfunction unarrayifyInteger(data, offset, length) {\r\n    let result = 0\r\n    for (let i = 0; i < length; i++) {\r\n        result = result * 256 + data[offset + i]\r\n    }\r\n    return result\r\n}\r\nfunction _decodeChildren(data, offset, childOffset, length) {\r\n    const result = []\r\n    while (childOffset < offset + 1 + length) {\r\n        const decoded = _decode(data, childOffset)\r\n        result.push(decoded.result)\r\n        childOffset += decoded.consumed\r\n        assert(\r\n            childOffset <= offset + 1 + length,\r\n            \"child data too short\",\r\n            \"BUFFER_OVERRUN\",\r\n            {\r\n                buffer: data,\r\n                length: length,\r\n                offset: offset,\r\n            },\r\n        )\r\n    }\r\n    return {\r\n        consumed: 1 + length,\r\n        result: result,\r\n    }\r\n}\r\nfunction _decode(data, offset) {\r\n    assert(data.length !== 0, \"data too short\", \"BUFFER_OVERRUN\", {\r\n        buffer: data,\r\n        length: 0,\r\n        offset: 1,\r\n    })\r\n    const checkOffset = (offset) => {\r\n        assert(\r\n            offset <= data.length,\r\n            \"data short segment too short\",\r\n            \"BUFFER_OVERRUN\",\r\n            {\r\n                buffer: data,\r\n                length: data.length,\r\n                offset: offset,\r\n            },\r\n        )\r\n    }\r\n    if (data[offset] >= 248) {\r\n        const lengthLength = data[offset] - 247\r\n        checkOffset(offset + 1 + lengthLength)\r\n        const length = unarrayifyInteger(data, offset + 1, lengthLength)\r\n        checkOffset(offset + 1 + lengthLength + length)\r\n        return _decodeChildren(\r\n            data,\r\n            offset,\r\n            offset + 1 + lengthLength,\r\n            lengthLength + length,\r\n        )\r\n    } else if (data[offset] >= 192) {\r\n        const length = data[offset] - 192\r\n        checkOffset(offset + 1 + length)\r\n        return _decodeChildren(data, offset, offset + 1, length)\r\n    } else if (data[offset] >= 184) {\r\n        const lengthLength = data[offset] - 183\r\n        checkOffset(offset + 1 + lengthLength)\r\n        const length = unarrayifyInteger(data, offset + 1, lengthLength)\r\n        checkOffset(offset + 1 + lengthLength + length)\r\n        const result = hexlify(\r\n            data.slice(\r\n                offset + 1 + lengthLength,\r\n                offset + 1 + lengthLength + length,\r\n            ),\r\n        )\r\n        return {\r\n            consumed: 1 + lengthLength + length,\r\n            result: result,\r\n        }\r\n    } else if (data[offset] >= 128) {\r\n        const length = data[offset] - 128\r\n        checkOffset(offset + 1 + length)\r\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length))\r\n        return {\r\n            consumed: 1 + length,\r\n            result: result,\r\n        }\r\n    }\r\n    return {\r\n        consumed: 1,\r\n        result: hexlifyByte(data[offset]),\r\n    }\r\n}\r\nfunction decodeRlp(_data) {\r\n    const data = getBytes(_data, \"data\")\r\n    const decoded = _decode(data, 0)\r\n    assertArgument(\r\n        decoded.consumed === data.length,\r\n        \"unexpected junk after rlp payload\",\r\n        \"data\",\r\n        _data,\r\n    )\r\n    return decoded.result\r\n}\r\nfunction arrayifyInteger(value) {\r\n    const result = []\r\n    while (value) {\r\n        result.unshift(value & 255)\r\n        value >>= 8\r\n    }\r\n    return result\r\n}\r\nfunction _encode(object) {\r\n    if (Array.isArray(object)) {\r\n        let payload = []\r\n        object.forEach(function (child) {\r\n            payload = payload.concat(_encode(child))\r\n        })\r\n        if (payload.length <= 55) {\r\n            payload.unshift(192 + payload.length)\r\n            return payload\r\n        }\r\n        const length = arrayifyInteger(payload.length)\r\n        length.unshift(247 + length.length)\r\n        return length.concat(payload)\r\n    }\r\n    const data = Array.prototype.slice.call(getBytes(object, \"object\"))\r\n    if (data.length === 1 && data[0] <= 127) {\r\n        return data\r\n    } else if (data.length <= 55) {\r\n        data.unshift(128 + data.length)\r\n        return data\r\n    }\r\n    const length = arrayifyInteger(data.length)\r\n    length.unshift(183 + length.length)\r\n    return length.concat(data)\r\n}\r\nconst nibbles = \"0123456789abcdef\"\r\nfunction encodeRlp(object) {\r\n    let result = \"0x\"\r\n    for (const v of _encode(object)) {\r\n        result += nibbles[v >> 4]\r\n        result += nibbles[v & 15]\r\n    }\r\n    return result\r\n}\r\nconst names = [\"wei\", \"kwei\", \"mwei\", \"gwei\", \"szabo\", \"finney\", \"ether\"]\r\nfunction formatUnits(value, unit) {\r\n    let decimals = 18\r\n    if (typeof unit === \"string\") {\r\n        const index = names.indexOf(unit)\r\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit)\r\n        decimals = 3 * index\r\n    } else if (unit != null) {\r\n        decimals = getNumber(unit, \"unit\")\r\n    }\r\n    return FixedNumber.fromValue(value, decimals, {\r\n        decimals: decimals,\r\n        width: 512,\r\n    }).toString()\r\n}\r\nfunction parseUnits$1(value, unit) {\r\n    assertArgument(\r\n        typeof value === \"string\",\r\n        \"value must be a string\",\r\n        \"value\",\r\n        value,\r\n    )\r\n    let decimals = 18\r\n    if (typeof unit === \"string\") {\r\n        const index = names.indexOf(unit)\r\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit)\r\n        decimals = 3 * index\r\n    } else if (unit != null) {\r\n        decimals = getNumber(unit, \"unit\")\r\n    }\r\n    return FixedNumber.fromString(value, {\r\n        decimals: decimals,\r\n        width: 512,\r\n    }).value\r\n}\r\nfunction formatEther(wei) {\r\n    return formatUnits(wei, 18)\r\n}\r\nfunction parseEther(ether) {\r\n    return parseUnits$1(ether, 18)\r\n}\r\nfunction uuidV4(randomBytes) {\r\n    const bytes = getBytes(randomBytes, \"randomBytes\")\r\n    bytes[6] = (bytes[6] & 15) | 64\r\n    bytes[8] = (bytes[8] & 63) | 128\r\n    const value = hexlify(bytes)\r\n    return [\r\n        value.substring(2, 10),\r\n        value.substring(10, 14),\r\n        value.substring(14, 18),\r\n        value.substring(18, 22),\r\n        value.substring(22, 34),\r\n    ].join(\"-\")\r\n}\r\nconst WordSize = 32\r\nconst Padding = new Uint8Array(WordSize)\r\nconst passProperties$1 = [\"then\"]\r\nconst _guard$4 = {}\r\nfunction throwError(name, error) {\r\n    const wrapped = new Error(\r\n        `deferred error during ABI decoding triggered accessing ${name}`,\r\n    )\r\n    wrapped.error = error\r\n    throw wrapped\r\n}\r\nclass Result extends Array {\r\n    #names\r\n    constructor(...args) {\r\n        const guard = args[0]\r\n        let items = args[1]\r\n        let names = (args[2] || []).slice()\r\n        let wrap = true\r\n        if (guard !== _guard$4) {\r\n            items = args\r\n            names = []\r\n            wrap = false\r\n        }\r\n        super(items.length)\r\n        items.forEach((item, index) => {\r\n            this[index] = item\r\n        })\r\n        const nameCounts = names.reduce((accum, name) => {\r\n            if (typeof name === \"string\") {\r\n                accum.set(name, (accum.get(name) || 0) + 1)\r\n            }\r\n            return accum\r\n        }, new Map())\r\n        this.#names = Object.freeze(\r\n            items.map((item, index) => {\r\n                const name = names[index]\r\n                if (name != null && nameCounts.get(name) === 1) {\r\n                    return name\r\n                }\r\n                return null\r\n            }),\r\n        )\r\n        if (!wrap) {\r\n            return\r\n        }\r\n        Object.freeze(this)\r\n        return new Proxy(this, {\r\n            get: (target, prop, receiver) => {\r\n                if (typeof prop === \"string\") {\r\n                    if (prop.match(/^[0-9]+$/)) {\r\n                        const index = getNumber(prop, \"%index\")\r\n                        if (index < 0 || index >= this.length) {\r\n                            throw new RangeError(\"out of result range\")\r\n                        }\r\n                        const item = target[index]\r\n                        if (item instanceof Error) {\r\n                            throwError(`index ${index}`, item)\r\n                        }\r\n                        return item\r\n                    }\r\n                    if (passProperties$1.indexOf(prop) >= 0) {\r\n                        return Reflect.get(target, prop, receiver)\r\n                    }\r\n                    const value = target[prop]\r\n                    if (value instanceof Function) {\r\n                        return function (...args) {\r\n                            return value.apply(\r\n                                this === receiver ? target : this,\r\n                                args,\r\n                            )\r\n                        }\r\n                    } else if (!(prop in target)) {\r\n                        return target.getValue.apply(\r\n                            this === receiver ? target : this,\r\n                            [prop],\r\n                        )\r\n                    }\r\n                }\r\n                return Reflect.get(target, prop, receiver)\r\n            },\r\n        })\r\n    }\r\n    toArray() {\r\n        const result = []\r\n        this.forEach((item, index) => {\r\n            if (item instanceof Error) {\r\n                throwError(`index ${index}`, item)\r\n            }\r\n            result.push(item)\r\n        })\r\n        return result\r\n    }\r\n    toObject() {\r\n        return this.#names.reduce((accum, name, index) => {\r\n            assert(\r\n                name != null,\r\n                \"value at index ${ index } unnamed\",\r\n                \"UNSUPPORTED_OPERATION\",\r\n                {\r\n                    operation: \"toObject()\",\r\n                },\r\n            )\r\n            if (!(name in accum)) {\r\n                accum[name] = this.getValue(name)\r\n            }\r\n            return accum\r\n        }, {})\r\n    }\r\n    slice(start, end) {\r\n        if (start == null) {\r\n            start = 0\r\n        }\r\n        if (start < 0) {\r\n            start += this.length\r\n            if (start < 0) {\r\n                start = 0\r\n            }\r\n        }\r\n        if (end == null) {\r\n            end = this.length\r\n        }\r\n        if (end < 0) {\r\n            end += this.length\r\n            if (end < 0) {\r\n                end = 0\r\n            }\r\n        }\r\n        if (end > this.length) {\r\n            end = this.length\r\n        }\r\n        const result = [],\r\n            names = []\r\n        for (let i = start; i < end; i++) {\r\n            result.push(this[i])\r\n            names.push(this.#names[i])\r\n        }\r\n        return new Result(_guard$4, result, names)\r\n    }\r\n    filter(callback, thisArg) {\r\n        const result = [],\r\n            names = []\r\n        for (let i = 0; i < this.length; i++) {\r\n            const item = this[i]\r\n            if (item instanceof Error) {\r\n                throwError(`index ${i}`, item)\r\n            }\r\n            if (callback.call(thisArg, item, i, this)) {\r\n                result.push(item)\r\n                names.push(this.#names[i])\r\n            }\r\n        }\r\n        return new Result(_guard$4, result, names)\r\n    }\r\n    map(callback, thisArg) {\r\n        const result = []\r\n        for (let i = 0; i < this.length; i++) {\r\n            const item = this[i]\r\n            if (item instanceof Error) {\r\n                throwError(`index ${i}`, item)\r\n            }\r\n            result.push(callback.call(thisArg, item, i, this))\r\n        }\r\n        return result\r\n    }\r\n    getValue(name) {\r\n        const index = this.#names.indexOf(name)\r\n        if (index === -1) {\r\n            return undefined\r\n        }\r\n        const value = this[index]\r\n        if (value instanceof Error) {\r\n            throwError(`property ${JSON.stringify(name)}`, value.error)\r\n        }\r\n        return value\r\n    }\r\n    static fromItems(items, keys) {\r\n        return new Result(_guard$4, items, keys)\r\n    }\r\n}\r\nfunction checkResultErrors(result) {\r\n    const errors = []\r\n    const checkErrors = function (path, object) {\r\n        if (!Array.isArray(object)) {\r\n            return\r\n        }\r\n        for (let key in object) {\r\n            const childPath = path.slice()\r\n            childPath.push(key)\r\n            try {\r\n                checkErrors(childPath, object[key])\r\n            } catch (error) {\r\n                errors.push({\r\n                    path: childPath,\r\n                    error: error,\r\n                })\r\n            }\r\n        }\r\n    }\r\n    checkErrors([], result)\r\n    return errors\r\n}\r\nfunction getValue$1(value) {\r\n    let bytes = toBeArray(value)\r\n    assert(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", {\r\n        buffer: bytes,\r\n        length: WordSize,\r\n        offset: bytes.length,\r\n    })\r\n    if (bytes.length !== WordSize) {\r\n        bytes = getBytesCopy(\r\n            concat([Padding.slice(bytes.length % WordSize), bytes]),\r\n        )\r\n    }\r\n    return bytes\r\n}\r\nclass Coder {\r\n    name\r\n    type\r\n    localName\r\n    dynamic\r\n    constructor(name, type, localName, dynamic) {\r\n        defineProperties(\r\n            this,\r\n            {\r\n                name: name,\r\n                type: type,\r\n                localName: localName,\r\n                dynamic: dynamic,\r\n            },\r\n            {\r\n                name: \"string\",\r\n                type: \"string\",\r\n                localName: \"string\",\r\n                dynamic: \"boolean\",\r\n            },\r\n        )\r\n    }\r\n    _throwError(message, value) {\r\n        assertArgument(false, message, this.localName, value)\r\n    }\r\n}\r\nclass Writer {\r\n    #data\r\n    #dataLength\r\n    constructor() {\r\n        this.#data = []\r\n        this.#dataLength = 0\r\n    }\r\n    get data() {\r\n        return concat(this.#data)\r\n    }\r\n    get length() {\r\n        return this.#dataLength\r\n    }\r\n    #writeData(data) {\r\n        this.#data.push(data)\r\n        this.#dataLength += data.length\r\n        return data.length\r\n    }\r\n    appendWriter(writer) {\r\n        return this.#writeData(getBytesCopy(writer.data))\r\n    }\r\n    writeBytes(value) {\r\n        let bytes = getBytesCopy(value)\r\n        const paddingOffset = bytes.length % WordSize\r\n        if (paddingOffset) {\r\n            bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]))\r\n        }\r\n        return this.#writeData(bytes)\r\n    }\r\n    writeValue(value) {\r\n        return this.#writeData(getValue$1(value))\r\n    }\r\n    writeUpdatableValue() {\r\n        const offset = this.#data.length\r\n        this.#data.push(Padding)\r\n        this.#dataLength += WordSize\r\n        return (value) => {\r\n            this.#data[offset] = getValue$1(value)\r\n        }\r\n    }\r\n}\r\nclass Reader {\r\n    allowLoose\r\n    #data\r\n    #offset\r\n    constructor(data, allowLoose) {\r\n        defineProperties(this, {\r\n            allowLoose: !!allowLoose,\r\n        })\r\n        this.#data = getBytesCopy(data)\r\n        this.#offset = 0\r\n    }\r\n    get data() {\r\n        return hexlify(this.#data)\r\n    }\r\n    get dataLength() {\r\n        return this.#data.length\r\n    }\r\n    get consumed() {\r\n        return this.#offset\r\n    }\r\n    get bytes() {\r\n        return new Uint8Array(this.#data)\r\n    }\r\n    #peekBytes(offset, length, loose) {\r\n        let alignedLength = Math.ceil(length / WordSize) * WordSize\r\n        if (this.#offset + alignedLength > this.#data.length) {\r\n            if (\r\n                this.allowLoose &&\r\n                loose &&\r\n                this.#offset + length <= this.#data.length\r\n            ) {\r\n                alignedLength = length\r\n            } else {\r\n                assert(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\r\n                    buffer: getBytesCopy(this.#data),\r\n                    length: this.#data.length,\r\n                    offset: this.#offset + alignedLength,\r\n                })\r\n            }\r\n        }\r\n        return this.#data.slice(this.#offset, this.#offset + alignedLength)\r\n    }\r\n    subReader(offset) {\r\n        return new Reader(\r\n            this.#data.slice(this.#offset + offset),\r\n            this.allowLoose,\r\n        )\r\n    }\r\n    readBytes(length, loose) {\r\n        let bytes = this.#peekBytes(0, length, !!loose)\r\n        this.#offset += bytes.length\r\n        return bytes.slice(0, length)\r\n    }\r\n    readValue() {\r\n        return toBigInt(this.readBytes(WordSize))\r\n    }\r\n    readIndex() {\r\n        return toNumber(this.readBytes(WordSize))\r\n    }\r\n}\r\nfunction number(n) {\r\n    if (!Number.isSafeInteger(n) || n < 0)\r\n        throw new Error(`Wrong positive integer: ${n}`)\r\n}\r\nfunction bytes(b, ...lengths) {\r\n    if (!(b instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\")\r\n    if (lengths.length > 0 && !lengths.includes(b.length))\r\n        throw new Error(\r\n            `Expected Uint8Array of length ${lengths}, not of length=${b.length}`,\r\n        )\r\n}\r\nfunction hash(hash) {\r\n    if (typeof hash !== \"function\" || typeof hash.create !== \"function\")\r\n        throw new Error(\"Hash should be wrapped by utils.wrapConstructor\")\r\n    number(hash.outputLen)\r\n    number(hash.blockLen)\r\n}\r\nfunction exists(instance, checkFinished = true) {\r\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\")\r\n    if (checkFinished && instance.finished)\r\n        throw new Error(\"Hash#digest() has already been called\")\r\n}\r\nfunction output(out, instance) {\r\n    bytes(out)\r\n    const min = instance.outputLen\r\n    if (out.length < min) {\r\n        throw new Error(\r\n            `digestInto() expects output buffer of length at least ${min}`,\r\n        )\r\n    }\r\n}\r\nconst crypto$1 =\r\n    typeof globalThis === \"object\" && \"crypto\" in globalThis\r\n        ? globalThis.crypto\r\n        : undefined\r\nconst u8a$1 = (a) => a instanceof Uint8Array\r\nconst u32 = (arr) =>\r\n    new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4))\r\nconst createView = (arr) =>\r\n    new DataView(arr.buffer, arr.byteOffset, arr.byteLength)\r\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift)\r\nconst isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68\r\nif (!isLE) throw new Error(\"Non little-endian hardware is not supported\")\r\nconst nextTick = async () => {}\r\nasync function asyncLoop(iters, tick, cb) {\r\n    let ts = Date.now()\r\n    for (let i = 0; i < iters; i++) {\r\n        cb(i)\r\n        const diff = Date.now() - ts\r\n        if (diff >= 0 && diff < tick) continue\r\n        await nextTick()\r\n        ts += diff\r\n    }\r\n}\r\nfunction utf8ToBytes$1(str) {\r\n    if (typeof str !== \"string\")\r\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`)\r\n    return new Uint8Array(new TextEncoder().encode(str))\r\n}\r\nfunction toBytes(data) {\r\n    if (typeof data === \"string\") data = utf8ToBytes$1(data)\r\n    if (!u8a$1(data)) throw new Error(`expected Uint8Array, got ${typeof data}`)\r\n    return data\r\n}\r\nfunction concatBytes$1(...arrays) {\r\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0))\r\n    let pad = 0\r\n    arrays.forEach((a) => {\r\n        if (!u8a$1(a)) throw new Error(\"Uint8Array expected\")\r\n        r.set(a, pad)\r\n        pad += a.length\r\n    })\r\n    return r\r\n}\r\nclass Hash {\r\n    clone() {\r\n        return this._cloneInto()\r\n    }\r\n}\r\nconst toStr = {}.toString\r\nfunction checkOpts(defaults, opts) {\r\n    if (opts !== undefined && toStr.call(opts) !== \"[object Object]\")\r\n        throw new Error(\"Options should be object or undefined\")\r\n    const merged = Object.assign(defaults, opts)\r\n    return merged\r\n}\r\nfunction wrapConstructor(hashCons) {\r\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest()\r\n    const tmp = hashCons()\r\n    hashC.outputLen = tmp.outputLen\r\n    hashC.blockLen = tmp.blockLen\r\n    hashC.create = () => hashCons()\r\n    return hashC\r\n}\r\nfunction randomBytes$2(bytesLength = 32) {\r\n    if (crypto$1 && typeof crypto$1.getRandomValues === \"function\") {\r\n        return crypto$1.getRandomValues(new Uint8Array(bytesLength))\r\n    }\r\n    throw new Error(\"crypto.getRandomValues must be defined\")\r\n}\r\nclass HMAC extends Hash {\r\n    constructor(hash$1, _key) {\r\n        super()\r\n        this.finished = false\r\n        this.destroyed = false\r\n        hash(hash$1)\r\n        const key = toBytes(_key)\r\n        this.iHash = hash$1.create()\r\n        if (typeof this.iHash.update !== \"function\")\r\n            throw new Error(\r\n                \"Expected instance of class which extends utils.Hash\",\r\n            )\r\n        this.blockLen = this.iHash.blockLen\r\n        this.outputLen = this.iHash.outputLen\r\n        const blockLen = this.blockLen\r\n        const pad = new Uint8Array(blockLen)\r\n        pad.set(\r\n            key.length > blockLen ? hash$1.create().update(key).digest() : key,\r\n        )\r\n        for (let i = 0; i < pad.length; i++) pad[i] ^= 54\r\n        this.iHash.update(pad)\r\n        this.oHash = hash$1.create()\r\n        for (let i = 0; i < pad.length; i++) pad[i] ^= 54 ^ 92\r\n        this.oHash.update(pad)\r\n        pad.fill(0)\r\n    }\r\n    update(buf) {\r\n        exists(this)\r\n        this.iHash.update(buf)\r\n        return this\r\n    }\r\n    digestInto(out) {\r\n        exists(this)\r\n        bytes(out, this.outputLen)\r\n        this.finished = true\r\n        this.iHash.digestInto(out)\r\n        this.oHash.update(out)\r\n        this.oHash.digestInto(out)\r\n        this.destroy()\r\n    }\r\n    digest() {\r\n        const out = new Uint8Array(this.oHash.outputLen)\r\n        this.digestInto(out)\r\n        return out\r\n    }\r\n    _cloneInto(to) {\r\n        to || (to = Object.create(Object.getPrototypeOf(this), {}))\r\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this\r\n        to = to\r\n        to.finished = finished\r\n        to.destroyed = destroyed\r\n        to.blockLen = blockLen\r\n        to.outputLen = outputLen\r\n        to.oHash = oHash._cloneInto(to.oHash)\r\n        to.iHash = iHash._cloneInto(to.iHash)\r\n        return to\r\n    }\r\n    destroy() {\r\n        this.destroyed = true\r\n        this.oHash.destroy()\r\n        this.iHash.destroy()\r\n    }\r\n}\r\nconst hmac = (hash, key, message) =>\r\n    new HMAC(hash, key).update(message).digest()\r\nhmac.create = (hash, key) => new HMAC(hash, key)\r\nfunction pbkdf2Init(hash$1, _password, _salt, _opts) {\r\n    hash(hash$1)\r\n    const opts = checkOpts(\r\n        {\r\n            dkLen: 32,\r\n            asyncTick: 10,\r\n        },\r\n        _opts,\r\n    )\r\n    const { c, dkLen, asyncTick } = opts\r\n    number(c)\r\n    number(dkLen)\r\n    number(asyncTick)\r\n    if (c < 1) throw new Error(\"PBKDF2: iterations (c) should be >= 1\")\r\n    const password = toBytes(_password)\r\n    const salt = toBytes(_salt)\r\n    const DK = new Uint8Array(dkLen)\r\n    const PRF = hmac.create(hash$1, password)\r\n    const PRFSalt = PRF._cloneInto().update(salt)\r\n    return {\r\n        c: c,\r\n        dkLen: dkLen,\r\n        asyncTick: asyncTick,\r\n        DK: DK,\r\n        PRF: PRF,\r\n        PRFSalt: PRFSalt,\r\n    }\r\n}\r\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\r\n    PRF.destroy()\r\n    PRFSalt.destroy()\r\n    if (prfW) prfW.destroy()\r\n    u.fill(0)\r\n    return DK\r\n}\r\nfunction pbkdf2$1(hash, password, salt, opts) {\r\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(\r\n        hash,\r\n        password,\r\n        salt,\r\n        opts,\r\n    )\r\n    let prfW\r\n    const arr = new Uint8Array(4)\r\n    const view = createView(arr)\r\n    const u = new Uint8Array(PRF.outputLen)\r\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\r\n        const Ti = DK.subarray(pos, pos + PRF.outputLen)\r\n        view.setInt32(0, ti, false)\r\n        ;(prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u)\r\n        Ti.set(u.subarray(0, Ti.length))\r\n        for (let ui = 1; ui < c; ui++) {\r\n            PRF._cloneInto(prfW).update(u).digestInto(u)\r\n            for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i]\r\n        }\r\n    }\r\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u)\r\n}\r\nfunction setBigUint64(view, byteOffset, value, isLE) {\r\n    if (typeof view.setBigUint64 === \"function\")\r\n        return view.setBigUint64(byteOffset, value, isLE)\r\n    const _32n = BigInt(32)\r\n    const _u32_max = BigInt(4294967295)\r\n    const wh = Number((value >> _32n) & _u32_max)\r\n    const wl = Number(value & _u32_max)\r\n    const h = isLE ? 4 : 0\r\n    const l = isLE ? 0 : 4\r\n    view.setUint32(byteOffset + h, wh, isLE)\r\n    view.setUint32(byteOffset + l, wl, isLE)\r\n}\r\nclass SHA2 extends Hash {\r\n    constructor(blockLen, outputLen, padOffset, isLE) {\r\n        super()\r\n        this.blockLen = blockLen\r\n        this.outputLen = outputLen\r\n        this.padOffset = padOffset\r\n        this.isLE = isLE\r\n        this.finished = false\r\n        this.length = 0\r\n        this.pos = 0\r\n        this.destroyed = false\r\n        this.buffer = new Uint8Array(blockLen)\r\n        this.view = createView(this.buffer)\r\n    }\r\n    update(data) {\r\n        exists(this)\r\n        const { view, buffer, blockLen } = this\r\n        data = toBytes(data)\r\n        const len = data.length\r\n        for (let pos = 0; pos < len; ) {\r\n            const take = Math.min(blockLen - this.pos, len - pos)\r\n            if (take === blockLen) {\r\n                const dataView = createView(data)\r\n                for (; blockLen <= len - pos; pos += blockLen)\r\n                    this.process(dataView, pos)\r\n                continue\r\n            }\r\n            buffer.set(data.subarray(pos, pos + take), this.pos)\r\n            this.pos += take\r\n            pos += take\r\n            if (this.pos === blockLen) {\r\n                this.process(view, 0)\r\n                this.pos = 0\r\n            }\r\n        }\r\n        this.length += data.length\r\n        this.roundClean()\r\n        return this\r\n    }\r\n    digestInto(out) {\r\n        exists(this)\r\n        output(out, this)\r\n        this.finished = true\r\n        const { buffer, view, blockLen, isLE } = this\r\n        let { pos } = this\r\n        buffer[pos++] = 128\r\n        this.buffer.subarray(pos).fill(0)\r\n        if (this.padOffset > blockLen - pos) {\r\n            this.process(view, 0)\r\n            pos = 0\r\n        }\r\n        for (let i = pos; i < blockLen; i++) buffer[i] = 0\r\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE)\r\n        this.process(view, 0)\r\n        const oview = createView(out)\r\n        const len = this.outputLen\r\n        if (len % 4)\r\n            throw new Error(\"_sha2: outputLen should be aligned to 32bit\")\r\n        const outLen = len / 4\r\n        const state = this.get()\r\n        if (outLen > state.length)\r\n            throw new Error(\"_sha2: outputLen bigger than state\")\r\n        for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE)\r\n    }\r\n    digest() {\r\n        const { buffer, outputLen } = this\r\n        this.digestInto(buffer)\r\n        const res = buffer.slice(0, outputLen)\r\n        this.destroy()\r\n        return res\r\n    }\r\n    _cloneInto(to) {\r\n        to || (to = new this.constructor())\r\n        to.set(...this.get())\r\n        const { blockLen, buffer, length, finished, destroyed, pos } = this\r\n        to.length = length\r\n        to.pos = pos\r\n        to.finished = finished\r\n        to.destroyed = destroyed\r\n        if (length % blockLen) to.buffer.set(buffer)\r\n        return to\r\n    }\r\n}\r\nconst Chi = (a, b, c) => (a & b) ^ (~a & c)\r\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c)\r\nconst SHA256_K = new Uint32Array([\r\n    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,\r\n    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,\r\n    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,\r\n    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,\r\n    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,\r\n    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,\r\n    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,\r\n    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,\r\n    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,\r\n    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,\r\n    2428436474, 2756734187, 3204031479, 3329325298,\r\n])\r\nconst IV = new Uint32Array([\r\n    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,\r\n    528734635, 1541459225,\r\n])\r\nconst SHA256_W = new Uint32Array(64)\r\nclass SHA256 extends SHA2 {\r\n    constructor() {\r\n        super(64, 32, 8, false)\r\n        this.A = IV[0] | 0\r\n        this.B = IV[1] | 0\r\n        this.C = IV[2] | 0\r\n        this.D = IV[3] | 0\r\n        this.E = IV[4] | 0\r\n        this.F = IV[5] | 0\r\n        this.G = IV[6] | 0\r\n        this.H = IV[7] | 0\r\n    }\r\n    get() {\r\n        const { A, B, C, D, E, F, G, H } = this\r\n        return [A, B, C, D, E, F, G, H]\r\n    }\r\n    set(A, B, C, D, E, F, G, H) {\r\n        this.A = A | 0\r\n        this.B = B | 0\r\n        this.C = C | 0\r\n        this.D = D | 0\r\n        this.E = E | 0\r\n        this.F = F | 0\r\n        this.G = G | 0\r\n        this.H = H | 0\r\n    }\r\n    process(view, offset) {\r\n        for (let i = 0; i < 16; i++, offset += 4)\r\n            SHA256_W[i] = view.getUint32(offset, false)\r\n        for (let i = 16; i < 64; i++) {\r\n            const W15 = SHA256_W[i - 15]\r\n            const W2 = SHA256_W[i - 2]\r\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3)\r\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10)\r\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0\r\n        }\r\n        let { A, B, C, D, E, F, G, H } = this\r\n        for (let i = 0; i < 64; i++) {\r\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25)\r\n            const T1 =\r\n                (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0\r\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22)\r\n            const T2 = (sigma0 + Maj(A, B, C)) | 0\r\n            H = G\r\n            G = F\r\n            F = E\r\n            E = (D + T1) | 0\r\n            D = C\r\n            C = B\r\n            B = A\r\n            A = (T1 + T2) | 0\r\n        }\r\n        A = (A + this.A) | 0\r\n        B = (B + this.B) | 0\r\n        C = (C + this.C) | 0\r\n        D = (D + this.D) | 0\r\n        E = (E + this.E) | 0\r\n        F = (F + this.F) | 0\r\n        G = (G + this.G) | 0\r\n        H = (H + this.H) | 0\r\n        this.set(A, B, C, D, E, F, G, H)\r\n    }\r\n    roundClean() {\r\n        SHA256_W.fill(0)\r\n    }\r\n    destroy() {\r\n        this.set(0, 0, 0, 0, 0, 0, 0, 0)\r\n        this.buffer.fill(0)\r\n    }\r\n}\r\nconst sha256$1 = wrapConstructor(() => new SHA256())\r\nconst U32_MASK64 = BigInt(2 ** 32 - 1)\r\nconst _32n = BigInt(32)\r\nfunction fromBig(n, le = false) {\r\n    if (le)\r\n        return {\r\n            h: Number(n & U32_MASK64),\r\n            l: Number((n >> _32n) & U32_MASK64),\r\n        }\r\n    return {\r\n        h: Number((n >> _32n) & U32_MASK64) | 0,\r\n        l: Number(n & U32_MASK64) | 0,\r\n    }\r\n}\r\nfunction split$1(lst, le = false) {\r\n    let Ah = new Uint32Array(lst.length)\r\n    let Al = new Uint32Array(lst.length)\r\n    for (let i = 0; i < lst.length; i++) {\r\n        const { h, l } = fromBig(lst[i], le)\r\n        ;[Ah[i], Al[i]] = [h, l]\r\n    }\r\n    return [Ah, Al]\r\n}\r\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0)\r\nconst shrSH = (h, _l, s) => h >>> s\r\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s)\r\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s))\r\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s)\r\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32))\r\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s))\r\nconst rotr32H = (_h, l) => l\r\nconst rotr32L = (h, _l) => h\r\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s))\r\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s))\r\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s))\r\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s))\r\nfunction add(Ah, Al, Bh, Bl) {\r\n    const l = (Al >>> 0) + (Bl >>> 0)\r\n    return {\r\n        h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0,\r\n        l: l | 0,\r\n    }\r\n}\r\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0)\r\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0\r\nconst add4L = (Al, Bl, Cl, Dl) =>\r\n    (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0)\r\nconst add4H = (low, Ah, Bh, Ch, Dh) =>\r\n    (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0\r\nconst add5L = (Al, Bl, Cl, Dl, El) =>\r\n    (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0)\r\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) =>\r\n    (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0\r\nconst u64 = {\r\n    fromBig: fromBig,\r\n    split: split$1,\r\n    toBig: toBig,\r\n    shrSH: shrSH,\r\n    shrSL: shrSL,\r\n    rotrSH: rotrSH,\r\n    rotrSL: rotrSL,\r\n    rotrBH: rotrBH,\r\n    rotrBL: rotrBL,\r\n    rotr32H: rotr32H,\r\n    rotr32L: rotr32L,\r\n    rotlSH: rotlSH,\r\n    rotlSL: rotlSL,\r\n    rotlBH: rotlBH,\r\n    rotlBL: rotlBL,\r\n    add: add,\r\n    add3L: add3L,\r\n    add3H: add3H,\r\n    add4L: add4L,\r\n    add4H: add4H,\r\n    add5H: add5H,\r\n    add5L: add5L,\r\n}\r\nvar u64$1 = u64\r\nconst [SHA512_Kh, SHA512_Kl] = (() =>\r\n    u64$1.split(\r\n        [\r\n            \"0x428a2f98d728ae22\",\r\n            \"0x7137449123ef65cd\",\r\n            \"0xb5c0fbcfec4d3b2f\",\r\n            \"0xe9b5dba58189dbbc\",\r\n            \"0x3956c25bf348b538\",\r\n            \"0x59f111f1b605d019\",\r\n            \"0x923f82a4af194f9b\",\r\n            \"0xab1c5ed5da6d8118\",\r\n            \"0xd807aa98a3030242\",\r\n            \"0x12835b0145706fbe\",\r\n            \"0x243185be4ee4b28c\",\r\n            \"0x550c7dc3d5ffb4e2\",\r\n            \"0x72be5d74f27b896f\",\r\n            \"0x80deb1fe3b1696b1\",\r\n            \"0x9bdc06a725c71235\",\r\n            \"0xc19bf174cf692694\",\r\n            \"0xe49b69c19ef14ad2\",\r\n            \"0xefbe4786384f25e3\",\r\n            \"0x0fc19dc68b8cd5b5\",\r\n            \"0x240ca1cc77ac9c65\",\r\n            \"0x2de92c6f592b0275\",\r\n            \"0x4a7484aa6ea6e483\",\r\n            \"0x5cb0a9dcbd41fbd4\",\r\n            \"0x76f988da831153b5\",\r\n            \"0x983e5152ee66dfab\",\r\n            \"0xa831c66d2db43210\",\r\n            \"0xb00327c898fb213f\",\r\n            \"0xbf597fc7beef0ee4\",\r\n            \"0xc6e00bf33da88fc2\",\r\n            \"0xd5a79147930aa725\",\r\n            \"0x06ca6351e003826f\",\r\n            \"0x142929670a0e6e70\",\r\n            \"0x27b70a8546d22ffc\",\r\n            \"0x2e1b21385c26c926\",\r\n            \"0x4d2c6dfc5ac42aed\",\r\n            \"0x53380d139d95b3df\",\r\n            \"0x650a73548baf63de\",\r\n            \"0x766a0abb3c77b2a8\",\r\n            \"0x81c2c92e47edaee6\",\r\n            \"0x92722c851482353b\",\r\n            \"0xa2bfe8a14cf10364\",\r\n            \"0xa81a664bbc423001\",\r\n            \"0xc24b8b70d0f89791\",\r\n            \"0xc76c51a30654be30\",\r\n            \"0xd192e819d6ef5218\",\r\n            \"0xd69906245565a910\",\r\n            \"0xf40e35855771202a\",\r\n            \"0x106aa07032bbd1b8\",\r\n            \"0x19a4c116b8d2d0c8\",\r\n            \"0x1e376c085141ab53\",\r\n            \"0x2748774cdf8eeb99\",\r\n            \"0x34b0bcb5e19b48a8\",\r\n            \"0x391c0cb3c5c95a63\",\r\n            \"0x4ed8aa4ae3418acb\",\r\n            \"0x5b9cca4f7763e373\",\r\n            \"0x682e6ff3d6b2b8a3\",\r\n            \"0x748f82ee5defb2fc\",\r\n            \"0x78a5636f43172f60\",\r\n            \"0x84c87814a1f0ab72\",\r\n            \"0x8cc702081a6439ec\",\r\n            \"0x90befffa23631e28\",\r\n            \"0xa4506cebde82bde9\",\r\n            \"0xbef9a3f7b2c67915\",\r\n            \"0xc67178f2e372532b\",\r\n            \"0xca273eceea26619c\",\r\n            \"0xd186b8c721c0c207\",\r\n            \"0xeada7dd6cde0eb1e\",\r\n            \"0xf57d4f7fee6ed178\",\r\n            \"0x06f067aa72176fba\",\r\n            \"0x0a637dc5a2c898a6\",\r\n            \"0x113f9804bef90dae\",\r\n            \"0x1b710b35131c471b\",\r\n            \"0x28db77f523047d84\",\r\n            \"0x32caab7b40c72493\",\r\n            \"0x3c9ebe0a15c9bebc\",\r\n            \"0x431d67c49c100d4c\",\r\n            \"0x4cc5d4becb3e42b6\",\r\n            \"0x597f299cfc657e2a\",\r\n            \"0x5fcb6fab3ad6faec\",\r\n            \"0x6c44198c4a475817\",\r\n        ].map((n) => BigInt(n)),\r\n    ))()\r\nconst SHA512_W_H = new Uint32Array(80)\r\nconst SHA512_W_L = new Uint32Array(80)\r\nclass SHA512 extends SHA2 {\r\n    constructor() {\r\n        super(128, 64, 16, false)\r\n        this.Ah = 1779033703 | 0\r\n        this.Al = 4089235720 | 0\r\n        this.Bh = 3144134277 | 0\r\n        this.Bl = 2227873595 | 0\r\n        this.Ch = 1013904242 | 0\r\n        this.Cl = 4271175723 | 0\r\n        this.Dh = 2773480762 | 0\r\n        this.Dl = 1595750129 | 0\r\n        this.Eh = 1359893119 | 0\r\n        this.El = 2917565137 | 0\r\n        this.Fh = 2600822924 | 0\r\n        this.Fl = 725511199 | 0\r\n        this.Gh = 528734635 | 0\r\n        this.Gl = 4215389547 | 0\r\n        this.Hh = 1541459225 | 0\r\n        this.Hl = 327033209 | 0\r\n    }\r\n    get() {\r\n        const {\r\n            Ah,\r\n            Al,\r\n            Bh,\r\n            Bl,\r\n            Ch,\r\n            Cl,\r\n            Dh,\r\n            Dl,\r\n            Eh,\r\n            El,\r\n            Fh,\r\n            Fl,\r\n            Gh,\r\n            Gl,\r\n            Hh,\r\n            Hl,\r\n        } = this\r\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl]\r\n    }\r\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\r\n        this.Ah = Ah | 0\r\n        this.Al = Al | 0\r\n        this.Bh = Bh | 0\r\n        this.Bl = Bl | 0\r\n        this.Ch = Ch | 0\r\n        this.Cl = Cl | 0\r\n        this.Dh = Dh | 0\r\n        this.Dl = Dl | 0\r\n        this.Eh = Eh | 0\r\n        this.El = El | 0\r\n        this.Fh = Fh | 0\r\n        this.Fl = Fl | 0\r\n        this.Gh = Gh | 0\r\n        this.Gl = Gl | 0\r\n        this.Hh = Hh | 0\r\n        this.Hl = Hl | 0\r\n    }\r\n    process(view, offset) {\r\n        for (let i = 0; i < 16; i++, offset += 4) {\r\n            SHA512_W_H[i] = view.getUint32(offset)\r\n            SHA512_W_L[i] = view.getUint32((offset += 4))\r\n        }\r\n        for (let i = 16; i < 80; i++) {\r\n            const W15h = SHA512_W_H[i - 15] | 0\r\n            const W15l = SHA512_W_L[i - 15] | 0\r\n            const s0h =\r\n                u64$1.rotrSH(W15h, W15l, 1) ^\r\n                u64$1.rotrSH(W15h, W15l, 8) ^\r\n                u64$1.shrSH(W15h, W15l, 7)\r\n            const s0l =\r\n                u64$1.rotrSL(W15h, W15l, 1) ^\r\n                u64$1.rotrSL(W15h, W15l, 8) ^\r\n                u64$1.shrSL(W15h, W15l, 7)\r\n            const W2h = SHA512_W_H[i - 2] | 0\r\n            const W2l = SHA512_W_L[i - 2] | 0\r\n            const s1h =\r\n                u64$1.rotrSH(W2h, W2l, 19) ^\r\n                u64$1.rotrBH(W2h, W2l, 61) ^\r\n                u64$1.shrSH(W2h, W2l, 6)\r\n            const s1l =\r\n                u64$1.rotrSL(W2h, W2l, 19) ^\r\n                u64$1.rotrBL(W2h, W2l, 61) ^\r\n                u64$1.shrSL(W2h, W2l, 6)\r\n            const SUMl = u64$1.add4L(\r\n                s0l,\r\n                s1l,\r\n                SHA512_W_L[i - 7],\r\n                SHA512_W_L[i - 16],\r\n            )\r\n            const SUMh = u64$1.add4H(\r\n                SUMl,\r\n                s0h,\r\n                s1h,\r\n                SHA512_W_H[i - 7],\r\n                SHA512_W_H[i - 16],\r\n            )\r\n            SHA512_W_H[i] = SUMh | 0\r\n            SHA512_W_L[i] = SUMl | 0\r\n        }\r\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } =\r\n            this\r\n        for (let i = 0; i < 80; i++) {\r\n            const sigma1h =\r\n                u64$1.rotrSH(Eh, El, 14) ^\r\n                u64$1.rotrSH(Eh, El, 18) ^\r\n                u64$1.rotrBH(Eh, El, 41)\r\n            const sigma1l =\r\n                u64$1.rotrSL(Eh, El, 14) ^\r\n                u64$1.rotrSL(Eh, El, 18) ^\r\n                u64$1.rotrBL(Eh, El, 41)\r\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh)\r\n            const CHIl = (El & Fl) ^ (~El & Gl)\r\n            const T1ll = u64$1.add5L(\r\n                Hl,\r\n                sigma1l,\r\n                CHIl,\r\n                SHA512_Kl[i],\r\n                SHA512_W_L[i],\r\n            )\r\n            const T1h = u64$1.add5H(\r\n                T1ll,\r\n                Hh,\r\n                sigma1h,\r\n                CHIh,\r\n                SHA512_Kh[i],\r\n                SHA512_W_H[i],\r\n            )\r\n            const T1l = T1ll | 0\r\n            const sigma0h =\r\n                u64$1.rotrSH(Ah, Al, 28) ^\r\n                u64$1.rotrBH(Ah, Al, 34) ^\r\n                u64$1.rotrBH(Ah, Al, 39)\r\n            const sigma0l =\r\n                u64$1.rotrSL(Ah, Al, 28) ^\r\n                u64$1.rotrBL(Ah, Al, 34) ^\r\n                u64$1.rotrBL(Ah, Al, 39)\r\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch)\r\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl)\r\n            Hh = Gh | 0\r\n            Hl = Gl | 0\r\n            Gh = Fh | 0\r\n            Gl = Fl | 0\r\n            Fh = Eh | 0\r\n            Fl = El | 0\r\n            ;({ h: Eh, l: El } = u64$1.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0))\r\n            Dh = Ch | 0\r\n            Dl = Cl | 0\r\n            Ch = Bh | 0\r\n            Cl = Bl | 0\r\n            Bh = Ah | 0\r\n            Bl = Al | 0\r\n            const All = u64$1.add3L(T1l, sigma0l, MAJl)\r\n            Ah = u64$1.add3H(All, T1h, sigma0h, MAJh)\r\n            Al = All | 0\r\n        }\r\n        ;({ h: Ah, l: Al } = u64$1.add(\r\n            this.Ah | 0,\r\n            this.Al | 0,\r\n            Ah | 0,\r\n            Al | 0,\r\n        ))\r\n        ;({ h: Bh, l: Bl } = u64$1.add(\r\n            this.Bh | 0,\r\n            this.Bl | 0,\r\n            Bh | 0,\r\n            Bl | 0,\r\n        ))\r\n        ;({ h: Ch, l: Cl } = u64$1.add(\r\n            this.Ch | 0,\r\n            this.Cl | 0,\r\n            Ch | 0,\r\n            Cl | 0,\r\n        ))\r\n        ;({ h: Dh, l: Dl } = u64$1.add(\r\n            this.Dh | 0,\r\n            this.Dl | 0,\r\n            Dh | 0,\r\n            Dl | 0,\r\n        ))\r\n        ;({ h: Eh, l: El } = u64$1.add(\r\n            this.Eh | 0,\r\n            this.El | 0,\r\n            Eh | 0,\r\n            El | 0,\r\n        ))\r\n        ;({ h: Fh, l: Fl } = u64$1.add(\r\n            this.Fh | 0,\r\n            this.Fl | 0,\r\n            Fh | 0,\r\n            Fl | 0,\r\n        ))\r\n        ;({ h: Gh, l: Gl } = u64$1.add(\r\n            this.Gh | 0,\r\n            this.Gl | 0,\r\n            Gh | 0,\r\n            Gl | 0,\r\n        ))\r\n        ;({ h: Hh, l: Hl } = u64$1.add(\r\n            this.Hh | 0,\r\n            this.Hl | 0,\r\n            Hh | 0,\r\n            Hl | 0,\r\n        ))\r\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl)\r\n    }\r\n    roundClean() {\r\n        SHA512_W_H.fill(0)\r\n        SHA512_W_L.fill(0)\r\n    }\r\n    destroy() {\r\n        this.buffer.fill(0)\r\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\r\n    }\r\n}\r\nconst sha512$1 = wrapConstructor(() => new SHA512())\r\nfunction getGlobal$1() {\r\n    if (typeof self !== \"undefined\") {\r\n        return self\r\n    }\r\n    if (typeof window !== \"undefined\") {\r\n        return window\r\n    }\r\n    if (typeof global !== \"undefined\") {\r\n        return global\r\n    }\r\n    throw new Error(\"unable to locate global object\")\r\n}\r\nconst anyGlobal = getGlobal$1()\r\nconst crypto = anyGlobal.crypto || anyGlobal.msCrypto\r\nfunction createHash(algo) {\r\n    switch (algo) {\r\n        case \"sha256\":\r\n            return sha256$1.create()\r\n        case \"sha512\":\r\n            return sha512$1.create()\r\n    }\r\n    assertArgument(false, \"invalid hashing algorithm name\", \"algorithm\", algo)\r\n}\r\nfunction createHmac(_algo, key) {\r\n    const algo = {\r\n        sha256: sha256$1,\r\n        sha512: sha512$1,\r\n    }[_algo]\r\n    assertArgument(algo != null, \"invalid hmac algorithm\", \"algorithm\", _algo)\r\n    return hmac.create(algo, key)\r\n}\r\nfunction pbkdf2Sync(password, salt, iterations, keylen, _algo) {\r\n    const algo = {\r\n        sha256: sha256$1,\r\n        sha512: sha512$1,\r\n    }[_algo]\r\n    assertArgument(algo != null, \"invalid pbkdf2 algorithm\", \"algorithm\", _algo)\r\n    return pbkdf2$1(algo, password, salt, {\r\n        c: iterations,\r\n        dkLen: keylen,\r\n    })\r\n}\r\nfunction randomBytes$1(length) {\r\n    assert(\r\n        crypto != null,\r\n        \"platform does not support secure random numbers\",\r\n        \"UNSUPPORTED_OPERATION\",\r\n        {\r\n            operation: \"randomBytes\",\r\n        },\r\n    )\r\n    assertArgument(\r\n        Number.isInteger(length) && length > 0 && length <= 1024,\r\n        \"invalid length\",\r\n        \"length\",\r\n        length,\r\n    )\r\n    const result = new Uint8Array(length)\r\n    crypto.getRandomValues(result)\r\n    return result\r\n}\r\nlet locked$4 = false\r\nconst _computeHmac = function (algorithm, key, data) {\r\n    return createHmac(algorithm, key).update(data).digest()\r\n}\r\nlet __computeHmac = _computeHmac\r\nfunction computeHmac(algorithm, _key, _data) {\r\n    const key = getBytes(_key, \"key\")\r\n    const data = getBytes(_data, \"data\")\r\n    return hexlify(__computeHmac(algorithm, key, data))\r\n}\r\ncomputeHmac._ = _computeHmac\r\ncomputeHmac.lock = function () {\r\n    locked$4 = true\r\n}\r\ncomputeHmac.register = function (func) {\r\n    if (locked$4) {\r\n        throw new Error(\"computeHmac is locked\")\r\n    }\r\n    __computeHmac = func\r\n}\r\nObject.freeze(computeHmac)\r\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []]\r\nconst _0n$4 = BigInt(0)\r\nconst _1n$5 = BigInt(1)\r\nconst _2n$3 = BigInt(2)\r\nconst _7n = BigInt(7)\r\nconst _256n = BigInt(256)\r\nconst _0x71n = BigInt(113)\r\nfor (let round = 0, R = _1n$5, x = 1, y = 0; round < 24; round++) {\r\n    ;[x, y] = [y, (2 * x + 3 * y) % 5]\r\n    SHA3_PI.push(2 * (5 * y + x))\r\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64)\r\n    let t = _0n$4\r\n    for (let j = 0; j < 7; j++) {\r\n        R = ((R << _1n$5) ^ ((R >> _7n) * _0x71n)) % _256n\r\n        if (R & _2n$3) t ^= _1n$5 << ((_1n$5 << BigInt(j)) - _1n$5)\r\n    }\r\n    _SHA3_IOTA.push(t)\r\n}\r\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = split$1(_SHA3_IOTA, true)\r\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s))\r\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s))\r\nfunction keccakP(s, rounds = 24) {\r\n    const B = new Uint32Array(5 * 2)\r\n    for (let round = 24 - rounds; round < 24; round++) {\r\n        for (let x = 0; x < 10; x++)\r\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40]\r\n        for (let x = 0; x < 10; x += 2) {\r\n            const idx1 = (x + 8) % 10\r\n            const idx0 = (x + 2) % 10\r\n            const B0 = B[idx0]\r\n            const B1 = B[idx0 + 1]\r\n            const Th = rotlH(B0, B1, 1) ^ B[idx1]\r\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1]\r\n            for (let y = 0; y < 50; y += 10) {\r\n                s[x + y] ^= Th\r\n                s[x + y + 1] ^= Tl\r\n            }\r\n        }\r\n        let curH = s[2]\r\n        let curL = s[3]\r\n        for (let t = 0; t < 24; t++) {\r\n            const shift = SHA3_ROTL[t]\r\n            const Th = rotlH(curH, curL, shift)\r\n            const Tl = rotlL(curH, curL, shift)\r\n            const PI = SHA3_PI[t]\r\n            curH = s[PI]\r\n            curL = s[PI + 1]\r\n            s[PI] = Th\r\n            s[PI + 1] = Tl\r\n        }\r\n        for (let y = 0; y < 50; y += 10) {\r\n            for (let x = 0; x < 10; x++) B[x] = s[y + x]\r\n            for (let x = 0; x < 10; x++)\r\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10]\r\n        }\r\n        s[0] ^= SHA3_IOTA_H[round]\r\n        s[1] ^= SHA3_IOTA_L[round]\r\n    }\r\n    B.fill(0)\r\n}\r\nclass Keccak extends Hash {\r\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\r\n        super()\r\n        this.blockLen = blockLen\r\n        this.suffix = suffix\r\n        this.outputLen = outputLen\r\n        this.enableXOF = enableXOF\r\n        this.rounds = rounds\r\n        this.pos = 0\r\n        this.posOut = 0\r\n        this.finished = false\r\n        this.destroyed = false\r\n        number(outputLen)\r\n        if (0 >= this.blockLen || this.blockLen >= 200)\r\n            throw new Error(\"Sha3 supports only keccak-f1600 function\")\r\n        this.state = new Uint8Array(200)\r\n        this.state32 = u32(this.state)\r\n    }\r\n    keccak() {\r\n        keccakP(this.state32, this.rounds)\r\n        this.posOut = 0\r\n        this.pos = 0\r\n    }\r\n    update(data) {\r\n        exists(this)\r\n        const { blockLen, state } = this\r\n        data = toBytes(data)\r\n        const len = data.length\r\n        for (let pos = 0; pos < len; ) {\r\n            const take = Math.min(blockLen - this.pos, len - pos)\r\n            for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++]\r\n            if (this.pos === blockLen) this.keccak()\r\n        }\r\n        return this\r\n    }\r\n    finish() {\r\n        if (this.finished) return\r\n        this.finished = true\r\n        const { state, suffix, pos, blockLen } = this\r\n        state[pos] ^= suffix\r\n        if ((suffix & 128) !== 0 && pos === blockLen - 1) this.keccak()\r\n        state[blockLen - 1] ^= 128\r\n        this.keccak()\r\n    }\r\n    writeInto(out) {\r\n        exists(this, false)\r\n        bytes(out)\r\n        this.finish()\r\n        const bufferOut = this.state\r\n        const { blockLen } = this\r\n        for (let pos = 0, len = out.length; pos < len; ) {\r\n            if (this.posOut >= blockLen) this.keccak()\r\n            const take = Math.min(blockLen - this.posOut, len - pos)\r\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos)\r\n            this.posOut += take\r\n            pos += take\r\n        }\r\n        return out\r\n    }\r\n    xofInto(out) {\r\n        if (!this.enableXOF)\r\n            throw new Error(\"XOF is not possible for this instance\")\r\n        return this.writeInto(out)\r\n    }\r\n    xof(bytes) {\r\n        number(bytes)\r\n        return this.xofInto(new Uint8Array(bytes))\r\n    }\r\n    digestInto(out) {\r\n        output(out, this)\r\n        if (this.finished) throw new Error(\"digest() was already called\")\r\n        this.writeInto(out)\r\n        this.destroy()\r\n        return out\r\n    }\r\n    digest() {\r\n        return this.digestInto(new Uint8Array(this.outputLen))\r\n    }\r\n    destroy() {\r\n        this.destroyed = true\r\n        this.state.fill(0)\r\n    }\r\n    _cloneInto(to) {\r\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this\r\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds))\r\n        to.state32.set(this.state32)\r\n        to.pos = this.pos\r\n        to.posOut = this.posOut\r\n        to.finished = this.finished\r\n        to.rounds = rounds\r\n        to.suffix = suffix\r\n        to.outputLen = outputLen\r\n        to.enableXOF = enableXOF\r\n        to.destroyed = this.destroyed\r\n        return to\r\n    }\r\n}\r\nconst gen = (suffix, blockLen, outputLen) =>\r\n    wrapConstructor(() => new Keccak(blockLen, suffix, outputLen))\r\nconst keccak_256 = gen(1, 136, 256 / 8)\r\nlet locked$3 = false\r\nconst _keccak256 = function (data) {\r\n    return keccak_256(data)\r\n}\r\nlet __keccak256 = _keccak256\r\nfunction keccak256(_data) {\r\n    const data = getBytes(_data, \"data\")\r\n    return hexlify(__keccak256(data))\r\n}\r\nkeccak256._ = _keccak256\r\nkeccak256.lock = function () {\r\n    locked$3 = true\r\n}\r\nkeccak256.register = function (func) {\r\n    if (locked$3) {\r\n        throw new TypeError(\"keccak256 is locked\")\r\n    }\r\n    __keccak256 = func\r\n}\r\nObject.freeze(keccak256)\r\nconst Rho = new Uint8Array([\r\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\r\n])\r\nconst Id = Uint8Array.from(\r\n    {\r\n        length: 16,\r\n    },\r\n    (_, i) => i,\r\n)\r\nconst Pi = Id.map((i) => (9 * i + 5) % 16)\r\nlet idxL = [Id]\r\nlet idxR = [Pi]\r\nfor (let i = 0; i < 4; i++)\r\n    for (let j of [idxL, idxR]) j.push(j[i].map((k) => Rho[k]))\r\nconst shifts = [\r\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\r\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\r\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\r\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\r\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\r\n].map((i) => new Uint8Array(i))\r\nconst shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]))\r\nconst shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]))\r\nconst Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838])\r\nconst Kr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0])\r\nconst rotl$1 = (word, shift) => (word << shift) | (word >>> (32 - shift))\r\nfunction f(group, x, y, z) {\r\n    if (group === 0) return x ^ y ^ z\r\n    else if (group === 1) return (x & y) | (~x & z)\r\n    else if (group === 2) return (x | ~y) ^ z\r\n    else if (group === 3) return (x & z) | (y & ~z)\r\n    else return x ^ (y | ~z)\r\n}\r\nconst BUF = new Uint32Array(16)\r\nclass RIPEMD160 extends SHA2 {\r\n    constructor() {\r\n        super(64, 20, 8, true)\r\n        this.h0 = 1732584193 | 0\r\n        this.h1 = 4023233417 | 0\r\n        this.h2 = 2562383102 | 0\r\n        this.h3 = 271733878 | 0\r\n        this.h4 = 3285377520 | 0\r\n    }\r\n    get() {\r\n        const { h0, h1, h2, h3, h4 } = this\r\n        return [h0, h1, h2, h3, h4]\r\n    }\r\n    set(h0, h1, h2, h3, h4) {\r\n        this.h0 = h0 | 0\r\n        this.h1 = h1 | 0\r\n        this.h2 = h2 | 0\r\n        this.h3 = h3 | 0\r\n        this.h4 = h4 | 0\r\n    }\r\n    process(view, offset) {\r\n        for (let i = 0; i < 16; i++, offset += 4)\r\n            BUF[i] = view.getUint32(offset, true)\r\n        let al = this.h0 | 0,\r\n            ar = al,\r\n            bl = this.h1 | 0,\r\n            br = bl,\r\n            cl = this.h2 | 0,\r\n            cr = cl,\r\n            dl = this.h3 | 0,\r\n            dr = dl,\r\n            el = this.h4 | 0,\r\n            er = el\r\n        for (let group = 0; group < 5; group++) {\r\n            const rGroup = 4 - group\r\n            const hbl = Kl[group],\r\n                hbr = Kr[group]\r\n            const rl = idxL[group],\r\n                rr = idxR[group]\r\n            const sl = shiftsL[group],\r\n                sr = shiftsR[group]\r\n            for (let i = 0; i < 16; i++) {\r\n                const tl =\r\n                    (rotl$1(\r\n                        al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl,\r\n                        sl[i],\r\n                    ) +\r\n                        el) |\r\n                    0\r\n                ;(al = el),\r\n                    (el = dl),\r\n                    (dl = rotl$1(cl, 10) | 0),\r\n                    (cl = bl),\r\n                    (bl = tl)\r\n            }\r\n            for (let i = 0; i < 16; i++) {\r\n                const tr =\r\n                    (rotl$1(\r\n                        ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr,\r\n                        sr[i],\r\n                    ) +\r\n                        er) |\r\n                    0\r\n                ;(ar = er),\r\n                    (er = dr),\r\n                    (dr = rotl$1(cr, 10) | 0),\r\n                    (cr = br),\r\n                    (br = tr)\r\n            }\r\n        }\r\n        this.set(\r\n            (this.h1 + cl + dr) | 0,\r\n            (this.h2 + dl + er) | 0,\r\n            (this.h3 + el + ar) | 0,\r\n            (this.h4 + al + br) | 0,\r\n            (this.h0 + bl + cr) | 0,\r\n        )\r\n    }\r\n    roundClean() {\r\n        BUF.fill(0)\r\n    }\r\n    destroy() {\r\n        this.destroyed = true\r\n        this.buffer.fill(0)\r\n        this.set(0, 0, 0, 0, 0)\r\n    }\r\n}\r\nconst ripemd160$1 = wrapConstructor(() => new RIPEMD160())\r\nlet locked$2 = false\r\nconst _ripemd160 = function (data) {\r\n    return ripemd160$1(data)\r\n}\r\nlet __ripemd160 = _ripemd160\r\nfunction ripemd160(_data) {\r\n    const data = getBytes(_data, \"data\")\r\n    return hexlify(__ripemd160(data))\r\n}\r\nripemd160._ = _ripemd160\r\nripemd160.lock = function () {\r\n    locked$2 = true\r\n}\r\nripemd160.register = function (func) {\r\n    if (locked$2) {\r\n        throw new TypeError(\"ripemd160 is locked\")\r\n    }\r\n    __ripemd160 = func\r\n}\r\nObject.freeze(ripemd160)\r\nlet locked$1 = false\r\nconst _pbkdf2 = function (password, salt, iterations, keylen, algo) {\r\n    return pbkdf2Sync(password, salt, iterations, keylen, algo)\r\n}\r\nlet __pbkdf2 = _pbkdf2\r\nfunction pbkdf2(_password, _salt, iterations, keylen, algo) {\r\n    const password = getBytes(_password, \"password\")\r\n    const salt = getBytes(_salt, \"salt\")\r\n    return hexlify(__pbkdf2(password, salt, iterations, keylen, algo))\r\n}\r\npbkdf2._ = _pbkdf2\r\npbkdf2.lock = function () {\r\n    locked$1 = true\r\n}\r\npbkdf2.register = function (func) {\r\n    if (locked$1) {\r\n        throw new Error(\"pbkdf2 is locked\")\r\n    }\r\n    __pbkdf2 = func\r\n}\r\nObject.freeze(pbkdf2)\r\nlet locked = false\r\nconst _randomBytes = function (length) {\r\n    return new Uint8Array(randomBytes$1(length))\r\n}\r\nlet __randomBytes = _randomBytes\r\nfunction randomBytes(length) {\r\n    return __randomBytes(length)\r\n}\r\nrandomBytes._ = _randomBytes\r\nrandomBytes.lock = function () {\r\n    locked = true\r\n}\r\nrandomBytes.register = function (func) {\r\n    if (locked) {\r\n        throw new Error(\"randomBytes is locked\")\r\n    }\r\n    __randomBytes = func\r\n}\r\nObject.freeze(randomBytes)\r\nconst rotl = (a, b) => (a << b) | (a >>> (32 - b))\r\nfunction XorAndSalsa(prev, pi, input, ii, out, oi) {\r\n    let y00 = prev[pi++] ^ input[ii++],\r\n        y01 = prev[pi++] ^ input[ii++]\r\n    let y02 = prev[pi++] ^ input[ii++],\r\n        y03 = prev[pi++] ^ input[ii++]\r\n    let y04 = prev[pi++] ^ input[ii++],\r\n        y05 = prev[pi++] ^ input[ii++]\r\n    let y06 = prev[pi++] ^ input[ii++],\r\n        y07 = prev[pi++] ^ input[ii++]\r\n    let y08 = prev[pi++] ^ input[ii++],\r\n        y09 = prev[pi++] ^ input[ii++]\r\n    let y10 = prev[pi++] ^ input[ii++],\r\n        y11 = prev[pi++] ^ input[ii++]\r\n    let y12 = prev[pi++] ^ input[ii++],\r\n        y13 = prev[pi++] ^ input[ii++]\r\n    let y14 = prev[pi++] ^ input[ii++],\r\n        y15 = prev[pi++] ^ input[ii++]\r\n    let x00 = y00,\r\n        x01 = y01,\r\n        x02 = y02,\r\n        x03 = y03,\r\n        x04 = y04,\r\n        x05 = y05,\r\n        x06 = y06,\r\n        x07 = y07,\r\n        x08 = y08,\r\n        x09 = y09,\r\n        x10 = y10,\r\n        x11 = y11,\r\n        x12 = y12,\r\n        x13 = y13,\r\n        x14 = y14,\r\n        x15 = y15\r\n    for (let i = 0; i < 8; i += 2) {\r\n        x04 ^= rotl((x00 + x12) | 0, 7)\r\n        x08 ^= rotl((x04 + x00) | 0, 9)\r\n        x12 ^= rotl((x08 + x04) | 0, 13)\r\n        x00 ^= rotl((x12 + x08) | 0, 18)\r\n        x09 ^= rotl((x05 + x01) | 0, 7)\r\n        x13 ^= rotl((x09 + x05) | 0, 9)\r\n        x01 ^= rotl((x13 + x09) | 0, 13)\r\n        x05 ^= rotl((x01 + x13) | 0, 18)\r\n        x14 ^= rotl((x10 + x06) | 0, 7)\r\n        x02 ^= rotl((x14 + x10) | 0, 9)\r\n        x06 ^= rotl((x02 + x14) | 0, 13)\r\n        x10 ^= rotl((x06 + x02) | 0, 18)\r\n        x03 ^= rotl((x15 + x11) | 0, 7)\r\n        x07 ^= rotl((x03 + x15) | 0, 9)\r\n        x11 ^= rotl((x07 + x03) | 0, 13)\r\n        x15 ^= rotl((x11 + x07) | 0, 18)\r\n        x01 ^= rotl((x00 + x03) | 0, 7)\r\n        x02 ^= rotl((x01 + x00) | 0, 9)\r\n        x03 ^= rotl((x02 + x01) | 0, 13)\r\n        x00 ^= rotl((x03 + x02) | 0, 18)\r\n        x06 ^= rotl((x05 + x04) | 0, 7)\r\n        x07 ^= rotl((x06 + x05) | 0, 9)\r\n        x04 ^= rotl((x07 + x06) | 0, 13)\r\n        x05 ^= rotl((x04 + x07) | 0, 18)\r\n        x11 ^= rotl((x10 + x09) | 0, 7)\r\n        x08 ^= rotl((x11 + x10) | 0, 9)\r\n        x09 ^= rotl((x08 + x11) | 0, 13)\r\n        x10 ^= rotl((x09 + x08) | 0, 18)\r\n        x12 ^= rotl((x15 + x14) | 0, 7)\r\n        x13 ^= rotl((x12 + x15) | 0, 9)\r\n        x14 ^= rotl((x13 + x12) | 0, 13)\r\n        x15 ^= rotl((x14 + x13) | 0, 18)\r\n    }\r\n    out[oi++] = (y00 + x00) | 0\r\n    out[oi++] = (y01 + x01) | 0\r\n    out[oi++] = (y02 + x02) | 0\r\n    out[oi++] = (y03 + x03) | 0\r\n    out[oi++] = (y04 + x04) | 0\r\n    out[oi++] = (y05 + x05) | 0\r\n    out[oi++] = (y06 + x06) | 0\r\n    out[oi++] = (y07 + x07) | 0\r\n    out[oi++] = (y08 + x08) | 0\r\n    out[oi++] = (y09 + x09) | 0\r\n    out[oi++] = (y10 + x10) | 0\r\n    out[oi++] = (y11 + x11) | 0\r\n    out[oi++] = (y12 + x12) | 0\r\n    out[oi++] = (y13 + x13) | 0\r\n    out[oi++] = (y14 + x14) | 0\r\n    out[oi++] = (y15 + x15) | 0\r\n}\r\nfunction BlockMix(input, ii, out, oi, r) {\r\n    let head = oi + 0\r\n    let tail = oi + 16 * r\r\n    for (let i = 0; i < 16; i++)\r\n        out[tail + i] = input[ii + (2 * r - 1) * 16 + i]\r\n    for (let i = 0; i < r; i++, head += 16, ii += 16) {\r\n        XorAndSalsa(out, tail, input, ii, out, head)\r\n        if (i > 0) tail += 16\r\n        XorAndSalsa(out, head, input, (ii += 16), out, tail)\r\n    }\r\n}\r\nfunction scryptInit(password, salt, _opts) {\r\n    const opts = checkOpts(\r\n        {\r\n            dkLen: 32,\r\n            asyncTick: 10,\r\n            maxmem: 1024 ** 3 + 1024,\r\n        },\r\n        _opts,\r\n    )\r\n    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts\r\n    number(N)\r\n    number(r)\r\n    number(p)\r\n    number(dkLen)\r\n    number(asyncTick)\r\n    number(maxmem)\r\n    if (onProgress !== undefined && typeof onProgress !== \"function\")\r\n        throw new Error(\"progressCb should be function\")\r\n    const blockSize = 128 * r\r\n    const blockSize32 = blockSize / 4\r\n    if (\r\n        N <= 1 ||\r\n        (N & (N - 1)) !== 0 ||\r\n        N >= 2 ** (blockSize / 8) ||\r\n        N > 2 ** 32\r\n    ) {\r\n        throw new Error(\r\n            \"Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32\",\r\n        )\r\n    }\r\n    if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {\r\n        throw new Error(\r\n            \"Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)\",\r\n        )\r\n    }\r\n    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {\r\n        throw new Error(\r\n            \"Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32\",\r\n        )\r\n    }\r\n    const memUsed = blockSize * (N + p)\r\n    if (memUsed > maxmem) {\r\n        throw new Error(\r\n            `Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`,\r\n        )\r\n    }\r\n    const B = pbkdf2$1(sha256$1, password, salt, {\r\n        c: 1,\r\n        dkLen: blockSize * p,\r\n    })\r\n    const B32 = u32(B)\r\n    const V = u32(new Uint8Array(blockSize * N))\r\n    const tmp = u32(new Uint8Array(blockSize))\r\n    let blockMixCb = () => {}\r\n    if (onProgress) {\r\n        const totalBlockMix = 2 * N * p\r\n        const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1)\r\n        let blockMixCnt = 0\r\n        blockMixCb = () => {\r\n            blockMixCnt++\r\n            if (\r\n                onProgress &&\r\n                (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix)\r\n            )\r\n                onProgress(blockMixCnt / totalBlockMix)\r\n        }\r\n    }\r\n    return {\r\n        N: N,\r\n        r: r,\r\n        p: p,\r\n        dkLen: dkLen,\r\n        blockSize32: blockSize32,\r\n        V: V,\r\n        B32: B32,\r\n        B: B,\r\n        tmp: tmp,\r\n        blockMixCb: blockMixCb,\r\n        asyncTick: asyncTick,\r\n    }\r\n}\r\nfunction scryptOutput(password, dkLen, B, V, tmp) {\r\n    const res = pbkdf2$1(sha256$1, password, B, {\r\n        c: 1,\r\n        dkLen: dkLen,\r\n    })\r\n    B.fill(0)\r\n    V.fill(0)\r\n    tmp.fill(0)\r\n    return res\r\n}\r\nfunction scrypt$1(password, salt, opts) {\r\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } =\r\n        scryptInit(password, salt, opts)\r\n    for (let pi = 0; pi < p; pi++) {\r\n        const Pi = blockSize32 * pi\r\n        for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]\r\n        for (let i = 0, pos = 0; i < N - 1; i++) {\r\n            BlockMix(V, pos, V, (pos += blockSize32), r)\r\n            blockMixCb()\r\n        }\r\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r)\r\n        blockMixCb()\r\n        for (let i = 0; i < N; i++) {\r\n            const j = B32[Pi + blockSize32 - 16] % N\r\n            for (let k = 0; k < blockSize32; k++)\r\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]\r\n            BlockMix(tmp, 0, B32, Pi, r)\r\n            blockMixCb()\r\n        }\r\n    }\r\n    return scryptOutput(password, dkLen, B, V, tmp)\r\n}\r\nasync function scryptAsync(password, salt, opts) {\r\n    const {\r\n        N,\r\n        r,\r\n        p,\r\n        dkLen,\r\n        blockSize32,\r\n        V,\r\n        B32,\r\n        B,\r\n        tmp,\r\n        blockMixCb,\r\n        asyncTick,\r\n    } = scryptInit(password, salt, opts)\r\n    for (let pi = 0; pi < p; pi++) {\r\n        const Pi = blockSize32 * pi\r\n        for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]\r\n        let pos = 0\r\n        await asyncLoop(N - 1, asyncTick, () => {\r\n            BlockMix(V, pos, V, (pos += blockSize32), r)\r\n            blockMixCb()\r\n        })\r\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r)\r\n        blockMixCb()\r\n        await asyncLoop(N, asyncTick, () => {\r\n            const j = B32[Pi + blockSize32 - 16] % N\r\n            for (let k = 0; k < blockSize32; k++)\r\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]\r\n            BlockMix(tmp, 0, B32, Pi, r)\r\n            blockMixCb()\r\n        })\r\n    }\r\n    return scryptOutput(password, dkLen, B, V, tmp)\r\n}\r\nlet lockedSync = false,\r\n    lockedAsync = false\r\nconst _scryptAsync = async function (passwd, salt, N, r, p, dkLen, onProgress) {\r\n    return await scryptAsync(passwd, salt, {\r\n        N: N,\r\n        r: r,\r\n        p: p,\r\n        dkLen: dkLen,\r\n        onProgress: onProgress,\r\n    })\r\n}\r\nconst _scryptSync = function (passwd, salt, N, r, p, dkLen) {\r\n    return scrypt$1(passwd, salt, {\r\n        N: N,\r\n        r: r,\r\n        p: p,\r\n        dkLen: dkLen,\r\n    })\r\n}\r\nlet __scryptAsync = _scryptAsync\r\nlet __scryptSync = _scryptSync\r\nasync function scrypt(_passwd, _salt, N, r, p, dkLen, progress) {\r\n    const passwd = getBytes(_passwd, \"passwd\")\r\n    const salt = getBytes(_salt, \"salt\")\r\n    return hexlify(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress))\r\n}\r\nscrypt._ = _scryptAsync\r\nscrypt.lock = function () {\r\n    lockedAsync = true\r\n}\r\nscrypt.register = function (func) {\r\n    if (lockedAsync) {\r\n        throw new Error(\"scrypt is locked\")\r\n    }\r\n    __scryptAsync = func\r\n}\r\nObject.freeze(scrypt)\r\nfunction scryptSync(_passwd, _salt, N, r, p, dkLen) {\r\n    const passwd = getBytes(_passwd, \"passwd\")\r\n    const salt = getBytes(_salt, \"salt\")\r\n    return hexlify(__scryptSync(passwd, salt, N, r, p, dkLen))\r\n}\r\nscryptSync._ = _scryptSync\r\nscryptSync.lock = function () {\r\n    lockedSync = true\r\n}\r\nscryptSync.register = function (func) {\r\n    if (lockedSync) {\r\n        throw new Error(\"scryptSync is locked\")\r\n    }\r\n    __scryptSync = func\r\n}\r\nObject.freeze(scryptSync)\r\nconst _sha256 = function (data) {\r\n    return createHash(\"sha256\").update(data).digest()\r\n}\r\nconst _sha512 = function (data) {\r\n    return createHash(\"sha512\").update(data).digest()\r\n}\r\nlet __sha256 = _sha256\r\nlet __sha512 = _sha512\r\nlet locked256 = false,\r\n    locked512 = false\r\nfunction sha256(_data) {\r\n    const data = getBytes(_data, \"data\")\r\n    return hexlify(__sha256(data))\r\n}\r\nsha256._ = _sha256\r\nsha256.lock = function () {\r\n    locked256 = true\r\n}\r\nsha256.register = function (func) {\r\n    if (locked256) {\r\n        throw new Error(\"sha256 is locked\")\r\n    }\r\n    __sha256 = func\r\n}\r\nObject.freeze(sha256)\r\nfunction sha512(_data) {\r\n    const data = getBytes(_data, \"data\")\r\n    return hexlify(__sha512(data))\r\n}\r\nsha512._ = _sha512\r\nsha512.lock = function () {\r\n    locked512 = true\r\n}\r\nsha512.register = function (func) {\r\n    if (locked512) {\r\n        throw new Error(\"sha512 is locked\")\r\n    }\r\n    __sha512 = func\r\n}\r\nObject.freeze(sha256)\r\nconst _0n$3 = BigInt(0)\r\nconst _1n$4 = BigInt(1)\r\nconst _2n$2 = BigInt(2)\r\nconst u8a = (a) => a instanceof Uint8Array\r\nconst hexes = Array.from(\r\n    {\r\n        length: 256,\r\n    },\r\n    (_, i) => i.toString(16).padStart(2, \"0\"),\r\n)\r\nfunction bytesToHex(bytes) {\r\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\")\r\n    let hex = \"\"\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        hex += hexes[bytes[i]]\r\n    }\r\n    return hex\r\n}\r\nfunction numberToHexUnpadded(num) {\r\n    const hex = num.toString(16)\r\n    return hex.length & 1 ? `0${hex}` : hex\r\n}\r\nfunction hexToNumber(hex) {\r\n    if (typeof hex !== \"string\")\r\n        throw new Error(\"hex string expected, got \" + typeof hex)\r\n    return BigInt(hex === \"\" ? \"0\" : `0x${hex}`)\r\n}\r\nfunction hexToBytes(hex) {\r\n    if (typeof hex !== \"string\")\r\n        throw new Error(\"hex string expected, got \" + typeof hex)\r\n    const len = hex.length\r\n    if (len % 2)\r\n        throw new Error(\r\n            \"padded hex string expected, got unpadded hex of length \" + len,\r\n        )\r\n    const array = new Uint8Array(len / 2)\r\n    for (let i = 0; i < array.length; i++) {\r\n        const j = i * 2\r\n        const hexByte = hex.slice(j, j + 2)\r\n        const byte = Number.parseInt(hexByte, 16)\r\n        if (Number.isNaN(byte) || byte < 0)\r\n            throw new Error(\"Invalid byte sequence\")\r\n        array[i] = byte\r\n    }\r\n    return array\r\n}\r\nfunction bytesToNumberBE(bytes) {\r\n    return hexToNumber(bytesToHex(bytes))\r\n}\r\nfunction bytesToNumberLE(bytes) {\r\n    if (!u8a(bytes)) throw new Error(\"Uint8Array expected\")\r\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()))\r\n}\r\nfunction numberToBytesBE(n, len) {\r\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"))\r\n}\r\nfunction numberToBytesLE(n, len) {\r\n    return numberToBytesBE(n, len).reverse()\r\n}\r\nfunction numberToVarBytesBE(n) {\r\n    return hexToBytes(numberToHexUnpadded(n))\r\n}\r\nfunction ensureBytes(title, hex, expectedLength) {\r\n    let res\r\n    if (typeof hex === \"string\") {\r\n        try {\r\n            res = hexToBytes(hex)\r\n        } catch (e) {\r\n            throw new Error(\r\n                `${title} must be valid hex string, got \"${hex}\". Cause: ${e}`,\r\n            )\r\n        }\r\n    } else if (u8a(hex)) {\r\n        res = Uint8Array.from(hex)\r\n    } else {\r\n        throw new Error(`${title} must be hex string or Uint8Array`)\r\n    }\r\n    const len = res.length\r\n    if (typeof expectedLength === \"number\" && len !== expectedLength)\r\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`)\r\n    return res\r\n}\r\nfunction concatBytes(...arrays) {\r\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0))\r\n    let pad = 0\r\n    arrays.forEach((a) => {\r\n        if (!u8a(a)) throw new Error(\"Uint8Array expected\")\r\n        r.set(a, pad)\r\n        pad += a.length\r\n    })\r\n    return r\r\n}\r\nfunction equalBytes(b1, b2) {\r\n    if (b1.length !== b2.length) return false\r\n    for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false\r\n    return true\r\n}\r\nfunction utf8ToBytes(str) {\r\n    if (typeof str !== \"string\")\r\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`)\r\n    return new Uint8Array(new TextEncoder().encode(str))\r\n}\r\nfunction bitLen(n) {\r\n    let len\r\n    for (len = 0; n > _0n$3; n >>= _1n$4, len += 1);\r\n    return len\r\n}\r\nfunction bitGet(n, pos) {\r\n    return (n >> BigInt(pos)) & _1n$4\r\n}\r\nconst bitSet = (n, pos, value) => {\r\n    return n | ((value ? _1n$4 : _0n$3) << BigInt(pos))\r\n}\r\nconst bitMask = (n) => (_2n$2 << BigInt(n - 1)) - _1n$4\r\nconst u8n = (data) => new Uint8Array(data)\r\nconst u8fr = (arr) => Uint8Array.from(arr)\r\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\r\n    if (typeof hashLen !== \"number\" || hashLen < 2)\r\n        throw new Error(\"hashLen must be a number\")\r\n    if (typeof qByteLen !== \"number\" || qByteLen < 2)\r\n        throw new Error(\"qByteLen must be a number\")\r\n    if (typeof hmacFn !== \"function\")\r\n        throw new Error(\"hmacFn must be a function\")\r\n    let v = u8n(hashLen)\r\n    let k = u8n(hashLen)\r\n    let i = 0\r\n    const reset = () => {\r\n        v.fill(1)\r\n        k.fill(0)\r\n        i = 0\r\n    }\r\n    const h = (...b) => hmacFn(k, v, ...b)\r\n    const reseed = (seed = u8n()) => {\r\n        k = h(u8fr([0]), seed)\r\n        v = h()\r\n        if (seed.length === 0) return\r\n        k = h(u8fr([1]), seed)\r\n        v = h()\r\n    }\r\n    const gen = () => {\r\n        if (i++ >= 1e3) throw new Error(\"drbg: tried 1000 values\")\r\n        let len = 0\r\n        const out = []\r\n        while (len < qByteLen) {\r\n            v = h()\r\n            const sl = v.slice()\r\n            out.push(sl)\r\n            len += v.length\r\n        }\r\n        return concatBytes(...out)\r\n    }\r\n    const genUntil = (seed, pred) => {\r\n        reset()\r\n        reseed(seed)\r\n        let res = undefined\r\n        while (!(res = pred(gen()))) reseed()\r\n        reset()\r\n        return res\r\n    }\r\n    return genUntil\r\n}\r\nconst validatorFns = {\r\n    bigint: (val) => typeof val === \"bigint\",\r\n    function: (val) => typeof val === \"function\",\r\n    boolean: (val) => typeof val === \"boolean\",\r\n    string: (val) => typeof val === \"string\",\r\n    stringOrUint8Array: (val) =>\r\n        typeof val === \"string\" || val instanceof Uint8Array,\r\n    isSafeInteger: (val) => Number.isSafeInteger(val),\r\n    array: (val) => Array.isArray(val),\r\n    field: (val, object) => object.Fp.isValid(val),\r\n    hash: (val) =>\r\n        typeof val === \"function\" && Number.isSafeInteger(val.outputLen),\r\n}\r\nfunction validateObject(object, validators, optValidators = {}) {\r\n    const checkField = (fieldName, type, isOptional) => {\r\n        const checkVal = validatorFns[type]\r\n        if (typeof checkVal !== \"function\")\r\n            throw new Error(`Invalid validator \"${type}\", expected function`)\r\n        const val = object[fieldName]\r\n        if (isOptional && val === undefined) return\r\n        if (!checkVal(val, object)) {\r\n            throw new Error(\r\n                `Invalid param ${String(\r\n                    fieldName,\r\n                )}=${val} (${typeof val}), expected ${type}`,\r\n            )\r\n        }\r\n    }\r\n    for (const [fieldName, type] of Object.entries(validators))\r\n        checkField(fieldName, type, false)\r\n    for (const [fieldName, type] of Object.entries(optValidators))\r\n        checkField(fieldName, type, true)\r\n    return object\r\n}\r\nvar ut = Object.freeze({\r\n    __proto__: null,\r\n    bitGet: bitGet,\r\n    bitLen: bitLen,\r\n    bitMask: bitMask,\r\n    bitSet: bitSet,\r\n    bytesToHex: bytesToHex,\r\n    bytesToNumberBE: bytesToNumberBE,\r\n    bytesToNumberLE: bytesToNumberLE,\r\n    concatBytes: concatBytes,\r\n    createHmacDrbg: createHmacDrbg,\r\n    ensureBytes: ensureBytes,\r\n    equalBytes: equalBytes,\r\n    hexToBytes: hexToBytes,\r\n    hexToNumber: hexToNumber,\r\n    numberToBytesBE: numberToBytesBE,\r\n    numberToBytesLE: numberToBytesLE,\r\n    numberToHexUnpadded: numberToHexUnpadded,\r\n    numberToVarBytesBE: numberToVarBytesBE,\r\n    utf8ToBytes: utf8ToBytes,\r\n    validateObject: validateObject,\r\n})\r\nconst _0n$2 = BigInt(0),\r\n    _1n$3 = BigInt(1),\r\n    _2n$1 = BigInt(2),\r\n    _3n$1 = BigInt(3)\r\nconst _4n = BigInt(4),\r\n    _5n = BigInt(5),\r\n    _8n = BigInt(8)\r\nBigInt(9)\r\nBigInt(16)\r\nfunction mod(a, b) {\r\n    const result = a % b\r\n    return result >= _0n$2 ? result : b + result\r\n}\r\nfunction pow(num, power, modulo) {\r\n    if (modulo <= _0n$2 || power < _0n$2)\r\n        throw new Error(\"Expected power/modulo > 0\")\r\n    if (modulo === _1n$3) return _0n$2\r\n    let res = _1n$3\r\n    while (power > _0n$2) {\r\n        if (power & _1n$3) res = (res * num) % modulo\r\n        num = (num * num) % modulo\r\n        power >>= _1n$3\r\n    }\r\n    return res\r\n}\r\nfunction pow2(x, power, modulo) {\r\n    let res = x\r\n    while (power-- > _0n$2) {\r\n        res *= res\r\n        res %= modulo\r\n    }\r\n    return res\r\n}\r\nfunction invert(number, modulo) {\r\n    if (number === _0n$2 || modulo <= _0n$2) {\r\n        throw new Error(\r\n            `invert: expected positive integers, got n=${number} mod=${modulo}`,\r\n        )\r\n    }\r\n    let a = mod(number, modulo)\r\n    let b = modulo\r\n    let x = _0n$2,\r\n        u = _1n$3\r\n    while (a !== _0n$2) {\r\n        const q = b / a\r\n        const r = b % a\r\n        const m = x - u * q\r\n        ;(b = a), (a = r), (x = u), (u = m)\r\n    }\r\n    const gcd = b\r\n    if (gcd !== _1n$3) throw new Error(\"invert: does not exist\")\r\n    return mod(x, modulo)\r\n}\r\nfunction tonelliShanks(P) {\r\n    const legendreC = (P - _1n$3) / _2n$1\r\n    let Q, S, Z\r\n    for (Q = P - _1n$3, S = 0; Q % _2n$1 === _0n$2; Q /= _2n$1, S++);\r\n    for (Z = _2n$1; Z < P && pow(Z, legendreC, P) !== P - _1n$3; Z++);\r\n    if (S === 1) {\r\n        const p1div4 = (P + _1n$3) / _4n\r\n        return function tonelliFast(Fp, n) {\r\n            const root = Fp.pow(n, p1div4)\r\n            if (!Fp.eql(Fp.sqr(root), n))\r\n                throw new Error(\"Cannot find square root\")\r\n            return root\r\n        }\r\n    }\r\n    const Q1div2 = (Q + _1n$3) / _2n$1\r\n    return function tonelliSlow(Fp, n) {\r\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\r\n            throw new Error(\"Cannot find square root\")\r\n        let r = S\r\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q)\r\n        let x = Fp.pow(n, Q1div2)\r\n        let b = Fp.pow(n, Q)\r\n        while (!Fp.eql(b, Fp.ONE)) {\r\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO\r\n            let m = 1\r\n            for (let t2 = Fp.sqr(b); m < r; m++) {\r\n                if (Fp.eql(t2, Fp.ONE)) break\r\n                t2 = Fp.sqr(t2)\r\n            }\r\n            const ge = Fp.pow(g, _1n$3 << BigInt(r - m - 1))\r\n            g = Fp.sqr(ge)\r\n            x = Fp.mul(x, ge)\r\n            b = Fp.mul(b, g)\r\n            r = m\r\n        }\r\n        return x\r\n    }\r\n}\r\nfunction FpSqrt(P) {\r\n    if (P % _4n === _3n$1) {\r\n        const p1div4 = (P + _1n$3) / _4n\r\n        return function sqrt3mod4(Fp, n) {\r\n            const root = Fp.pow(n, p1div4)\r\n            if (!Fp.eql(Fp.sqr(root), n))\r\n                throw new Error(\"Cannot find square root\")\r\n            return root\r\n        }\r\n    }\r\n    if (P % _8n === _5n) {\r\n        const c1 = (P - _5n) / _8n\r\n        return function sqrt5mod8(Fp, n) {\r\n            const n2 = Fp.mul(n, _2n$1)\r\n            const v = Fp.pow(n2, c1)\r\n            const nv = Fp.mul(n, v)\r\n            const i = Fp.mul(Fp.mul(nv, _2n$1), v)\r\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE))\r\n            if (!Fp.eql(Fp.sqr(root), n))\r\n                throw new Error(\"Cannot find square root\")\r\n            return root\r\n        }\r\n    }\r\n    return tonelliShanks(P)\r\n}\r\nconst FIELD_FIELDS = [\r\n    \"create\",\r\n    \"isValid\",\r\n    \"is0\",\r\n    \"neg\",\r\n    \"inv\",\r\n    \"sqrt\",\r\n    \"sqr\",\r\n    \"eql\",\r\n    \"add\",\r\n    \"sub\",\r\n    \"mul\",\r\n    \"pow\",\r\n    \"div\",\r\n    \"addN\",\r\n    \"subN\",\r\n    \"mulN\",\r\n    \"sqrN\",\r\n]\r\nfunction validateField(field) {\r\n    const initial = {\r\n        ORDER: \"bigint\",\r\n        MASK: \"bigint\",\r\n        BYTES: \"isSafeInteger\",\r\n        BITS: \"isSafeInteger\",\r\n    }\r\n    const opts = FIELD_FIELDS.reduce((map, val) => {\r\n        map[val] = \"function\"\r\n        return map\r\n    }, initial)\r\n    return validateObject(field, opts)\r\n}\r\nfunction FpPow(f, num, power) {\r\n    if (power < _0n$2) throw new Error(\"Expected power > 0\")\r\n    if (power === _0n$2) return f.ONE\r\n    if (power === _1n$3) return num\r\n    let p = f.ONE\r\n    let d = num\r\n    while (power > _0n$2) {\r\n        if (power & _1n$3) p = f.mul(p, d)\r\n        d = f.sqr(d)\r\n        power >>= _1n$3\r\n    }\r\n    return p\r\n}\r\nfunction FpInvertBatch(f, nums) {\r\n    const tmp = new Array(nums.length)\r\n    const lastMultiplied = nums.reduce((acc, num, i) => {\r\n        if (f.is0(num)) return acc\r\n        tmp[i] = acc\r\n        return f.mul(acc, num)\r\n    }, f.ONE)\r\n    const inverted = f.inv(lastMultiplied)\r\n    nums.reduceRight((acc, num, i) => {\r\n        if (f.is0(num)) return acc\r\n        tmp[i] = f.mul(acc, tmp[i])\r\n        return f.mul(acc, num)\r\n    }, inverted)\r\n    return tmp\r\n}\r\nfunction nLength(n, nBitLength) {\r\n    const _nBitLength =\r\n        nBitLength !== undefined ? nBitLength : n.toString(2).length\r\n    const nByteLength = Math.ceil(_nBitLength / 8)\r\n    return {\r\n        nBitLength: _nBitLength,\r\n        nByteLength: nByteLength,\r\n    }\r\n}\r\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\r\n    if (ORDER <= _0n$2)\r\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`)\r\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen)\r\n    if (BYTES > 2048)\r\n        throw new Error(\"Field lengths over 2048 bytes are not supported\")\r\n    const sqrtP = FpSqrt(ORDER)\r\n    const f = Object.freeze({\r\n        ORDER: ORDER,\r\n        BITS: BITS,\r\n        BYTES: BYTES,\r\n        MASK: bitMask(BITS),\r\n        ZERO: _0n$2,\r\n        ONE: _1n$3,\r\n        create: (num) => mod(num, ORDER),\r\n        isValid: (num) => {\r\n            if (typeof num !== \"bigint\")\r\n                throw new Error(\r\n                    `Invalid field element: expected bigint, got ${typeof num}`,\r\n                )\r\n            return _0n$2 <= num && num < ORDER\r\n        },\r\n        is0: (num) => num === _0n$2,\r\n        isOdd: (num) => (num & _1n$3) === _1n$3,\r\n        neg: (num) => mod(-num, ORDER),\r\n        eql: (lhs, rhs) => lhs === rhs,\r\n        sqr: (num) => mod(num * num, ORDER),\r\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\r\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\r\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\r\n        pow: (num, power) => FpPow(f, num, power),\r\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\r\n        sqrN: (num) => num * num,\r\n        addN: (lhs, rhs) => lhs + rhs,\r\n        subN: (lhs, rhs) => lhs - rhs,\r\n        mulN: (lhs, rhs) => lhs * rhs,\r\n        inv: (num) => invert(num, ORDER),\r\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\r\n        invertBatch: (lst) => FpInvertBatch(f, lst),\r\n        cmov: (a, b, c) => (c ? b : a),\r\n        toBytes: (num) =>\r\n            isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),\r\n        fromBytes: (bytes) => {\r\n            if (bytes.length !== BYTES)\r\n                throw new Error(\r\n                    `Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`,\r\n                )\r\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes)\r\n        },\r\n    })\r\n    return Object.freeze(f)\r\n}\r\nfunction getFieldBytesLength(fieldOrder) {\r\n    if (typeof fieldOrder !== \"bigint\")\r\n        throw new Error(\"field order must be bigint\")\r\n    const bitLength = fieldOrder.toString(2).length\r\n    return Math.ceil(bitLength / 8)\r\n}\r\nfunction getMinHashLength(fieldOrder) {\r\n    const length = getFieldBytesLength(fieldOrder)\r\n    return length + Math.ceil(length / 2)\r\n}\r\nfunction mapHashToField(key, fieldOrder, isLE = false) {\r\n    const len = key.length\r\n    const fieldLen = getFieldBytesLength(fieldOrder)\r\n    const minLen = getMinHashLength(fieldOrder)\r\n    if (len < 16 || len < minLen || len > 1024)\r\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`)\r\n    const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key)\r\n    const reduced = mod(num, fieldOrder - _1n$3) + _1n$3\r\n    return isLE\r\n        ? numberToBytesLE(reduced, fieldLen)\r\n        : numberToBytesBE(reduced, fieldLen)\r\n}\r\nconst _0n$1 = BigInt(0)\r\nconst _1n$2 = BigInt(1)\r\nfunction wNAF(c, bits) {\r\n    const constTimeNegate = (condition, item) => {\r\n        const neg = item.negate()\r\n        return condition ? neg : item\r\n    }\r\n    const opts = (W) => {\r\n        const windows = Math.ceil(bits / W) + 1\r\n        const windowSize = 2 ** (W - 1)\r\n        return {\r\n            windows: windows,\r\n            windowSize: windowSize,\r\n        }\r\n    }\r\n    return {\r\n        constTimeNegate: constTimeNegate,\r\n        unsafeLadder(elm, n) {\r\n            let p = c.ZERO\r\n            let d = elm\r\n            while (n > _0n$1) {\r\n                if (n & _1n$2) p = p.add(d)\r\n                d = d.double()\r\n                n >>= _1n$2\r\n            }\r\n            return p\r\n        },\r\n        precomputeWindow(elm, W) {\r\n            const { windows, windowSize } = opts(W)\r\n            const points = []\r\n            let p = elm\r\n            let base = p\r\n            for (let window = 0; window < windows; window++) {\r\n                base = p\r\n                points.push(base)\r\n                for (let i = 1; i < windowSize; i++) {\r\n                    base = base.add(p)\r\n                    points.push(base)\r\n                }\r\n                p = base.double()\r\n            }\r\n            return points\r\n        },\r\n        wNAF(W, precomputes, n) {\r\n            const { windows, windowSize } = opts(W)\r\n            let p = c.ZERO\r\n            let f = c.BASE\r\n            const mask = BigInt(2 ** W - 1)\r\n            const maxNumber = 2 ** W\r\n            const shiftBy = BigInt(W)\r\n            for (let window = 0; window < windows; window++) {\r\n                const offset = window * windowSize\r\n                let wbits = Number(n & mask)\r\n                n >>= shiftBy\r\n                if (wbits > windowSize) {\r\n                    wbits -= maxNumber\r\n                    n += _1n$2\r\n                }\r\n                const offset1 = offset\r\n                const offset2 = offset + Math.abs(wbits) - 1\r\n                const cond1 = window % 2 !== 0\r\n                const cond2 = wbits < 0\r\n                if (wbits === 0) {\r\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]))\r\n                } else {\r\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]))\r\n                }\r\n            }\r\n            return {\r\n                p: p,\r\n                f: f,\r\n            }\r\n        },\r\n        wNAFCached(P, precomputesMap, n, transform) {\r\n            const W = P._WINDOW_SIZE || 1\r\n            let comp = precomputesMap.get(P)\r\n            if (!comp) {\r\n                comp = this.precomputeWindow(P, W)\r\n                if (W !== 1) {\r\n                    precomputesMap.set(P, transform(comp))\r\n                }\r\n            }\r\n            return this.wNAF(W, comp, n)\r\n        },\r\n    }\r\n}\r\nfunction validateBasic(curve) {\r\n    validateField(curve.Fp)\r\n    validateObject(\r\n        curve,\r\n        {\r\n            n: \"bigint\",\r\n            h: \"bigint\",\r\n            Gx: \"field\",\r\n            Gy: \"field\",\r\n        },\r\n        {\r\n            nBitLength: \"isSafeInteger\",\r\n            nByteLength: \"isSafeInteger\",\r\n        },\r\n    )\r\n    return Object.freeze({\r\n        ...nLength(curve.n, curve.nBitLength),\r\n        ...curve,\r\n        ...{\r\n            p: curve.Fp.ORDER,\r\n        },\r\n    })\r\n}\r\nfunction validatePointOpts(curve) {\r\n    const opts = validateBasic(curve)\r\n    validateObject(\r\n        opts,\r\n        {\r\n            a: \"field\",\r\n            b: \"field\",\r\n        },\r\n        {\r\n            allowedPrivateKeyLengths: \"array\",\r\n            wrapPrivateKey: \"boolean\",\r\n            isTorsionFree: \"function\",\r\n            clearCofactor: \"function\",\r\n            allowInfinityPoint: \"boolean\",\r\n            fromBytes: \"function\",\r\n            toBytes: \"function\",\r\n        },\r\n    )\r\n    const { endo, Fp, a } = opts\r\n    if (endo) {\r\n        if (!Fp.eql(a, Fp.ZERO)) {\r\n            throw new Error(\r\n                \"Endomorphism can only be defined for Koblitz curves that have a=0\",\r\n            )\r\n        }\r\n        if (\r\n            typeof endo !== \"object\" ||\r\n            typeof endo.beta !== \"bigint\" ||\r\n            typeof endo.splitScalar !== \"function\"\r\n        ) {\r\n            throw new Error(\r\n                \"Expected endomorphism with beta: bigint and splitScalar: function\",\r\n            )\r\n        }\r\n    }\r\n    return Object.freeze({\r\n        ...opts,\r\n    })\r\n}\r\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut\r\nconst DER = {\r\n    Err: class DERErr extends Error {\r\n        constructor(m = \"\") {\r\n            super(m)\r\n        }\r\n    },\r\n    _parseInt(data) {\r\n        const { Err: E } = DER\r\n        if (data.length < 2 || data[0] !== 2)\r\n            throw new E(\"Invalid signature integer tag\")\r\n        const len = data[1]\r\n        const res = data.subarray(2, len + 2)\r\n        if (!len || res.length !== len)\r\n            throw new E(\"Invalid signature integer: wrong length\")\r\n        if (res[0] & 128) throw new E(\"Invalid signature integer: negative\")\r\n        if (res[0] === 0 && !(res[1] & 128))\r\n            throw new E(\"Invalid signature integer: unnecessary leading zero\")\r\n        return {\r\n            d: b2n(res),\r\n            l: data.subarray(len + 2),\r\n        }\r\n    },\r\n    toSig(hex) {\r\n        const { Err: E } = DER\r\n        const data = typeof hex === \"string\" ? h2b(hex) : hex\r\n        if (!(data instanceof Uint8Array)) throw new Error(\"ui8a expected\")\r\n        let l = data.length\r\n        if (l < 2 || data[0] != 48) throw new E(\"Invalid signature tag\")\r\n        if (data[1] !== l - 2)\r\n            throw new E(\"Invalid signature: incorrect length\")\r\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2))\r\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes)\r\n        if (rBytesLeft.length)\r\n            throw new E(\"Invalid signature: left bytes after parsing\")\r\n        return {\r\n            r: r,\r\n            s: s,\r\n        }\r\n    },\r\n    hexFromSig(sig) {\r\n        const slice = (s) => (Number.parseInt(s[0], 16) & 8 ? \"00\" + s : s)\r\n        const h = (num) => {\r\n            const hex = num.toString(16)\r\n            return hex.length & 1 ? `0${hex}` : hex\r\n        }\r\n        const s = slice(h(sig.s))\r\n        const r = slice(h(sig.r))\r\n        const shl = s.length / 2\r\n        const rhl = r.length / 2\r\n        const sl = h(shl)\r\n        const rl = h(rhl)\r\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`\r\n    },\r\n}\r\nconst _0n = BigInt(0),\r\n    _1n$1 = BigInt(1)\r\nBigInt(2)\r\nconst _3n = BigInt(3)\r\nBigInt(4)\r\nfunction weierstrassPoints(opts) {\r\n    const CURVE = validatePointOpts(opts)\r\n    const { Fp } = CURVE\r\n    const toBytes =\r\n        CURVE.toBytes ||\r\n        ((_c, point, _isCompressed) => {\r\n            const a = point.toAffine()\r\n            return concatBytes(\r\n                Uint8Array.from([4]),\r\n                Fp.toBytes(a.x),\r\n                Fp.toBytes(a.y),\r\n            )\r\n        })\r\n    const fromBytes =\r\n        CURVE.fromBytes ||\r\n        ((bytes) => {\r\n            const tail = bytes.subarray(1)\r\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES))\r\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES))\r\n            return {\r\n                x: x,\r\n                y: y,\r\n            }\r\n        })\r\n    function weierstrassEquation(x) {\r\n        const { a, b } = CURVE\r\n        const x2 = Fp.sqr(x)\r\n        const x3 = Fp.mul(x2, x)\r\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b)\r\n    }\r\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\r\n        throw new Error(\"bad generator point: equation left != right\")\r\n    function isWithinCurveOrder(num) {\r\n        return typeof num === \"bigint\" && _0n < num && num < CURVE.n\r\n    }\r\n    function assertGE(num) {\r\n        if (!isWithinCurveOrder(num))\r\n            throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\")\r\n    }\r\n    function normPrivateKeyToScalar(key) {\r\n        const {\r\n            allowedPrivateKeyLengths: lengths,\r\n            nByteLength,\r\n            wrapPrivateKey,\r\n            n,\r\n        } = CURVE\r\n        if (lengths && typeof key !== \"bigint\") {\r\n            if (key instanceof Uint8Array) key = bytesToHex(key)\r\n            if (typeof key !== \"string\" || !lengths.includes(key.length))\r\n                throw new Error(\"Invalid key\")\r\n            key = key.padStart(nByteLength * 2, \"0\")\r\n        }\r\n        let num\r\n        try {\r\n            num =\r\n                typeof key === \"bigint\"\r\n                    ? key\r\n                    : bytesToNumberBE(\r\n                          ensureBytes(\"private key\", key, nByteLength),\r\n                      )\r\n        } catch (error) {\r\n            throw new Error(\r\n                `private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`,\r\n            )\r\n        }\r\n        if (wrapPrivateKey) num = mod(num, n)\r\n        assertGE(num)\r\n        return num\r\n    }\r\n    const pointPrecomputes = new Map()\r\n    function assertPrjPoint(other) {\r\n        if (!(other instanceof Point))\r\n            throw new Error(\"ProjectivePoint expected\")\r\n    }\r\n    class Point {\r\n        constructor(px, py, pz) {\r\n            this.px = px\r\n            this.py = py\r\n            this.pz = pz\r\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\")\r\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\")\r\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\")\r\n        }\r\n        static fromAffine(p) {\r\n            const { x, y } = p || {}\r\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\r\n                throw new Error(\"invalid affine point\")\r\n            if (p instanceof Point)\r\n                throw new Error(\"projective point not allowed\")\r\n            const is0 = (i) => Fp.eql(i, Fp.ZERO)\r\n            if (is0(x) && is0(y)) return Point.ZERO\r\n            return new Point(x, y, Fp.ONE)\r\n        }\r\n        get x() {\r\n            return this.toAffine().x\r\n        }\r\n        get y() {\r\n            return this.toAffine().y\r\n        }\r\n        static normalizeZ(points) {\r\n            const toInv = Fp.invertBatch(points.map((p) => p.pz))\r\n            return points\r\n                .map((p, i) => p.toAffine(toInv[i]))\r\n                .map(Point.fromAffine)\r\n        }\r\n        static fromHex(hex) {\r\n            const P = Point.fromAffine(fromBytes(ensureBytes(\"pointHex\", hex)))\r\n            P.assertValidity()\r\n            return P\r\n        }\r\n        static fromPrivateKey(privateKey) {\r\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey))\r\n        }\r\n        _setWindowSize(windowSize) {\r\n            this._WINDOW_SIZE = windowSize\r\n            pointPrecomputes.delete(this)\r\n        }\r\n        assertValidity() {\r\n            if (this.is0()) {\r\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return\r\n                throw new Error(\"bad point: ZERO\")\r\n            }\r\n            const { x, y } = this.toAffine()\r\n            if (!Fp.isValid(x) || !Fp.isValid(y))\r\n                throw new Error(\"bad point: x or y not FE\")\r\n            const left = Fp.sqr(y)\r\n            const right = weierstrassEquation(x)\r\n            if (!Fp.eql(left, right))\r\n                throw new Error(\"bad point: equation left != right\")\r\n            if (!this.isTorsionFree())\r\n                throw new Error(\"bad point: not in prime-order subgroup\")\r\n        }\r\n        hasEvenY() {\r\n            const { y } = this.toAffine()\r\n            if (Fp.isOdd) return !Fp.isOdd(y)\r\n            throw new Error(\"Field doesn't support isOdd\")\r\n        }\r\n        equals(other) {\r\n            assertPrjPoint(other)\r\n            const { px: X1, py: Y1, pz: Z1 } = this\r\n            const { px: X2, py: Y2, pz: Z2 } = other\r\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1))\r\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1))\r\n            return U1 && U2\r\n        }\r\n        negate() {\r\n            return new Point(this.px, Fp.neg(this.py), this.pz)\r\n        }\r\n        double() {\r\n            const { a, b } = CURVE\r\n            const b3 = Fp.mul(b, _3n)\r\n            const { px: X1, py: Y1, pz: Z1 } = this\r\n            let X3 = Fp.ZERO,\r\n                Y3 = Fp.ZERO,\r\n                Z3 = Fp.ZERO\r\n            let t0 = Fp.mul(X1, X1)\r\n            let t1 = Fp.mul(Y1, Y1)\r\n            let t2 = Fp.mul(Z1, Z1)\r\n            let t3 = Fp.mul(X1, Y1)\r\n            t3 = Fp.add(t3, t3)\r\n            Z3 = Fp.mul(X1, Z1)\r\n            Z3 = Fp.add(Z3, Z3)\r\n            X3 = Fp.mul(a, Z3)\r\n            Y3 = Fp.mul(b3, t2)\r\n            Y3 = Fp.add(X3, Y3)\r\n            X3 = Fp.sub(t1, Y3)\r\n            Y3 = Fp.add(t1, Y3)\r\n            Y3 = Fp.mul(X3, Y3)\r\n            X3 = Fp.mul(t3, X3)\r\n            Z3 = Fp.mul(b3, Z3)\r\n            t2 = Fp.mul(a, t2)\r\n            t3 = Fp.sub(t0, t2)\r\n            t3 = Fp.mul(a, t3)\r\n            t3 = Fp.add(t3, Z3)\r\n            Z3 = Fp.add(t0, t0)\r\n            t0 = Fp.add(Z3, t0)\r\n            t0 = Fp.add(t0, t2)\r\n            t0 = Fp.mul(t0, t3)\r\n            Y3 = Fp.add(Y3, t0)\r\n            t2 = Fp.mul(Y1, Z1)\r\n            t2 = Fp.add(t2, t2)\r\n            t0 = Fp.mul(t2, t3)\r\n            X3 = Fp.sub(X3, t0)\r\n            Z3 = Fp.mul(t2, t1)\r\n            Z3 = Fp.add(Z3, Z3)\r\n            Z3 = Fp.add(Z3, Z3)\r\n            return new Point(X3, Y3, Z3)\r\n        }\r\n        add(other) {\r\n            assertPrjPoint(other)\r\n            const { px: X1, py: Y1, pz: Z1 } = this\r\n            const { px: X2, py: Y2, pz: Z2 } = other\r\n            let X3 = Fp.ZERO,\r\n                Y3 = Fp.ZERO,\r\n                Z3 = Fp.ZERO\r\n            const a = CURVE.a\r\n            const b3 = Fp.mul(CURVE.b, _3n)\r\n            let t0 = Fp.mul(X1, X2)\r\n            let t1 = Fp.mul(Y1, Y2)\r\n            let t2 = Fp.mul(Z1, Z2)\r\n            let t3 = Fp.add(X1, Y1)\r\n            let t4 = Fp.add(X2, Y2)\r\n            t3 = Fp.mul(t3, t4)\r\n            t4 = Fp.add(t0, t1)\r\n            t3 = Fp.sub(t3, t4)\r\n            t4 = Fp.add(X1, Z1)\r\n            let t5 = Fp.add(X2, Z2)\r\n            t4 = Fp.mul(t4, t5)\r\n            t5 = Fp.add(t0, t2)\r\n            t4 = Fp.sub(t4, t5)\r\n            t5 = Fp.add(Y1, Z1)\r\n            X3 = Fp.add(Y2, Z2)\r\n            t5 = Fp.mul(t5, X3)\r\n            X3 = Fp.add(t1, t2)\r\n            t5 = Fp.sub(t5, X3)\r\n            Z3 = Fp.mul(a, t4)\r\n            X3 = Fp.mul(b3, t2)\r\n            Z3 = Fp.add(X3, Z3)\r\n            X3 = Fp.sub(t1, Z3)\r\n            Z3 = Fp.add(t1, Z3)\r\n            Y3 = Fp.mul(X3, Z3)\r\n            t1 = Fp.add(t0, t0)\r\n            t1 = Fp.add(t1, t0)\r\n            t2 = Fp.mul(a, t2)\r\n            t4 = Fp.mul(b3, t4)\r\n            t1 = Fp.add(t1, t2)\r\n            t2 = Fp.sub(t0, t2)\r\n            t2 = Fp.mul(a, t2)\r\n            t4 = Fp.add(t4, t2)\r\n            t0 = Fp.mul(t1, t4)\r\n            Y3 = Fp.add(Y3, t0)\r\n            t0 = Fp.mul(t5, t4)\r\n            X3 = Fp.mul(t3, X3)\r\n            X3 = Fp.sub(X3, t0)\r\n            t0 = Fp.mul(t3, t1)\r\n            Z3 = Fp.mul(t5, Z3)\r\n            Z3 = Fp.add(Z3, t0)\r\n            return new Point(X3, Y3, Z3)\r\n        }\r\n        subtract(other) {\r\n            return this.add(other.negate())\r\n        }\r\n        is0() {\r\n            return this.equals(Point.ZERO)\r\n        }\r\n        wNAF(n) {\r\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\r\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz))\r\n                return comp\r\n                    .map((p, i) => p.toAffine(toInv[i]))\r\n                    .map(Point.fromAffine)\r\n            })\r\n        }\r\n        multiplyUnsafe(n) {\r\n            const I = Point.ZERO\r\n            if (n === _0n) return I\r\n            assertGE(n)\r\n            if (n === _1n$1) return this\r\n            const { endo } = CURVE\r\n            if (!endo) return wnaf.unsafeLadder(this, n)\r\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n)\r\n            let k1p = I\r\n            let k2p = I\r\n            let d = this\r\n            while (k1 > _0n || k2 > _0n) {\r\n                if (k1 & _1n$1) k1p = k1p.add(d)\r\n                if (k2 & _1n$1) k2p = k2p.add(d)\r\n                d = d.double()\r\n                k1 >>= _1n$1\r\n                k2 >>= _1n$1\r\n            }\r\n            if (k1neg) k1p = k1p.negate()\r\n            if (k2neg) k2p = k2p.negate()\r\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz)\r\n            return k1p.add(k2p)\r\n        }\r\n        multiply(scalar) {\r\n            assertGE(scalar)\r\n            let n = scalar\r\n            let point, fake\r\n            const { endo } = CURVE\r\n            if (endo) {\r\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n)\r\n                let { p: k1p, f: f1p } = this.wNAF(k1)\r\n                let { p: k2p, f: f2p } = this.wNAF(k2)\r\n                k1p = wnaf.constTimeNegate(k1neg, k1p)\r\n                k2p = wnaf.constTimeNegate(k2neg, k2p)\r\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz)\r\n                point = k1p.add(k2p)\r\n                fake = f1p.add(f2p)\r\n            } else {\r\n                const { p, f } = this.wNAF(n)\r\n                point = p\r\n                fake = f\r\n            }\r\n            return Point.normalizeZ([point, fake])[0]\r\n        }\r\n        multiplyAndAddUnsafe(Q, a, b) {\r\n            const G = Point.BASE\r\n            const mul = (P, a) =>\r\n                a === _0n || a === _1n$1 || !P.equals(G)\r\n                    ? P.multiplyUnsafe(a)\r\n                    : P.multiply(a)\r\n            const sum = mul(this, a).add(mul(Q, b))\r\n            return sum.is0() ? undefined : sum\r\n        }\r\n        toAffine(iz) {\r\n            const { px: x, py: y, pz: z } = this\r\n            const is0 = this.is0()\r\n            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z)\r\n            const ax = Fp.mul(x, iz)\r\n            const ay = Fp.mul(y, iz)\r\n            const zz = Fp.mul(z, iz)\r\n            if (is0)\r\n                return {\r\n                    x: Fp.ZERO,\r\n                    y: Fp.ZERO,\r\n                }\r\n            if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\")\r\n            return {\r\n                x: ax,\r\n                y: ay,\r\n            }\r\n        }\r\n        isTorsionFree() {\r\n            const { h: cofactor, isTorsionFree } = CURVE\r\n            if (cofactor === _1n$1) return true\r\n            if (isTorsionFree) return isTorsionFree(Point, this)\r\n            throw new Error(\r\n                \"isTorsionFree() has not been declared for the elliptic curve\",\r\n            )\r\n        }\r\n        clearCofactor() {\r\n            const { h: cofactor, clearCofactor } = CURVE\r\n            if (cofactor === _1n$1) return this\r\n            if (clearCofactor) return clearCofactor(Point, this)\r\n            return this.multiplyUnsafe(CURVE.h)\r\n        }\r\n        toRawBytes(isCompressed = true) {\r\n            this.assertValidity()\r\n            return toBytes(Point, this, isCompressed)\r\n        }\r\n        toHex(isCompressed = true) {\r\n            return bytesToHex(this.toRawBytes(isCompressed))\r\n        }\r\n    }\r\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE)\r\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO)\r\n    const _bits = CURVE.nBitLength\r\n    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits)\r\n    return {\r\n        CURVE: CURVE,\r\n        ProjectivePoint: Point,\r\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\r\n        weierstrassEquation: weierstrassEquation,\r\n        isWithinCurveOrder: isWithinCurveOrder,\r\n    }\r\n}\r\nfunction validateOpts(curve) {\r\n    const opts = validateBasic(curve)\r\n    validateObject(\r\n        opts,\r\n        {\r\n            hash: \"hash\",\r\n            hmac: \"function\",\r\n            randomBytes: \"function\",\r\n        },\r\n        {\r\n            bits2int: \"function\",\r\n            bits2int_modN: \"function\",\r\n            lowS: \"boolean\",\r\n        },\r\n    )\r\n    return Object.freeze({\r\n        lowS: true,\r\n        ...opts,\r\n    })\r\n}\r\nfunction weierstrass(curveDef) {\r\n    const CURVE = validateOpts(curveDef)\r\n    const { Fp, n: CURVE_ORDER } = CURVE\r\n    const compressedLen = Fp.BYTES + 1\r\n    const uncompressedLen = 2 * Fp.BYTES + 1\r\n    function isValidFieldElement(num) {\r\n        return _0n < num && num < Fp.ORDER\r\n    }\r\n    function modN(a) {\r\n        return mod(a, CURVE_ORDER)\r\n    }\r\n    function invN(a) {\r\n        return invert(a, CURVE_ORDER)\r\n    }\r\n    const {\r\n        ProjectivePoint: Point,\r\n        normPrivateKeyToScalar,\r\n        weierstrassEquation,\r\n        isWithinCurveOrder,\r\n    } = weierstrassPoints({\r\n        ...CURVE,\r\n        toBytes(_c, point, isCompressed) {\r\n            const a = point.toAffine()\r\n            const x = Fp.toBytes(a.x)\r\n            const cat = concatBytes\r\n            if (isCompressed) {\r\n                return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x)\r\n            } else {\r\n                return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y))\r\n            }\r\n        },\r\n        fromBytes(bytes) {\r\n            const len = bytes.length\r\n            const head = bytes[0]\r\n            const tail = bytes.subarray(1)\r\n            if (len === compressedLen && (head === 2 || head === 3)) {\r\n                const x = bytesToNumberBE(tail)\r\n                if (!isValidFieldElement(x))\r\n                    throw new Error(\"Point is not on curve\")\r\n                const y2 = weierstrassEquation(x)\r\n                let y = Fp.sqrt(y2)\r\n                const isYOdd = (y & _1n$1) === _1n$1\r\n                const isHeadOdd = (head & 1) === 1\r\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y)\r\n                return {\r\n                    x: x,\r\n                    y: y,\r\n                }\r\n            } else if (len === uncompressedLen && head === 4) {\r\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES))\r\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES))\r\n                return {\r\n                    x: x,\r\n                    y: y,\r\n                }\r\n            } else {\r\n                throw new Error(\r\n                    `Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`,\r\n                )\r\n            }\r\n        },\r\n    })\r\n    const numToNByteStr = (num) =>\r\n        bytesToHex(numberToBytesBE(num, CURVE.nByteLength))\r\n    function isBiggerThanHalfOrder(number) {\r\n        const HALF = CURVE_ORDER >> _1n$1\r\n        return number > HALF\r\n    }\r\n    function normalizeS(s) {\r\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s\r\n    }\r\n    const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to))\r\n    class Signature {\r\n        constructor(r, s, recovery) {\r\n            this.r = r\r\n            this.s = s\r\n            this.recovery = recovery\r\n            this.assertValidity()\r\n        }\r\n        static fromCompact(hex) {\r\n            const l = CURVE.nByteLength\r\n            hex = ensureBytes(\"compactSignature\", hex, l * 2)\r\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l))\r\n        }\r\n        static fromDER(hex) {\r\n            const { r, s } = DER.toSig(ensureBytes(\"DER\", hex))\r\n            return new Signature(r, s)\r\n        }\r\n        assertValidity() {\r\n            if (!isWithinCurveOrder(this.r))\r\n                throw new Error(\"r must be 0 < r < CURVE.n\")\r\n            if (!isWithinCurveOrder(this.s))\r\n                throw new Error(\"s must be 0 < s < CURVE.n\")\r\n        }\r\n        addRecoveryBit(recovery) {\r\n            return new Signature(this.r, this.s, recovery)\r\n        }\r\n        recoverPublicKey(msgHash) {\r\n            const { r, s, recovery: rec } = this\r\n            const h = bits2int_modN(ensureBytes(\"msgHash\", msgHash))\r\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\r\n                throw new Error(\"recovery id invalid\")\r\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r\r\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\")\r\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\"\r\n            const R = Point.fromHex(prefix + numToNByteStr(radj))\r\n            const ir = invN(radj)\r\n            const u1 = modN(-h * ir)\r\n            const u2 = modN(s * ir)\r\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2)\r\n            if (!Q) throw new Error(\"point at infinify\")\r\n            Q.assertValidity()\r\n            return Q\r\n        }\r\n        hasHighS() {\r\n            return isBiggerThanHalfOrder(this.s)\r\n        }\r\n        normalizeS() {\r\n            return this.hasHighS()\r\n                ? new Signature(this.r, modN(-this.s), this.recovery)\r\n                : this\r\n        }\r\n        toDERRawBytes() {\r\n            return hexToBytes(this.toDERHex())\r\n        }\r\n        toDERHex() {\r\n            return DER.hexFromSig({\r\n                r: this.r,\r\n                s: this.s,\r\n            })\r\n        }\r\n        toCompactRawBytes() {\r\n            return hexToBytes(this.toCompactHex())\r\n        }\r\n        toCompactHex() {\r\n            return numToNByteStr(this.r) + numToNByteStr(this.s)\r\n        }\r\n    }\r\n    const utils = {\r\n        isValidPrivateKey(privateKey) {\r\n            try {\r\n                normPrivateKeyToScalar(privateKey)\r\n                return true\r\n            } catch (error) {\r\n                return false\r\n            }\r\n        },\r\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\r\n        randomPrivateKey: () => {\r\n            const length = getMinHashLength(CURVE.n)\r\n            return mapHashToField(CURVE.randomBytes(length), CURVE.n)\r\n        },\r\n        precompute(windowSize = 8, point = Point.BASE) {\r\n            point._setWindowSize(windowSize)\r\n            point.multiply(BigInt(3))\r\n            return point\r\n        },\r\n    }\r\n    function getPublicKey(privateKey, isCompressed = true) {\r\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed)\r\n    }\r\n    function isProbPub(item) {\r\n        const arr = item instanceof Uint8Array\r\n        const str = typeof item === \"string\"\r\n        const len = (arr || str) && item.length\r\n        if (arr) return len === compressedLen || len === uncompressedLen\r\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen\r\n        if (item instanceof Point) return true\r\n        return false\r\n    }\r\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\r\n        if (isProbPub(privateA))\r\n            throw new Error(\"first arg must be private key\")\r\n        if (!isProbPub(publicB))\r\n            throw new Error(\"second arg must be public key\")\r\n        const b = Point.fromHex(publicB)\r\n        return b\r\n            .multiply(normPrivateKeyToScalar(privateA))\r\n            .toRawBytes(isCompressed)\r\n    }\r\n    const bits2int =\r\n        CURVE.bits2int ||\r\n        function (bytes) {\r\n            const num = bytesToNumberBE(bytes)\r\n            const delta = bytes.length * 8 - CURVE.nBitLength\r\n            return delta > 0 ? num >> BigInt(delta) : num\r\n        }\r\n    const bits2int_modN =\r\n        CURVE.bits2int_modN ||\r\n        function (bytes) {\r\n            return modN(bits2int(bytes))\r\n        }\r\n    const ORDER_MASK = bitMask(CURVE.nBitLength)\r\n    function int2octets(num) {\r\n        if (typeof num !== \"bigint\") throw new Error(\"bigint expected\")\r\n        if (!(_0n <= num && num < ORDER_MASK))\r\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`)\r\n        return numberToBytesBE(num, CURVE.nByteLength)\r\n    }\r\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\r\n        if ([\"recovered\", \"canonical\"].some((k) => k in opts))\r\n            throw new Error(\"sign() legacy options not supported\")\r\n        const { hash, randomBytes } = CURVE\r\n        let { lowS, prehash, extraEntropy: ent } = opts\r\n        if (lowS == null) lowS = true\r\n        msgHash = ensureBytes(\"msgHash\", msgHash)\r\n        if (prehash) msgHash = ensureBytes(\"prehashed msgHash\", hash(msgHash))\r\n        const h1int = bits2int_modN(msgHash)\r\n        const d = normPrivateKeyToScalar(privateKey)\r\n        const seedArgs = [int2octets(d), int2octets(h1int)]\r\n        if (ent != null) {\r\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent\r\n            seedArgs.push(ensureBytes(\"extraEntropy\", e))\r\n        }\r\n        const seed = concatBytes(...seedArgs)\r\n        const m = h1int\r\n        function k2sig(kBytes) {\r\n            const k = bits2int(kBytes)\r\n            if (!isWithinCurveOrder(k)) return\r\n            const ik = invN(k)\r\n            const q = Point.BASE.multiply(k).toAffine()\r\n            const r = modN(q.x)\r\n            if (r === _0n) return\r\n            const s = modN(ik * modN(m + r * d))\r\n            if (s === _0n) return\r\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$1)\r\n            let normS = s\r\n            if (lowS && isBiggerThanHalfOrder(s)) {\r\n                normS = normalizeS(s)\r\n                recovery ^= 1\r\n            }\r\n            return new Signature(r, normS, recovery)\r\n        }\r\n        return {\r\n            seed: seed,\r\n            k2sig: k2sig,\r\n        }\r\n    }\r\n    const defaultSigOpts = {\r\n        lowS: CURVE.lowS,\r\n        prehash: false,\r\n    }\r\n    const defaultVerOpts = {\r\n        lowS: CURVE.lowS,\r\n        prehash: false,\r\n    }\r\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\r\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts)\r\n        const C = CURVE\r\n        const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac)\r\n        return drbg(seed, k2sig)\r\n    }\r\n    Point.BASE._setWindowSize(8)\r\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\r\n        const sg = signature\r\n        msgHash = ensureBytes(\"msgHash\", msgHash)\r\n        publicKey = ensureBytes(\"publicKey\", publicKey)\r\n        if (\"strict\" in opts)\r\n            throw new Error(\"options.strict was renamed to lowS\")\r\n        const { lowS, prehash } = opts\r\n        let _sig = undefined\r\n        let P\r\n        try {\r\n            if (typeof sg === \"string\" || sg instanceof Uint8Array) {\r\n                try {\r\n                    _sig = Signature.fromDER(sg)\r\n                } catch (derError) {\r\n                    if (!(derError instanceof DER.Err)) throw derError\r\n                    _sig = Signature.fromCompact(sg)\r\n                }\r\n            } else if (\r\n                typeof sg === \"object\" &&\r\n                typeof sg.r === \"bigint\" &&\r\n                typeof sg.s === \"bigint\"\r\n            ) {\r\n                const { r, s } = sg\r\n                _sig = new Signature(r, s)\r\n            } else {\r\n                throw new Error(\"PARSE\")\r\n            }\r\n            P = Point.fromHex(publicKey)\r\n        } catch (error) {\r\n            if (error.message === \"PARSE\")\r\n                throw new Error(\r\n                    `signature must be Signature instance, Uint8Array or hex string`,\r\n                )\r\n            return false\r\n        }\r\n        if (lowS && _sig.hasHighS()) return false\r\n        if (prehash) msgHash = CURVE.hash(msgHash)\r\n        const { r, s } = _sig\r\n        const h = bits2int_modN(msgHash)\r\n        const is = invN(s)\r\n        const u1 = modN(h * is)\r\n        const u2 = modN(r * is)\r\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine()\r\n        if (!R) return false\r\n        const v = modN(R.x)\r\n        return v === r\r\n    }\r\n    return {\r\n        CURVE: CURVE,\r\n        getPublicKey: getPublicKey,\r\n        getSharedSecret: getSharedSecret,\r\n        sign: sign,\r\n        verify: verify,\r\n        ProjectivePoint: Point,\r\n        Signature: Signature,\r\n        utils: utils,\r\n    }\r\n}\r\nfunction getHash(hash) {\r\n    return {\r\n        hash: hash,\r\n        hmac: (key, ...msgs) => hmac(hash, key, concatBytes$1(...msgs)),\r\n        randomBytes: randomBytes$2,\r\n    }\r\n}\r\nfunction createCurve(curveDef, defHash) {\r\n    const create = (hash) =>\r\n        weierstrass({\r\n            ...curveDef,\r\n            ...getHash(hash),\r\n        })\r\n    return Object.freeze({\r\n        ...create(defHash),\r\n        create: create,\r\n    })\r\n}\r\nconst secp256k1P = BigInt(\r\n    \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\",\r\n)\r\nconst secp256k1N = BigInt(\r\n    \"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\",\r\n)\r\nconst _1n = BigInt(1)\r\nconst _2n = BigInt(2)\r\nconst divNearest = (a, b) => (a + b / _2n) / b\r\nfunction sqrtMod(y) {\r\n    const P = secp256k1P\r\n    const _3n = BigInt(3),\r\n        _6n = BigInt(6),\r\n        _11n = BigInt(11),\r\n        _22n = BigInt(22)\r\n    const _23n = BigInt(23),\r\n        _44n = BigInt(44),\r\n        _88n = BigInt(88)\r\n    const b2 = (y * y * y) % P\r\n    const b3 = (b2 * b2 * y) % P\r\n    const b6 = (pow2(b3, _3n, P) * b3) % P\r\n    const b9 = (pow2(b6, _3n, P) * b3) % P\r\n    const b11 = (pow2(b9, _2n, P) * b2) % P\r\n    const b22 = (pow2(b11, _11n, P) * b11) % P\r\n    const b44 = (pow2(b22, _22n, P) * b22) % P\r\n    const b88 = (pow2(b44, _44n, P) * b44) % P\r\n    const b176 = (pow2(b88, _88n, P) * b88) % P\r\n    const b220 = (pow2(b176, _44n, P) * b44) % P\r\n    const b223 = (pow2(b220, _3n, P) * b3) % P\r\n    const t1 = (pow2(b223, _23n, P) * b22) % P\r\n    const t2 = (pow2(t1, _6n, P) * b2) % P\r\n    const root = pow2(t2, _2n, P)\r\n    if (!Fp.eql(Fp.sqr(root), y)) throw new Error(\"Cannot find square root\")\r\n    return root\r\n}\r\nconst Fp = Field(secp256k1P, undefined, undefined, {\r\n    sqrt: sqrtMod,\r\n})\r\nconst secp256k1 = createCurve(\r\n    {\r\n        a: BigInt(0),\r\n        b: BigInt(7),\r\n        Fp: Fp,\r\n        n: secp256k1N,\r\n        Gx: BigInt(\r\n            \"55066263022277343669578718895168534326250603453777594175500187360389116729240\",\r\n        ),\r\n        Gy: BigInt(\r\n            \"32670510020758816978083085130507043184471273380659243275938904335757337482424\",\r\n        ),\r\n        h: BigInt(1),\r\n        lowS: true,\r\n        endo: {\r\n            beta: BigInt(\r\n                \"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\",\r\n            ),\r\n            splitScalar: (k) => {\r\n                const n = secp256k1N\r\n                const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\")\r\n                const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\")\r\n                const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\")\r\n                const b2 = a1\r\n                const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\")\r\n                const c1 = divNearest(b2 * k, n)\r\n                const c2 = divNearest(-b1 * k, n)\r\n                let k1 = mod(k - c1 * a1 - c2 * a2, n)\r\n                let k2 = mod(-c1 * b1 - c2 * b2, n)\r\n                const k1neg = k1 > POW_2_128\r\n                const k2neg = k2 > POW_2_128\r\n                if (k1neg) k1 = n - k1\r\n                if (k2neg) k2 = n - k2\r\n                if (k1 > POW_2_128 || k2 > POW_2_128) {\r\n                    throw new Error(\"splitScalar: Endomorphism failed, k=\" + k)\r\n                }\r\n                return {\r\n                    k1neg: k1neg,\r\n                    k1: k1,\r\n                    k2neg: k2neg,\r\n                    k2: k2,\r\n                }\r\n            },\r\n        },\r\n    },\r\n    sha256$1,\r\n)\r\nBigInt(0)\r\nsecp256k1.ProjectivePoint\r\nconst ZeroAddress = \"0x0000000000000000000000000000000000000000\"\r\nconst ZeroHash =\r\n    \"0x0000000000000000000000000000000000000000000000000000000000000000\"\r\nconst N$1 = BigInt(\r\n    \"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\",\r\n)\r\nconst WeiPerEther = BigInt(\"1000000000000000000\")\r\nconst MaxUint256 = BigInt(\r\n    \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\r\n)\r\nconst MinInt256 =\r\n    BigInt(\r\n        \"0x8000000000000000000000000000000000000000000000000000000000000000\",\r\n    ) * BigInt(-1)\r\nconst MaxInt256 = BigInt(\r\n    \"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\r\n)\r\nconst EtherSymbol = \"\"\r\nconst MessagePrefix = \"\u0019Ethereum Signed Message:\\n\"\r\nconst BN_0$7 = BigInt(0)\r\nconst BN_1$3 = BigInt(1)\r\nconst BN_2$3 = BigInt(2)\r\nconst BN_27$1 = BigInt(27)\r\nconst BN_28$1 = BigInt(28)\r\nconst BN_35$1 = BigInt(35)\r\nconst _guard$3 = {}\r\nfunction toUint256(value) {\r\n    return zeroPadValue(toBeArray(value), 32)\r\n}\r\nclass Signature {\r\n    #r\r\n    #s\r\n    #v\r\n    #networkV\r\n    get r() {\r\n        return this.#r\r\n    }\r\n    set r(value) {\r\n        assertArgument(dataLength(value) === 32, \"invalid r\", \"value\", value)\r\n        this.#r = hexlify(value)\r\n    }\r\n    get s() {\r\n        return this.#s\r\n    }\r\n    set s(_value) {\r\n        assertArgument(dataLength(_value) === 32, \"invalid s\", \"value\", _value)\r\n        const value = hexlify(_value)\r\n        assertArgument(\r\n            parseInt(value.substring(0, 3)) < 8,\r\n            \"non-canonical s\",\r\n            \"value\",\r\n            value,\r\n        )\r\n        this.#s = value\r\n    }\r\n    get v() {\r\n        return this.#v\r\n    }\r\n    set v(value) {\r\n        const v = getNumber(value, \"value\")\r\n        assertArgument(v === 27 || v === 28, \"invalid v\", \"v\", value)\r\n        this.#v = v\r\n    }\r\n    get networkV() {\r\n        return this.#networkV\r\n    }\r\n    get legacyChainId() {\r\n        const v = this.networkV\r\n        if (v == null) {\r\n            return null\r\n        }\r\n        return Signature.getChainId(v)\r\n    }\r\n    get yParity() {\r\n        return this.v === 27 ? 0 : 1\r\n    }\r\n    get yParityAndS() {\r\n        const yParityAndS = getBytes(this.s)\r\n        if (this.yParity) {\r\n            yParityAndS[0] |= 128\r\n        }\r\n        return hexlify(yParityAndS)\r\n    }\r\n    get compactSerialized() {\r\n        return concat([this.r, this.yParityAndS])\r\n    }\r\n    get serialized() {\r\n        return concat([this.r, this.s, this.yParity ? \"0x1c\" : \"0x1b\"])\r\n    }\r\n    constructor(guard, r, s, v) {\r\n        assertPrivate(guard, _guard$3, \"Signature\")\r\n        this.#r = r\r\n        this.#s = s\r\n        this.#v = v\r\n        this.#networkV = null\r\n    }\r\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\r\n        return `Signature { r: \"${this.r}\", s: \"${this.s}\", yParity: ${this.yParity}, networkV: ${this.networkV} }`\r\n    }\r\n    clone() {\r\n        const clone = new Signature(_guard$3, this.r, this.s, this.v)\r\n        if (this.networkV) {\r\n            clone.#networkV = this.networkV\r\n        }\r\n        return clone\r\n    }\r\n    toJSON() {\r\n        const networkV = this.networkV\r\n        return {\r\n            _type: \"signature\",\r\n            networkV: networkV != null ? networkV.toString() : null,\r\n            r: this.r,\r\n            s: this.s,\r\n            v: this.v,\r\n        }\r\n    }\r\n    static getChainId(v) {\r\n        const bv = getBigInt(v, \"v\")\r\n        if (bv == BN_27$1 || bv == BN_28$1) {\r\n            return BN_0$7\r\n        }\r\n        assertArgument(bv >= BN_35$1, \"invalid EIP-155 v\", \"v\", v)\r\n        return (bv - BN_35$1) / BN_2$3\r\n    }\r\n    static getChainIdV(chainId, v) {\r\n        return getBigInt(chainId) * BN_2$3 + BigInt(35 + v - 27)\r\n    }\r\n    static getNormalizedV(v) {\r\n        const bv = getBigInt(v)\r\n        if (bv === BN_0$7 || bv === BN_27$1) {\r\n            return 27\r\n        }\r\n        if (bv === BN_1$3 || bv === BN_28$1) {\r\n            return 28\r\n        }\r\n        assertArgument(bv >= BN_35$1, \"invalid v\", \"v\", v)\r\n        return bv & BN_1$3 ? 27 : 28\r\n    }\r\n    static from(sig) {\r\n        function assertError(check, message) {\r\n            assertArgument(check, message, \"signature\", sig)\r\n        }\r\n        if (sig == null) {\r\n            return new Signature(_guard$3, ZeroHash, ZeroHash, 27)\r\n        }\r\n        if (typeof sig === \"string\") {\r\n            const bytes = getBytes(sig, \"signature\")\r\n            if (bytes.length === 64) {\r\n                const r = hexlify(bytes.slice(0, 32))\r\n                const s = bytes.slice(32, 64)\r\n                const v = s[0] & 128 ? 28 : 27\r\n                s[0] &= 127\r\n                return new Signature(_guard$3, r, hexlify(s), v)\r\n            }\r\n            if (bytes.length === 65) {\r\n                const r = hexlify(bytes.slice(0, 32))\r\n                const s = bytes.slice(32, 64)\r\n                assertError((s[0] & 128) === 0, \"non-canonical s\")\r\n                const v = Signature.getNormalizedV(bytes[64])\r\n                return new Signature(_guard$3, r, hexlify(s), v)\r\n            }\r\n            assertError(false, \"invalid raw signature length\")\r\n        }\r\n        if (sig instanceof Signature) {\r\n            return sig.clone()\r\n        }\r\n        const _r = sig.r\r\n        assertError(_r != null, \"missing r\")\r\n        const r = toUint256(_r)\r\n        const s = (function (s, yParityAndS) {\r\n            if (s != null) {\r\n                return toUint256(s)\r\n            }\r\n            if (yParityAndS != null) {\r\n                assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\")\r\n                const bytes = getBytes(yParityAndS)\r\n                bytes[0] &= 127\r\n                return hexlify(bytes)\r\n            }\r\n            assertError(false, \"missing s\")\r\n        })(sig.s, sig.yParityAndS)\r\n        assertError((getBytes(s)[0] & 128) == 0, \"non-canonical s\")\r\n        const { networkV, v } = (function (_v, yParityAndS, yParity) {\r\n            if (_v != null) {\r\n                const v = getBigInt(_v)\r\n                return {\r\n                    networkV: v >= BN_35$1 ? v : undefined,\r\n                    v: Signature.getNormalizedV(v),\r\n                }\r\n            }\r\n            if (yParityAndS != null) {\r\n                assertError(isHexString(yParityAndS, 32), \"invalid yParityAndS\")\r\n                return {\r\n                    v: getBytes(yParityAndS)[0] & 128 ? 28 : 27,\r\n                }\r\n            }\r\n            if (yParity != null) {\r\n                switch (getNumber(yParity, \"sig.yParity\")) {\r\n                    case 0:\r\n                        return {\r\n                            v: 27,\r\n                        }\r\n                    case 1:\r\n                        return {\r\n                            v: 28,\r\n                        }\r\n                }\r\n                assertError(false, \"invalid yParity\")\r\n            }\r\n            assertError(false, \"missing v\")\r\n        })(sig.v, sig.yParityAndS, sig.yParity)\r\n        const result = new Signature(_guard$3, r, s, v)\r\n        if (networkV) {\r\n            result.#networkV = networkV\r\n        }\r\n        assertError(\r\n            sig.yParity == null ||\r\n                getNumber(sig.yParity, \"sig.yParity\") === result.yParity,\r\n            \"yParity mismatch\",\r\n        )\r\n        assertError(\r\n            sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS,\r\n            \"yParityAndS mismatch\",\r\n        )\r\n        return result\r\n    }\r\n}\r\nclass SigningKey {\r\n    #privateKey\r\n    constructor(privateKey) {\r\n        assertArgument(\r\n            dataLength(privateKey) === 32,\r\n            \"invalid private key\",\r\n            \"privateKey\",\r\n            \"[REDACTED]\",\r\n        )\r\n        this.#privateKey = hexlify(privateKey)\r\n    }\r\n    get privateKey() {\r\n        return this.#privateKey\r\n    }\r\n    get publicKey() {\r\n        return SigningKey.computePublicKey(this.#privateKey)\r\n    }\r\n    get compressedPublicKey() {\r\n        return SigningKey.computePublicKey(this.#privateKey, true)\r\n    }\r\n    sign(digest) {\r\n        assertArgument(\r\n            dataLength(digest) === 32,\r\n            \"invalid digest length\",\r\n            \"digest\",\r\n            digest,\r\n        )\r\n        const sig = secp256k1.sign(\r\n            getBytesCopy(digest),\r\n            getBytesCopy(this.#privateKey),\r\n            {\r\n                lowS: true,\r\n            },\r\n        )\r\n        return Signature.from({\r\n            r: toBeHex(sig.r, 32),\r\n            s: toBeHex(sig.s, 32),\r\n            v: sig.recovery ? 28 : 27,\r\n        })\r\n    }\r\n    computeSharedSecret(other) {\r\n        const pubKey = SigningKey.computePublicKey(other)\r\n        return hexlify(\r\n            secp256k1.getSharedSecret(\r\n                getBytesCopy(this.#privateKey),\r\n                getBytes(pubKey),\r\n                false,\r\n            ),\r\n        )\r\n    }\r\n    static computePublicKey(key, compressed) {\r\n        let bytes = getBytes(key, \"key\")\r\n        if (bytes.length === 32) {\r\n            const pubKey = secp256k1.getPublicKey(bytes, !!compressed)\r\n            return hexlify(pubKey)\r\n        }\r\n        if (bytes.length === 64) {\r\n            const pub = new Uint8Array(65)\r\n            pub[0] = 4\r\n            pub.set(bytes, 1)\r\n            bytes = pub\r\n        }\r\n        const point = secp256k1.ProjectivePoint.fromHex(bytes)\r\n        return hexlify(point.toRawBytes(compressed))\r\n    }\r\n    static recoverPublicKey(digest, signature) {\r\n        assertArgument(\r\n            dataLength(digest) === 32,\r\n            \"invalid digest length\",\r\n            \"digest\",\r\n            digest,\r\n        )\r\n        const sig = Signature.from(signature)\r\n        let secpSig = secp256k1.Signature.fromCompact(\r\n            getBytesCopy(concat([sig.r, sig.s])),\r\n        )\r\n        secpSig = secpSig.addRecoveryBit(sig.yParity)\r\n        const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest))\r\n        assertArgument(\r\n            pubKey != null,\r\n            \"invalid signautre for digest\",\r\n            \"signature\",\r\n            signature,\r\n        )\r\n        return \"0x\" + pubKey.toHex(false)\r\n    }\r\n    static addPoints(p0, p1, compressed) {\r\n        const pub0 = secp256k1.ProjectivePoint.fromHex(\r\n            SigningKey.computePublicKey(p0).substring(2),\r\n        )\r\n        const pub1 = secp256k1.ProjectivePoint.fromHex(\r\n            SigningKey.computePublicKey(p1).substring(2),\r\n        )\r\n        return \"0x\" + pub0.add(pub1).toHex(!!compressed)\r\n    }\r\n}\r\nfunction lock() {\r\n    computeHmac.lock()\r\n    keccak256.lock()\r\n    pbkdf2.lock()\r\n    randomBytes.lock()\r\n    ripemd160.lock()\r\n    scrypt.lock()\r\n    scryptSync.lock()\r\n    sha256.lock()\r\n    sha512.lock()\r\n    randomBytes.lock()\r\n}\r\nconst BN_0$6 = BigInt(0)\r\nconst BN_36 = BigInt(36)\r\nfunction getChecksumAddress(address) {\r\n    address = address.toLowerCase()\r\n    const chars = address.substring(2).split(\"\")\r\n    const expanded = new Uint8Array(40)\r\n    for (let i = 0; i < 40; i++) {\r\n        expanded[i] = chars[i].charCodeAt(0)\r\n    }\r\n    const hashed = getBytes(keccak256(expanded))\r\n    for (let i = 0; i < 40; i += 2) {\r\n        if (hashed[i >> 1] >> 4 >= 8) {\r\n            chars[i] = chars[i].toUpperCase()\r\n        }\r\n        if ((hashed[i >> 1] & 15) >= 8) {\r\n            chars[i + 1] = chars[i + 1].toUpperCase()\r\n        }\r\n    }\r\n    return \"0x\" + chars.join(\"\")\r\n}\r\nconst ibanLookup = {}\r\nfor (let i = 0; i < 10; i++) {\r\n    ibanLookup[String(i)] = String(i)\r\n}\r\nfor (let i = 0; i < 26; i++) {\r\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i)\r\n}\r\nconst safeDigits = 15\r\nfunction ibanChecksum(address) {\r\n    address = address.toUpperCase()\r\n    address = address.substring(4) + address.substring(0, 2) + \"00\"\r\n    let expanded = address\r\n        .split(\"\")\r\n        .map((c) => {\r\n            return ibanLookup[c]\r\n        })\r\n        .join(\"\")\r\n    while (expanded.length >= safeDigits) {\r\n        let block = expanded.substring(0, safeDigits)\r\n        expanded = (parseInt(block, 10) % 97) + expanded.substring(block.length)\r\n    }\r\n    let checksum = String(98 - (parseInt(expanded, 10) % 97))\r\n    while (checksum.length < 2) {\r\n        checksum = \"0\" + checksum\r\n    }\r\n    return checksum\r\n}\r\nconst Base36 = (function () {\r\n    const result = {}\r\n    for (let i = 0; i < 36; i++) {\r\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i]\r\n        result[key] = BigInt(i)\r\n    }\r\n    return result\r\n})()\r\nfunction fromBase36(value) {\r\n    value = value.toLowerCase()\r\n    let result = BN_0$6\r\n    for (let i = 0; i < value.length; i++) {\r\n        result = result * BN_36 + Base36[value[i]]\r\n    }\r\n    return result\r\n}\r\nfunction getAddress(address) {\r\n    assertArgument(\r\n        typeof address === \"string\",\r\n        \"invalid address\",\r\n        \"address\",\r\n        address,\r\n    )\r\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\r\n        if (!address.startsWith(\"0x\")) {\r\n            address = \"0x\" + address\r\n        }\r\n        const result = getChecksumAddress(address)\r\n        assertArgument(\r\n            !address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) ||\r\n                result === address,\r\n            \"bad address checksum\",\r\n            \"address\",\r\n            address,\r\n        )\r\n        return result\r\n    }\r\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\r\n        assertArgument(\r\n            address.substring(2, 4) === ibanChecksum(address),\r\n            \"bad icap checksum\",\r\n            \"address\",\r\n            address,\r\n        )\r\n        let result = fromBase36(address.substring(4)).toString(16)\r\n        while (result.length < 40) {\r\n            result = \"0\" + result\r\n        }\r\n        return getChecksumAddress(\"0x\" + result)\r\n    }\r\n    assertArgument(false, \"invalid address\", \"address\", address)\r\n}\r\nfunction getIcapAddress(address) {\r\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase()\r\n    while (base36.length < 30) {\r\n        base36 = \"0\" + base36\r\n    }\r\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36\r\n}\r\nfunction getCreateAddress(tx) {\r\n    const from = getAddress(tx.from)\r\n    const nonce = getBigInt(tx.nonce, \"tx.nonce\")\r\n    let nonceHex = nonce.toString(16)\r\n    if (nonceHex === \"0\") {\r\n        nonceHex = \"0x\"\r\n    } else if (nonceHex.length % 2) {\r\n        nonceHex = \"0x0\" + nonceHex\r\n    } else {\r\n        nonceHex = \"0x\" + nonceHex\r\n    }\r\n    return getAddress(dataSlice(keccak256(encodeRlp([from, nonceHex])), 12))\r\n}\r\nfunction getCreate2Address(_from, _salt, _initCodeHash) {\r\n    const from = getAddress(_from)\r\n    const salt = getBytes(_salt, \"salt\")\r\n    const initCodeHash = getBytes(_initCodeHash, \"initCodeHash\")\r\n    assertArgument(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt)\r\n    assertArgument(\r\n        initCodeHash.length === 32,\r\n        \"initCodeHash must be 32 bytes\",\r\n        \"initCodeHash\",\r\n        _initCodeHash,\r\n    )\r\n    return getAddress(\r\n        dataSlice(keccak256(concat([\"0xff\", from, salt, initCodeHash])), 12),\r\n    )\r\n}\r\nfunction isAddressable(value) {\r\n    return value && typeof value.getAddress === \"function\"\r\n}\r\nfunction isAddress(value) {\r\n    try {\r\n        getAddress(value)\r\n        return true\r\n    } catch (error) {}\r\n    return false\r\n}\r\nasync function checkAddress(target, promise) {\r\n    const result = await promise\r\n    if (\r\n        result == null ||\r\n        result === \"0x0000000000000000000000000000000000000000\"\r\n    ) {\r\n        assert(\r\n            typeof target !== \"string\",\r\n            \"unconfigured name\",\r\n            \"UNCONFIGURED_NAME\",\r\n            {\r\n                value: target,\r\n            },\r\n        )\r\n        assertArgument(\r\n            false,\r\n            \"invalid AddressLike value; did not resolve to a value address\",\r\n            \"target\",\r\n            target,\r\n        )\r\n    }\r\n    return getAddress(result)\r\n}\r\nfunction resolveAddress(target, resolver) {\r\n    if (typeof target === \"string\") {\r\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\r\n            return getAddress(target)\r\n        }\r\n        assert(\r\n            resolver != null,\r\n            \"ENS resolution requires a provider\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"resolveName\",\r\n            },\r\n        )\r\n        return checkAddress(target, resolver.resolveName(target))\r\n    } else if (isAddressable(target)) {\r\n        return checkAddress(target, target.getAddress())\r\n    } else if (target && typeof target.then === \"function\") {\r\n        return checkAddress(target, target)\r\n    }\r\n    assertArgument(false, \"unsupported addressable value\", \"target\", target)\r\n}\r\nconst _gaurd = {}\r\nfunction n(value, width) {\r\n    let signed = false\r\n    if (width < 0) {\r\n        signed = true\r\n        width *= -1\r\n    }\r\n    return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, {\r\n        signed: signed,\r\n        width: width,\r\n    })\r\n}\r\nfunction b(value, size) {\r\n    return new Typed(_gaurd, `bytes${size ? size : \"\"}`, value, {\r\n        size: size,\r\n    })\r\n}\r\nconst _typedSymbol = Symbol.for(\"_ethers_typed\")\r\nclass Typed {\r\n    type\r\n    value\r\n    #options\r\n    _typedSymbol\r\n    constructor(gaurd, type, value, options) {\r\n        if (options == null) {\r\n            options = null\r\n        }\r\n        assertPrivate(_gaurd, gaurd, \"Typed\")\r\n        defineProperties(this, {\r\n            _typedSymbol: _typedSymbol,\r\n            type: type,\r\n            value: value,\r\n        })\r\n        this.#options = options\r\n        this.format()\r\n    }\r\n    format() {\r\n        if (this.type === \"array\") {\r\n            throw new Error(\"\")\r\n        } else if (this.type === \"dynamicArray\") {\r\n            throw new Error(\"\")\r\n        } else if (this.type === \"tuple\") {\r\n            return `tuple(${this.value.map((v) => v.format()).join(\",\")})`\r\n        }\r\n        return this.type\r\n    }\r\n    defaultValue() {\r\n        return 0\r\n    }\r\n    minValue() {\r\n        return 0\r\n    }\r\n    maxValue() {\r\n        return 0\r\n    }\r\n    isBigInt() {\r\n        return !!this.type.match(/^u?int[0-9]+$/)\r\n    }\r\n    isData() {\r\n        return this.type.startsWith(\"bytes\")\r\n    }\r\n    isString() {\r\n        return this.type === \"string\"\r\n    }\r\n    get tupleName() {\r\n        if (this.type !== \"tuple\") {\r\n            throw TypeError(\"not a tuple\")\r\n        }\r\n        return this.#options\r\n    }\r\n    get arrayLength() {\r\n        if (this.type !== \"array\") {\r\n            throw TypeError(\"not an array\")\r\n        }\r\n        if (this.#options === true) {\r\n            return -1\r\n        }\r\n        if (this.#options === false) {\r\n            return this.value.length\r\n        }\r\n        return null\r\n    }\r\n    static from(type, value) {\r\n        return new Typed(_gaurd, type, value)\r\n    }\r\n    static uint8(v) {\r\n        return n(v, 8)\r\n    }\r\n    static uint16(v) {\r\n        return n(v, 16)\r\n    }\r\n    static uint24(v) {\r\n        return n(v, 24)\r\n    }\r\n    static uint32(v) {\r\n        return n(v, 32)\r\n    }\r\n    static uint40(v) {\r\n        return n(v, 40)\r\n    }\r\n    static uint48(v) {\r\n        return n(v, 48)\r\n    }\r\n    static uint56(v) {\r\n        return n(v, 56)\r\n    }\r\n    static uint64(v) {\r\n        return n(v, 64)\r\n    }\r\n    static uint72(v) {\r\n        return n(v, 72)\r\n    }\r\n    static uint80(v) {\r\n        return n(v, 80)\r\n    }\r\n    static uint88(v) {\r\n        return n(v, 88)\r\n    }\r\n    static uint96(v) {\r\n        return n(v, 96)\r\n    }\r\n    static uint104(v) {\r\n        return n(v, 104)\r\n    }\r\n    static uint112(v) {\r\n        return n(v, 112)\r\n    }\r\n    static uint120(v) {\r\n        return n(v, 120)\r\n    }\r\n    static uint128(v) {\r\n        return n(v, 128)\r\n    }\r\n    static uint136(v) {\r\n        return n(v, 136)\r\n    }\r\n    static uint144(v) {\r\n        return n(v, 144)\r\n    }\r\n    static uint152(v) {\r\n        return n(v, 152)\r\n    }\r\n    static uint160(v) {\r\n        return n(v, 160)\r\n    }\r\n    static uint168(v) {\r\n        return n(v, 168)\r\n    }\r\n    static uint176(v) {\r\n        return n(v, 176)\r\n    }\r\n    static uint184(v) {\r\n        return n(v, 184)\r\n    }\r\n    static uint192(v) {\r\n        return n(v, 192)\r\n    }\r\n    static uint200(v) {\r\n        return n(v, 200)\r\n    }\r\n    static uint208(v) {\r\n        return n(v, 208)\r\n    }\r\n    static uint216(v) {\r\n        return n(v, 216)\r\n    }\r\n    static uint224(v) {\r\n        return n(v, 224)\r\n    }\r\n    static uint232(v) {\r\n        return n(v, 232)\r\n    }\r\n    static uint240(v) {\r\n        return n(v, 240)\r\n    }\r\n    static uint248(v) {\r\n        return n(v, 248)\r\n    }\r\n    static uint256(v) {\r\n        return n(v, 256)\r\n    }\r\n    static uint(v) {\r\n        return n(v, 256)\r\n    }\r\n    static int8(v) {\r\n        return n(v, -8)\r\n    }\r\n    static int16(v) {\r\n        return n(v, -16)\r\n    }\r\n    static int24(v) {\r\n        return n(v, -24)\r\n    }\r\n    static int32(v) {\r\n        return n(v, -32)\r\n    }\r\n    static int40(v) {\r\n        return n(v, -40)\r\n    }\r\n    static int48(v) {\r\n        return n(v, -48)\r\n    }\r\n    static int56(v) {\r\n        return n(v, -56)\r\n    }\r\n    static int64(v) {\r\n        return n(v, -64)\r\n    }\r\n    static int72(v) {\r\n        return n(v, -72)\r\n    }\r\n    static int80(v) {\r\n        return n(v, -80)\r\n    }\r\n    static int88(v) {\r\n        return n(v, -88)\r\n    }\r\n    static int96(v) {\r\n        return n(v, -96)\r\n    }\r\n    static int104(v) {\r\n        return n(v, -104)\r\n    }\r\n    static int112(v) {\r\n        return n(v, -112)\r\n    }\r\n    static int120(v) {\r\n        return n(v, -120)\r\n    }\r\n    static int128(v) {\r\n        return n(v, -128)\r\n    }\r\n    static int136(v) {\r\n        return n(v, -136)\r\n    }\r\n    static int144(v) {\r\n        return n(v, -144)\r\n    }\r\n    static int152(v) {\r\n        return n(v, -152)\r\n    }\r\n    static int160(v) {\r\n        return n(v, -160)\r\n    }\r\n    static int168(v) {\r\n        return n(v, -168)\r\n    }\r\n    static int176(v) {\r\n        return n(v, -176)\r\n    }\r\n    static int184(v) {\r\n        return n(v, -184)\r\n    }\r\n    static int192(v) {\r\n        return n(v, -192)\r\n    }\r\n    static int200(v) {\r\n        return n(v, -200)\r\n    }\r\n    static int208(v) {\r\n        return n(v, -208)\r\n    }\r\n    static int216(v) {\r\n        return n(v, -216)\r\n    }\r\n    static int224(v) {\r\n        return n(v, -224)\r\n    }\r\n    static int232(v) {\r\n        return n(v, -232)\r\n    }\r\n    static int240(v) {\r\n        return n(v, -240)\r\n    }\r\n    static int248(v) {\r\n        return n(v, -248)\r\n    }\r\n    static int256(v) {\r\n        return n(v, -256)\r\n    }\r\n    static int(v) {\r\n        return n(v, -256)\r\n    }\r\n    static bytes1(v) {\r\n        return b(v, 1)\r\n    }\r\n    static bytes2(v) {\r\n        return b(v, 2)\r\n    }\r\n    static bytes3(v) {\r\n        return b(v, 3)\r\n    }\r\n    static bytes4(v) {\r\n        return b(v, 4)\r\n    }\r\n    static bytes5(v) {\r\n        return b(v, 5)\r\n    }\r\n    static bytes6(v) {\r\n        return b(v, 6)\r\n    }\r\n    static bytes7(v) {\r\n        return b(v, 7)\r\n    }\r\n    static bytes8(v) {\r\n        return b(v, 8)\r\n    }\r\n    static bytes9(v) {\r\n        return b(v, 9)\r\n    }\r\n    static bytes10(v) {\r\n        return b(v, 10)\r\n    }\r\n    static bytes11(v) {\r\n        return b(v, 11)\r\n    }\r\n    static bytes12(v) {\r\n        return b(v, 12)\r\n    }\r\n    static bytes13(v) {\r\n        return b(v, 13)\r\n    }\r\n    static bytes14(v) {\r\n        return b(v, 14)\r\n    }\r\n    static bytes15(v) {\r\n        return b(v, 15)\r\n    }\r\n    static bytes16(v) {\r\n        return b(v, 16)\r\n    }\r\n    static bytes17(v) {\r\n        return b(v, 17)\r\n    }\r\n    static bytes18(v) {\r\n        return b(v, 18)\r\n    }\r\n    static bytes19(v) {\r\n        return b(v, 19)\r\n    }\r\n    static bytes20(v) {\r\n        return b(v, 20)\r\n    }\r\n    static bytes21(v) {\r\n        return b(v, 21)\r\n    }\r\n    static bytes22(v) {\r\n        return b(v, 22)\r\n    }\r\n    static bytes23(v) {\r\n        return b(v, 23)\r\n    }\r\n    static bytes24(v) {\r\n        return b(v, 24)\r\n    }\r\n    static bytes25(v) {\r\n        return b(v, 25)\r\n    }\r\n    static bytes26(v) {\r\n        return b(v, 26)\r\n    }\r\n    static bytes27(v) {\r\n        return b(v, 27)\r\n    }\r\n    static bytes28(v) {\r\n        return b(v, 28)\r\n    }\r\n    static bytes29(v) {\r\n        return b(v, 29)\r\n    }\r\n    static bytes30(v) {\r\n        return b(v, 30)\r\n    }\r\n    static bytes31(v) {\r\n        return b(v, 31)\r\n    }\r\n    static bytes32(v) {\r\n        return b(v, 32)\r\n    }\r\n    static address(v) {\r\n        return new Typed(_gaurd, \"address\", v)\r\n    }\r\n    static bool(v) {\r\n        return new Typed(_gaurd, \"bool\", !!v)\r\n    }\r\n    static bytes(v) {\r\n        return new Typed(_gaurd, \"bytes\", v)\r\n    }\r\n    static string(v) {\r\n        return new Typed(_gaurd, \"string\", v)\r\n    }\r\n    static array(v, dynamic) {\r\n        throw new Error(\"not implemented yet\")\r\n    }\r\n    static tuple(v, name) {\r\n        throw new Error(\"not implemented yet\")\r\n    }\r\n    static overrides(v) {\r\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v))\r\n    }\r\n    static isTyped(value) {\r\n        return (\r\n            value &&\r\n            typeof value === \"object\" &&\r\n            \"_typedSymbol\" in value &&\r\n            value._typedSymbol === _typedSymbol\r\n        )\r\n    }\r\n    static dereference(value, type) {\r\n        if (Typed.isTyped(value)) {\r\n            if (value.type !== type) {\r\n                throw new Error(\r\n                    `invalid type: expecetd ${type}, got ${value.type}`,\r\n                )\r\n            }\r\n            return value.value\r\n        }\r\n        return value\r\n    }\r\n}\r\nclass AddressCoder extends Coder {\r\n    constructor(localName) {\r\n        super(\"address\", \"address\", localName, false)\r\n    }\r\n    defaultValue() {\r\n        return \"0x0000000000000000000000000000000000000000\"\r\n    }\r\n    encode(writer, _value) {\r\n        let value = Typed.dereference(_value, \"string\")\r\n        try {\r\n            value = getAddress(value)\r\n        } catch (error) {\r\n            return this._throwError(error.message, _value)\r\n        }\r\n        return writer.writeValue(value)\r\n    }\r\n    decode(reader) {\r\n        return getAddress(toBeHex(reader.readValue(), 20))\r\n    }\r\n}\r\nclass AnonymousCoder extends Coder {\r\n    coder\r\n    constructor(coder) {\r\n        super(coder.name, coder.type, \"_\", coder.dynamic)\r\n        this.coder = coder\r\n    }\r\n    defaultValue() {\r\n        return this.coder.defaultValue()\r\n    }\r\n    encode(writer, value) {\r\n        return this.coder.encode(writer, value)\r\n    }\r\n    decode(reader) {\r\n        return this.coder.decode(reader)\r\n    }\r\n}\r\nfunction pack(writer, coders, values) {\r\n    let arrayValues = []\r\n    if (Array.isArray(values)) {\r\n        arrayValues = values\r\n    } else if (values && typeof values === \"object\") {\r\n        let unique = {}\r\n        arrayValues = coders.map((coder) => {\r\n            const name = coder.localName\r\n            assert(\r\n                name,\r\n                \"cannot encode object for signature with missing names\",\r\n                \"INVALID_ARGUMENT\",\r\n                {\r\n                    argument: \"values\",\r\n                    info: {\r\n                        coder: coder,\r\n                    },\r\n                    value: values,\r\n                },\r\n            )\r\n            assert(\r\n                !unique[name],\r\n                \"cannot encode object for signature with duplicate names\",\r\n                \"INVALID_ARGUMENT\",\r\n                {\r\n                    argument: \"values\",\r\n                    info: {\r\n                        coder: coder,\r\n                    },\r\n                    value: values,\r\n                },\r\n            )\r\n            unique[name] = true\r\n            return values[name]\r\n        })\r\n    } else {\r\n        assertArgument(false, \"invalid tuple value\", \"tuple\", values)\r\n    }\r\n    assertArgument(\r\n        coders.length === arrayValues.length,\r\n        \"types/value length mismatch\",\r\n        \"tuple\",\r\n        values,\r\n    )\r\n    let staticWriter = new Writer()\r\n    let dynamicWriter = new Writer()\r\n    let updateFuncs = []\r\n    coders.forEach((coder, index) => {\r\n        let value = arrayValues[index]\r\n        if (coder.dynamic) {\r\n            let dynamicOffset = dynamicWriter.length\r\n            coder.encode(dynamicWriter, value)\r\n            let updateFunc = staticWriter.writeUpdatableValue()\r\n            updateFuncs.push((baseOffset) => {\r\n                updateFunc(baseOffset + dynamicOffset)\r\n            })\r\n        } else {\r\n            coder.encode(staticWriter, value)\r\n        }\r\n    })\r\n    updateFuncs.forEach((func) => {\r\n        func(staticWriter.length)\r\n    })\r\n    let length = writer.appendWriter(staticWriter)\r\n    length += writer.appendWriter(dynamicWriter)\r\n    return length\r\n}\r\nfunction unpack(reader, coders) {\r\n    let values = []\r\n    let keys = []\r\n    let baseReader = reader.subReader(0)\r\n    coders.forEach((coder) => {\r\n        let value = null\r\n        if (coder.dynamic) {\r\n            let offset = reader.readIndex()\r\n            let offsetReader = baseReader.subReader(offset)\r\n            try {\r\n                value = coder.decode(offsetReader)\r\n            } catch (error) {\r\n                if (isError(error, \"BUFFER_OVERRUN\")) {\r\n                    throw error\r\n                }\r\n                value = error\r\n                value.baseType = coder.name\r\n                value.name = coder.localName\r\n                value.type = coder.type\r\n            }\r\n        } else {\r\n            try {\r\n                value = coder.decode(reader)\r\n            } catch (error) {\r\n                if (isError(error, \"BUFFER_OVERRUN\")) {\r\n                    throw error\r\n                }\r\n                value = error\r\n                value.baseType = coder.name\r\n                value.name = coder.localName\r\n                value.type = coder.type\r\n            }\r\n        }\r\n        if (value == undefined) {\r\n            throw new Error(\"investigate\")\r\n        }\r\n        values.push(value)\r\n        keys.push(coder.localName || null)\r\n    })\r\n    return Result.fromItems(values, keys)\r\n}\r\nclass ArrayCoder extends Coder {\r\n    coder\r\n    length\r\n    constructor(coder, length, localName) {\r\n        const type = coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\"\r\n        const dynamic = length === -1 || coder.dynamic\r\n        super(\"array\", type, localName, dynamic)\r\n        defineProperties(this, {\r\n            coder: coder,\r\n            length: length,\r\n        })\r\n    }\r\n    defaultValue() {\r\n        const defaultChild = this.coder.defaultValue()\r\n        const result = []\r\n        for (let i = 0; i < this.length; i++) {\r\n            result.push(defaultChild)\r\n        }\r\n        return result\r\n    }\r\n    encode(writer, _value) {\r\n        const value = Typed.dereference(_value, \"array\")\r\n        if (!Array.isArray(value)) {\r\n            this._throwError(\"expected array value\", value)\r\n        }\r\n        let count = this.length\r\n        if (count === -1) {\r\n            count = value.length\r\n            writer.writeValue(value.length)\r\n        }\r\n        assertArgumentCount(\r\n            value.length,\r\n            count,\r\n            \"coder array\" + (this.localName ? \" \" + this.localName : \"\"),\r\n        )\r\n        let coders = []\r\n        for (let i = 0; i < value.length; i++) {\r\n            coders.push(this.coder)\r\n        }\r\n        return pack(writer, coders, value)\r\n    }\r\n    decode(reader) {\r\n        let count = this.length\r\n        if (count === -1) {\r\n            count = reader.readIndex()\r\n            assert(\r\n                count * WordSize <= reader.dataLength,\r\n                \"insufficient data length\",\r\n                \"BUFFER_OVERRUN\",\r\n                {\r\n                    buffer: reader.bytes,\r\n                    offset: count * WordSize,\r\n                    length: reader.dataLength,\r\n                },\r\n            )\r\n        }\r\n        let coders = []\r\n        for (let i = 0; i < count; i++) {\r\n            coders.push(new AnonymousCoder(this.coder))\r\n        }\r\n        return unpack(reader, coders)\r\n    }\r\n}\r\nclass BooleanCoder extends Coder {\r\n    constructor(localName) {\r\n        super(\"bool\", \"bool\", localName, false)\r\n    }\r\n    defaultValue() {\r\n        return false\r\n    }\r\n    encode(writer, _value) {\r\n        const value = Typed.dereference(_value, \"bool\")\r\n        return writer.writeValue(value ? 1 : 0)\r\n    }\r\n    decode(reader) {\r\n        return !!reader.readValue()\r\n    }\r\n}\r\nclass DynamicBytesCoder extends Coder {\r\n    constructor(type, localName) {\r\n        super(type, type, localName, true)\r\n    }\r\n    defaultValue() {\r\n        return \"0x\"\r\n    }\r\n    encode(writer, value) {\r\n        value = getBytesCopy(value)\r\n        let length = writer.writeValue(value.length)\r\n        length += writer.writeBytes(value)\r\n        return length\r\n    }\r\n    decode(reader) {\r\n        return reader.readBytes(reader.readIndex(), true)\r\n    }\r\n}\r\nclass BytesCoder extends DynamicBytesCoder {\r\n    constructor(localName) {\r\n        super(\"bytes\", localName)\r\n    }\r\n    decode(reader) {\r\n        return hexlify(super.decode(reader))\r\n    }\r\n}\r\nclass FixedBytesCoder extends Coder {\r\n    size\r\n    constructor(size, localName) {\r\n        let name = \"bytes\" + String(size)\r\n        super(name, name, localName, false)\r\n        defineProperties(\r\n            this,\r\n            {\r\n                size: size,\r\n            },\r\n            {\r\n                size: \"number\",\r\n            },\r\n        )\r\n    }\r\n    defaultValue() {\r\n        return \"0x0000000000000000000000000000000000000000000000000000000000000000\".substring(\r\n            0,\r\n            2 + this.size * 2,\r\n        )\r\n    }\r\n    encode(writer, _value) {\r\n        let data = getBytesCopy(Typed.dereference(_value, this.type))\r\n        if (data.length !== this.size) {\r\n            this._throwError(\"incorrect data length\", _value)\r\n        }\r\n        return writer.writeBytes(data)\r\n    }\r\n    decode(reader) {\r\n        return hexlify(reader.readBytes(this.size))\r\n    }\r\n}\r\nconst Empty = new Uint8Array([])\r\nclass NullCoder extends Coder {\r\n    constructor(localName) {\r\n        super(\"null\", \"\", localName, false)\r\n    }\r\n    defaultValue() {\r\n        return null\r\n    }\r\n    encode(writer, value) {\r\n        if (value != null) {\r\n            this._throwError(\"not null\", value)\r\n        }\r\n        return writer.writeBytes(Empty)\r\n    }\r\n    decode(reader) {\r\n        reader.readBytes(0)\r\n        return null\r\n    }\r\n}\r\nconst BN_0$5 = BigInt(0)\r\nconst BN_1$2 = BigInt(1)\r\nconst BN_MAX_UINT256$1 = BigInt(\r\n    \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\r\n)\r\nclass NumberCoder extends Coder {\r\n    size\r\n    signed\r\n    constructor(size, signed, localName) {\r\n        const name = (signed ? \"int\" : \"uint\") + size * 8\r\n        super(name, name, localName, false)\r\n        defineProperties(\r\n            this,\r\n            {\r\n                size: size,\r\n                signed: signed,\r\n            },\r\n            {\r\n                size: \"number\",\r\n                signed: \"boolean\",\r\n            },\r\n        )\r\n    }\r\n    defaultValue() {\r\n        return 0\r\n    }\r\n    encode(writer, _value) {\r\n        let value = getBigInt(Typed.dereference(_value, this.type))\r\n        let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8)\r\n        if (this.signed) {\r\n            let bounds = mask(maxUintValue, this.size * 8 - 1)\r\n            if (value > bounds || value < -(bounds + BN_1$2)) {\r\n                this._throwError(\"value out-of-bounds\", _value)\r\n            }\r\n            value = toTwos(value, 8 * WordSize)\r\n        } else if (\r\n            value < BN_0$5 ||\r\n            value > mask(maxUintValue, this.size * 8)\r\n        ) {\r\n            this._throwError(\"value out-of-bounds\", _value)\r\n        }\r\n        return writer.writeValue(value)\r\n    }\r\n    decode(reader) {\r\n        let value = mask(reader.readValue(), this.size * 8)\r\n        if (this.signed) {\r\n            value = fromTwos(value, this.size * 8)\r\n        }\r\n        return value\r\n    }\r\n}\r\nclass StringCoder extends DynamicBytesCoder {\r\n    constructor(localName) {\r\n        super(\"string\", localName)\r\n    }\r\n    defaultValue() {\r\n        return \"\"\r\n    }\r\n    encode(writer, _value) {\r\n        return super.encode(\r\n            writer,\r\n            toUtf8Bytes(Typed.dereference(_value, \"string\")),\r\n        )\r\n    }\r\n    decode(reader) {\r\n        return toUtf8String(super.decode(reader))\r\n    }\r\n}\r\nclass TupleCoder extends Coder {\r\n    coders\r\n    constructor(coders, localName) {\r\n        let dynamic = false\r\n        const types = []\r\n        coders.forEach((coder) => {\r\n            if (coder.dynamic) {\r\n                dynamic = true\r\n            }\r\n            types.push(coder.type)\r\n        })\r\n        const type = \"tuple(\" + types.join(\",\") + \")\"\r\n        super(\"tuple\", type, localName, dynamic)\r\n        defineProperties(this, {\r\n            coders: Object.freeze(coders.slice()),\r\n        })\r\n    }\r\n    defaultValue() {\r\n        const values = []\r\n        this.coders.forEach((coder) => {\r\n            values.push(coder.defaultValue())\r\n        })\r\n        const uniqueNames = this.coders.reduce((accum, coder) => {\r\n            const name = coder.localName\r\n            if (name) {\r\n                if (!accum[name]) {\r\n                    accum[name] = 0\r\n                }\r\n                accum[name]++\r\n            }\r\n            return accum\r\n        }, {})\r\n        this.coders.forEach((coder, index) => {\r\n            let name = coder.localName\r\n            if (!name || uniqueNames[name] !== 1) {\r\n                return\r\n            }\r\n            if (name === \"length\") {\r\n                name = \"_length\"\r\n            }\r\n            if (values[name] != null) {\r\n                return\r\n            }\r\n            values[name] = values[index]\r\n        })\r\n        return Object.freeze(values)\r\n    }\r\n    encode(writer, _value) {\r\n        const value = Typed.dereference(_value, \"tuple\")\r\n        return pack(writer, this.coders, value)\r\n    }\r\n    decode(reader) {\r\n        return unpack(reader, this.coders)\r\n    }\r\n}\r\nfunction id(value) {\r\n    return keccak256(toUtf8Bytes(value))\r\n}\r\nvar COMPRESSED$1 =\r\n    \"AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI\"\r\nconst FENCED = new Map([\r\n    [8217, \"apostrophe\"],\r\n    [8260, \"fraction slash\"],\r\n    [12539, \"middle dot\"],\r\n])\r\nconst NSM_MAX = 4\r\nfunction decode_arithmetic(bytes) {\r\n    let pos = 0\r\n    function u16() {\r\n        return (bytes[pos++] << 8) | bytes[pos++]\r\n    }\r\n    let symbol_count = u16()\r\n    let total = 1\r\n    let acc = [0, 1]\r\n    for (let i = 1; i < symbol_count; i++) {\r\n        acc.push((total += u16()))\r\n    }\r\n    let skip = u16()\r\n    let pos_payload = pos\r\n    pos += skip\r\n    let read_width = 0\r\n    let read_buffer = 0\r\n    function read_bit() {\r\n        if (read_width == 0) {\r\n            read_buffer = (read_buffer << 8) | bytes[pos++]\r\n            read_width = 8\r\n        }\r\n        return (read_buffer >> --read_width) & 1\r\n    }\r\n    const N = 31\r\n    const FULL = 2 ** N\r\n    const HALF = FULL >>> 1\r\n    const QRTR = HALF >> 1\r\n    const MASK = FULL - 1\r\n    let register = 0\r\n    for (let i = 0; i < N; i++) register = (register << 1) | read_bit()\r\n    let symbols = []\r\n    let low = 0\r\n    let range = FULL\r\n    while (true) {\r\n        let value = Math.floor(((register - low + 1) * total - 1) / range)\r\n        let start = 0\r\n        let end = symbol_count\r\n        while (end - start > 1) {\r\n            let mid = (start + end) >>> 1\r\n            if (value < acc[mid]) {\r\n                end = mid\r\n            } else {\r\n                start = mid\r\n            }\r\n        }\r\n        if (start == 0) break\r\n        symbols.push(start)\r\n        let a = low + Math.floor((range * acc[start]) / total)\r\n        let b = low + Math.floor((range * acc[start + 1]) / total) - 1\r\n        while (((a ^ b) & HALF) == 0) {\r\n            register = ((register << 1) & MASK) | read_bit()\r\n            a = (a << 1) & MASK\r\n            b = ((b << 1) & MASK) | 1\r\n        }\r\n        while (a & ~b & QRTR) {\r\n            register =\r\n                (register & HALF) |\r\n                ((register << 1) & (MASK >>> 1)) |\r\n                read_bit()\r\n            a = (a << 1) ^ HALF\r\n            b = ((b ^ HALF) << 1) | HALF | 1\r\n        }\r\n        low = a\r\n        range = 1 + b - a\r\n    }\r\n    let offset = symbol_count - 4\r\n    return symbols.map((x) => {\r\n        switch (x - offset) {\r\n            case 3:\r\n                return (\r\n                    offset +\r\n                    65792 +\r\n                    ((bytes[pos_payload++] << 16) |\r\n                        (bytes[pos_payload++] << 8) |\r\n                        bytes[pos_payload++])\r\n                )\r\n            case 2:\r\n                return (\r\n                    offset +\r\n                    256 +\r\n                    ((bytes[pos_payload++] << 8) | bytes[pos_payload++])\r\n                )\r\n            case 1:\r\n                return offset + bytes[pos_payload++]\r\n            default:\r\n                return x - 1\r\n        }\r\n    })\r\n}\r\nfunction read_payload(v) {\r\n    let pos = 0\r\n    return () => v[pos++]\r\n}\r\nfunction read_compressed_payload(s) {\r\n    return read_payload(decode_arithmetic(unsafe_atob(s)))\r\n}\r\nfunction unsafe_atob(s) {\r\n    let lookup = []\r\n    ;[\r\n        ...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\r\n    ].forEach((c, i) => (lookup[c.charCodeAt(0)] = i))\r\n    let n = s.length\r\n    let ret = new Uint8Array((6 * n) >> 3)\r\n    for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n        carry = (carry << 6) | lookup[s.charCodeAt(i)]\r\n        width += 6\r\n        if (width >= 8) {\r\n            ret[pos++] = carry >> (width -= 8)\r\n        }\r\n    }\r\n    return ret\r\n}\r\nfunction signed(i) {\r\n    return i & 1 ? ~i >> 1 : i >> 1\r\n}\r\nfunction read_deltas(n, next) {\r\n    let v = Array(n)\r\n    for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next())\r\n    return v\r\n}\r\nfunction read_sorted(next, prev = 0) {\r\n    let ret = []\r\n    while (true) {\r\n        let x = next()\r\n        let n = next()\r\n        if (!n) break\r\n        prev += x\r\n        for (let i = 0; i < n; i++) {\r\n            ret.push(prev + i)\r\n        }\r\n        prev += n + 1\r\n    }\r\n    return ret\r\n}\r\nfunction read_sorted_arrays(next) {\r\n    return read_array_while(() => {\r\n        let v = read_sorted(next)\r\n        if (v.length) return v\r\n    })\r\n}\r\nfunction read_mapped(next) {\r\n    let ret = []\r\n    while (true) {\r\n        let w = next()\r\n        if (w == 0) break\r\n        ret.push(read_linear_table(w, next))\r\n    }\r\n    while (true) {\r\n        let w = next() - 1\r\n        if (w < 0) break\r\n        ret.push(read_replacement_table(w, next))\r\n    }\r\n    return ret.flat()\r\n}\r\nfunction read_array_while(next) {\r\n    let v = []\r\n    while (true) {\r\n        let x = next(v.length)\r\n        if (!x) break\r\n        v.push(x)\r\n    }\r\n    return v\r\n}\r\nfunction read_transposed(n, w, next) {\r\n    let m = Array(n)\r\n        .fill()\r\n        .map(() => [])\r\n    for (let i = 0; i < w; i++) {\r\n        read_deltas(n, next).forEach((x, j) => m[j].push(x))\r\n    }\r\n    return m\r\n}\r\nfunction read_linear_table(w, next) {\r\n    let dx = 1 + next()\r\n    let dy = next()\r\n    let vN = read_array_while(next)\r\n    let m = read_transposed(vN.length, 1 + w, next)\r\n    return m.flatMap((v, i) => {\r\n        let [x, ...ys] = v\r\n        return Array(vN[i])\r\n            .fill()\r\n            .map((_, j) => {\r\n                let j_dy = j * dy\r\n                return [x + j * dx, ys.map((y) => y + j_dy)]\r\n            })\r\n    })\r\n}\r\nfunction read_replacement_table(w, next) {\r\n    let n = 1 + next()\r\n    let m = read_transposed(n, 1 + w, next)\r\n    return m.map((v) => [v[0], v.slice(1)])\r\n}\r\nfunction read_trie(next) {\r\n    let ret = []\r\n    let sorted = read_sorted(next)\r\n    expand(decode([]), [])\r\n    return ret\r\n    function decode(Q) {\r\n        let S = next()\r\n        let B = read_array_while(() => {\r\n            let cps = read_sorted(next).map((i) => sorted[i])\r\n            if (cps.length) return decode(cps)\r\n        })\r\n        return {\r\n            S: S,\r\n            B: B,\r\n            Q: Q,\r\n        }\r\n    }\r\n    function expand({ S, B }, cps, saved) {\r\n        if (S & 4 && saved === cps[cps.length - 1]) return\r\n        if (S & 2) saved = cps[cps.length - 1]\r\n        if (S & 1) ret.push(cps)\r\n        for (let br of B) {\r\n            for (let cp of br.Q) {\r\n                expand(br, [...cps, cp], saved)\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction hex_cp(cp) {\r\n    return cp.toString(16).toUpperCase().padStart(2, \"0\")\r\n}\r\nfunction quote_cp(cp) {\r\n    return `{${hex_cp(cp)}}`\r\n}\r\nfunction explode_cp(s) {\r\n    let cps = []\r\n    for (let pos = 0, len = s.length; pos < len; ) {\r\n        let cp = s.codePointAt(pos)\r\n        pos += cp < 65536 ? 1 : 2\r\n        cps.push(cp)\r\n    }\r\n    return cps\r\n}\r\nfunction str_from_cps(cps) {\r\n    const chunk = 4096\r\n    let len = cps.length\r\n    if (len < chunk) return String.fromCodePoint(...cps)\r\n    let buf = []\r\n    for (let i = 0; i < len; ) {\r\n        buf.push(String.fromCodePoint(...cps.slice(i, (i += chunk))))\r\n    }\r\n    return buf.join(\"\")\r\n}\r\nfunction compare_arrays(a, b) {\r\n    let n = a.length\r\n    let c = n - b.length\r\n    for (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i]\r\n    return c\r\n}\r\nvar COMPRESSED =\r\n    \"AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g\"\r\nconst S0 = 44032\r\nconst L0 = 4352\r\nconst V0 = 4449\r\nconst T0 = 4519\r\nconst L_COUNT = 19\r\nconst V_COUNT = 21\r\nconst T_COUNT = 28\r\nconst N_COUNT = V_COUNT * T_COUNT\r\nconst S_COUNT = L_COUNT * N_COUNT\r\nconst S1 = S0 + S_COUNT\r\nconst L1 = L0 + L_COUNT\r\nconst V1 = V0 + V_COUNT\r\nconst T1$1 = T0 + T_COUNT\r\nfunction unpack_cc(packed) {\r\n    return (packed >> 24) & 255\r\n}\r\nfunction unpack_cp(packed) {\r\n    return packed & 16777215\r\n}\r\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP\r\nfunction init$1() {\r\n    let r = read_compressed_payload(COMPRESSED)\r\n    SHIFTED_RANK = new Map(\r\n        read_sorted_arrays(r).flatMap((v, i) =>\r\n            v.map((x) => [x, (i + 1) << 24]),\r\n        ),\r\n    )\r\n    EXCLUSIONS = new Set(read_sorted(r))\r\n    DECOMP = new Map()\r\n    RECOMP = new Map()\r\n    for (let [cp, cps] of read_mapped(r)) {\r\n        if (!EXCLUSIONS.has(cp) && cps.length == 2) {\r\n            let [a, b] = cps\r\n            let bucket = RECOMP.get(a)\r\n            if (!bucket) {\r\n                bucket = new Map()\r\n                RECOMP.set(a, bucket)\r\n            }\r\n            bucket.set(b, cp)\r\n        }\r\n        DECOMP.set(cp, cps.reverse())\r\n    }\r\n}\r\nfunction is_hangul(cp) {\r\n    return cp >= S0 && cp < S1\r\n}\r\nfunction compose_pair(a, b) {\r\n    if (a >= L0 && a < L1 && b >= V0 && b < V1) {\r\n        return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT\r\n    } else if (is_hangul(a) && b > T0 && b < T1$1 && (a - S0) % T_COUNT == 0) {\r\n        return a + (b - T0)\r\n    } else {\r\n        let recomp = RECOMP.get(a)\r\n        if (recomp) {\r\n            recomp = recomp.get(b)\r\n            if (recomp) {\r\n                return recomp\r\n            }\r\n        }\r\n        return -1\r\n    }\r\n}\r\nfunction decomposed(cps) {\r\n    if (!SHIFTED_RANK) init$1()\r\n    let ret = []\r\n    let buf = []\r\n    let check_order = false\r\n    function add(cp) {\r\n        let cc = SHIFTED_RANK.get(cp)\r\n        if (cc) {\r\n            check_order = true\r\n            cp |= cc\r\n        }\r\n        ret.push(cp)\r\n    }\r\n    for (let cp of cps) {\r\n        while (true) {\r\n            if (cp < 128) {\r\n                ret.push(cp)\r\n            } else if (is_hangul(cp)) {\r\n                let s_index = cp - S0\r\n                let l_index = (s_index / N_COUNT) | 0\r\n                let v_index = ((s_index % N_COUNT) / T_COUNT) | 0\r\n                let t_index = s_index % T_COUNT\r\n                add(L0 + l_index)\r\n                add(V0 + v_index)\r\n                if (t_index > 0) add(T0 + t_index)\r\n            } else {\r\n                let mapped = DECOMP.get(cp)\r\n                if (mapped) {\r\n                    buf.push(...mapped)\r\n                } else {\r\n                    add(cp)\r\n                }\r\n            }\r\n            if (!buf.length) break\r\n            cp = buf.pop()\r\n        }\r\n    }\r\n    if (check_order && ret.length > 1) {\r\n        let prev_cc = unpack_cc(ret[0])\r\n        for (let i = 1; i < ret.length; i++) {\r\n            let cc = unpack_cc(ret[i])\r\n            if (cc == 0 || prev_cc <= cc) {\r\n                prev_cc = cc\r\n                continue\r\n            }\r\n            let j = i - 1\r\n            while (true) {\r\n                let tmp = ret[j + 1]\r\n                ret[j + 1] = ret[j]\r\n                ret[j] = tmp\r\n                if (!j) break\r\n                prev_cc = unpack_cc(ret[--j])\r\n                if (prev_cc <= cc) break\r\n            }\r\n            prev_cc = unpack_cc(ret[i])\r\n        }\r\n    }\r\n    return ret\r\n}\r\nfunction composed_from_decomposed(v) {\r\n    let ret = []\r\n    let stack = []\r\n    let prev_cp = -1\r\n    let prev_cc = 0\r\n    for (let packed of v) {\r\n        let cc = unpack_cc(packed)\r\n        let cp = unpack_cp(packed)\r\n        if (prev_cp == -1) {\r\n            if (cc == 0) {\r\n                prev_cp = cp\r\n            } else {\r\n                ret.push(cp)\r\n            }\r\n        } else if (prev_cc > 0 && prev_cc >= cc) {\r\n            if (cc == 0) {\r\n                ret.push(prev_cp, ...stack)\r\n                stack.length = 0\r\n                prev_cp = cp\r\n            } else {\r\n                stack.push(cp)\r\n            }\r\n            prev_cc = cc\r\n        } else {\r\n            let composed = compose_pair(prev_cp, cp)\r\n            if (composed >= 0) {\r\n                prev_cp = composed\r\n            } else if (prev_cc == 0 && cc == 0) {\r\n                ret.push(prev_cp)\r\n                prev_cp = cp\r\n            } else {\r\n                stack.push(cp)\r\n                prev_cc = cc\r\n            }\r\n        }\r\n    }\r\n    if (prev_cp >= 0) {\r\n        ret.push(prev_cp, ...stack)\r\n    }\r\n    return ret\r\n}\r\nfunction nfd(cps) {\r\n    return decomposed(cps).map(unpack_cp)\r\n}\r\nfunction nfc(cps) {\r\n    return composed_from_decomposed(decomposed(cps))\r\n}\r\nconst HYPHEN = 45\r\nconst STOP_CH = \".\"\r\nconst FE0F = 65039\r\nconst UNIQUE_PH = 1\r\nconst Array_from = (x) => Array.from(x)\r\nfunction group_has_cp(g, cp) {\r\n    return g.P.has(cp) || g.Q.has(cp)\r\n}\r\nclass Emoji extends Array {\r\n    get is_emoji() {\r\n        return true\r\n    }\r\n}\r\nlet MAPPED,\r\n    IGNORED,\r\n    CM,\r\n    NSM,\r\n    ESCAPE,\r\n    GROUPS,\r\n    WHOLE_VALID,\r\n    WHOLE_MAP,\r\n    VALID,\r\n    EMOJI_LIST,\r\n    EMOJI_ROOT\r\nfunction init() {\r\n    if (MAPPED) return\r\n    let r = read_compressed_payload(COMPRESSED$1)\r\n    const read_sorted_array = () => read_sorted(r)\r\n    const read_sorted_set = () => new Set(read_sorted_array())\r\n    MAPPED = new Map(read_mapped(r))\r\n    IGNORED = read_sorted_set()\r\n    CM = read_sorted_array()\r\n    NSM = new Set(read_sorted_array().map((i) => CM[i]))\r\n    CM = new Set(CM)\r\n    ESCAPE = read_sorted_set()\r\n    read_sorted_set()\r\n    let chunks = read_sorted_arrays(r)\r\n    let unrestricted = r()\r\n    const read_chunked = () =>\r\n        new Set(\r\n            read_sorted_array()\r\n                .flatMap((i) => chunks[i])\r\n                .concat(read_sorted_array()),\r\n        )\r\n    GROUPS = read_array_while((i) => {\r\n        let N = read_array_while(r).map((x) => x + 96)\r\n        if (N.length) {\r\n            let R = i >= unrestricted\r\n            N[0] -= 32\r\n            N = str_from_cps(N)\r\n            if (R) N = `Restricted[${N}]`\r\n            let P = read_chunked()\r\n            let Q = read_chunked()\r\n            let M = !r()\r\n            return {\r\n                N: N,\r\n                P: P,\r\n                Q: Q,\r\n                M: M,\r\n                R: R,\r\n            }\r\n        }\r\n    })\r\n    WHOLE_VALID = read_sorted_set()\r\n    WHOLE_MAP = new Map()\r\n    let wholes = read_sorted_array()\r\n        .concat(Array_from(WHOLE_VALID))\r\n        .sort((a, b) => a - b)\r\n    wholes.forEach((cp, i) => {\r\n        let d = r()\r\n        let w = (wholes[i] = d\r\n            ? wholes[i - d]\r\n            : {\r\n                  V: [],\r\n                  M: new Map(),\r\n              })\r\n        w.V.push(cp)\r\n        if (!WHOLE_VALID.has(cp)) {\r\n            WHOLE_MAP.set(cp, w)\r\n        }\r\n    })\r\n    for (let { V, M } of new Set(WHOLE_MAP.values())) {\r\n        let recs = []\r\n        for (let cp of V) {\r\n            let gs = GROUPS.filter((g) => group_has_cp(g, cp))\r\n            let rec = recs.find(({ G }) => gs.some((g) => G.has(g)))\r\n            if (!rec) {\r\n                rec = {\r\n                    G: new Set(),\r\n                    V: [],\r\n                }\r\n                recs.push(rec)\r\n            }\r\n            rec.V.push(cp)\r\n            gs.forEach((g) => rec.G.add(g))\r\n        }\r\n        let union = recs.flatMap((x) => Array_from(x.G))\r\n        for (let { G, V } of recs) {\r\n            let complement = new Set(union.filter((g) => !G.has(g)))\r\n            for (let cp of V) {\r\n                M.set(cp, complement)\r\n            }\r\n        }\r\n    }\r\n    let union = new Set()\r\n    let multi = new Set()\r\n    const add_to_union = (cp) => (union.has(cp) ? multi.add(cp) : union.add(cp))\r\n    for (let g of GROUPS) {\r\n        for (let cp of g.P) add_to_union(cp)\r\n        for (let cp of g.Q) add_to_union(cp)\r\n    }\r\n    for (let cp of union) {\r\n        if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n            WHOLE_MAP.set(cp, UNIQUE_PH)\r\n        }\r\n    }\r\n    VALID = new Set(Array_from(union).concat(Array_from(nfd(union))))\r\n    EMOJI_LIST = read_trie(r)\r\n        .map((v) => Emoji.from(v))\r\n        .sort(compare_arrays)\r\n    EMOJI_ROOT = new Map()\r\n    for (let cps of EMOJI_LIST) {\r\n        let prev = [EMOJI_ROOT]\r\n        for (let cp of cps) {\r\n            let next = prev.map((node) => {\r\n                let child = node.get(cp)\r\n                if (!child) {\r\n                    child = new Map()\r\n                    node.set(cp, child)\r\n                }\r\n                return child\r\n            })\r\n            if (cp === FE0F) {\r\n                prev.push(...next)\r\n            } else {\r\n                prev = next\r\n            }\r\n        }\r\n        for (let x of prev) {\r\n            x.V = cps\r\n        }\r\n    }\r\n}\r\nfunction quoted_cp(cp) {\r\n    return (\r\n        (should_escape(cp) ? \"\" : `${bidi_qq(safe_str_from_cps([cp]))} `) +\r\n        quote_cp(cp)\r\n    )\r\n}\r\nfunction bidi_qq(s) {\r\n    return `\"${s}\"\\u200E`\r\n}\r\nfunction check_label_extension(cps) {\r\n    if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n        throw new Error(\r\n            `invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`,\r\n        )\r\n    }\r\n}\r\nfunction check_leading_underscore(cps) {\r\n    const UNDERSCORE = 95\r\n    for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n        if (cps[--i] !== UNDERSCORE) {\r\n            throw new Error(\"underscore allowed only at start\")\r\n        }\r\n    }\r\n}\r\nfunction check_fenced(cps) {\r\n    let cp = cps[0]\r\n    let prev = FENCED.get(cp)\r\n    if (prev) throw error_placement(`leading ${prev}`)\r\n    let n = cps.length\r\n    let last = -1\r\n    for (let i = 1; i < n; i++) {\r\n        cp = cps[i]\r\n        let match = FENCED.get(cp)\r\n        if (match) {\r\n            if (last == i) throw error_placement(`${prev} + ${match}`)\r\n            last = i + 1\r\n            prev = match\r\n        }\r\n    }\r\n    if (last == n) throw error_placement(`trailing ${prev}`)\r\n}\r\nfunction safe_str_from_cps(cps, quoter = quote_cp) {\r\n    let buf = []\r\n    if (is_combining_mark(cps[0])) buf.push(\"\")\r\n    let prev = 0\r\n    let n = cps.length\r\n    for (let i = 0; i < n; i++) {\r\n        let cp = cps[i]\r\n        if (should_escape(cp)) {\r\n            buf.push(str_from_cps(cps.slice(prev, i)))\r\n            buf.push(quoter(cp))\r\n            prev = i + 1\r\n        }\r\n    }\r\n    buf.push(str_from_cps(cps.slice(prev, n)))\r\n    return buf.join(\"\")\r\n}\r\nfunction is_combining_mark(cp) {\r\n    init()\r\n    return CM.has(cp)\r\n}\r\nfunction should_escape(cp) {\r\n    init()\r\n    return ESCAPE.has(cp)\r\n}\r\nfunction ens_normalize(name) {\r\n    return flatten(split(name, nfc, filter_fe0f))\r\n}\r\nfunction split(name, nf, ef) {\r\n    if (!name) return []\r\n    init()\r\n    let offset = 0\r\n    return name.split(STOP_CH).map((label) => {\r\n        let input = explode_cp(label)\r\n        let info = {\r\n            input: input,\r\n            offset: offset,\r\n        }\r\n        offset += input.length + 1\r\n        try {\r\n            let tokens = (info.tokens = tokens_from_str(input, nf, ef))\r\n            let token_count = tokens.length\r\n            let type\r\n            if (!token_count) {\r\n                throw new Error(`empty label`)\r\n            }\r\n            let norm = (info.output = tokens.flat())\r\n            check_leading_underscore(norm)\r\n            let emoji = (info.emoji = token_count > 1 || tokens[0].is_emoji)\r\n            if (!emoji && norm.every((cp) => cp < 128)) {\r\n                check_label_extension(norm)\r\n                type = \"ASCII\"\r\n            } else {\r\n                let chars = tokens.flatMap((x) => (x.is_emoji ? [] : x))\r\n                if (!chars.length) {\r\n                    type = \"Emoji\"\r\n                } else {\r\n                    if (CM.has(norm[0]))\r\n                        throw error_placement(\"leading combining mark\")\r\n                    for (let i = 1; i < token_count; i++) {\r\n                        let cps = tokens[i]\r\n                        if (!cps.is_emoji && CM.has(cps[0])) {\r\n                            throw error_placement(\r\n                                `emoji + combining mark: \"${str_from_cps(\r\n                                    tokens[i - 1],\r\n                                )} + ${safe_str_from_cps([cps[0]])}\"`,\r\n                            )\r\n                        }\r\n                    }\r\n                    check_fenced(norm)\r\n                    let unique = Array_from(new Set(chars))\r\n                    let [g] = determine_group(unique)\r\n                    check_group(g, chars)\r\n                    check_whole(g, unique)\r\n                    type = g.N\r\n                }\r\n            }\r\n            info.type = type\r\n        } catch (err) {\r\n            info.error = err\r\n        }\r\n        return info\r\n    })\r\n}\r\nfunction check_whole(group, unique) {\r\n    let maker\r\n    let shared = []\r\n    for (let cp of unique) {\r\n        let whole = WHOLE_MAP.get(cp)\r\n        if (whole === UNIQUE_PH) return\r\n        if (whole) {\r\n            let set = whole.M.get(cp)\r\n            maker = maker ? maker.filter((g) => set.has(g)) : Array_from(set)\r\n            if (!maker.length) return\r\n        } else {\r\n            shared.push(cp)\r\n        }\r\n    }\r\n    if (maker) {\r\n        for (let g of maker) {\r\n            if (shared.every((cp) => group_has_cp(g, cp))) {\r\n                throw new Error(`whole-script confusable: ${group.N}/${g.N}`)\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction determine_group(unique) {\r\n    let groups = GROUPS\r\n    for (let cp of unique) {\r\n        let gs = groups.filter((g) => group_has_cp(g, cp))\r\n        if (!gs.length) {\r\n            if (!GROUPS.some((g) => group_has_cp(g, cp))) {\r\n                throw error_disallowed(cp)\r\n            } else {\r\n                throw error_group_member(groups[0], cp)\r\n            }\r\n        }\r\n        groups = gs\r\n        if (gs.length == 1) break\r\n    }\r\n    return groups\r\n}\r\nfunction flatten(split) {\r\n    return split\r\n        .map(({ input, error, output }) => {\r\n            if (error) {\r\n                let msg = error.message\r\n                throw new Error(\r\n                    split.length == 1\r\n                        ? msg\r\n                        : `Invalid label ${bidi_qq(\r\n                              safe_str_from_cps(input),\r\n                          )}: ${msg}`,\r\n                )\r\n            }\r\n            return str_from_cps(output)\r\n        })\r\n        .join(STOP_CH)\r\n}\r\nfunction error_disallowed(cp) {\r\n    return new Error(`disallowed character: ${quoted_cp(cp)}`)\r\n}\r\nfunction error_group_member(g, cp) {\r\n    let quoted = quoted_cp(cp)\r\n    let gg = GROUPS.find((g) => g.P.has(cp))\r\n    if (gg) {\r\n        quoted = `${gg.N} ${quoted}`\r\n    }\r\n    return new Error(`illegal mixture: ${g.N} + ${quoted}`)\r\n}\r\nfunction error_placement(where) {\r\n    return new Error(`illegal placement: ${where}`)\r\n}\r\nfunction check_group(g, cps) {\r\n    for (let cp of cps) {\r\n        if (!group_has_cp(g, cp)) {\r\n            throw error_group_member(g, cp)\r\n        }\r\n    }\r\n    if (g.M) {\r\n        let decomposed = nfd(cps)\r\n        for (let i = 1, e = decomposed.length; i < e; i++) {\r\n            if (NSM.has(decomposed[i])) {\r\n                let j = i + 1\r\n                for (let cp; j < e && NSM.has((cp = decomposed[j])); j++) {\r\n                    for (let k = i; k < j; k++) {\r\n                        if (decomposed[k] == cp) {\r\n                            throw new Error(\r\n                                `duplicate non-spacing marks: ${quoted_cp(cp)}`,\r\n                            )\r\n                        }\r\n                    }\r\n                }\r\n                if (j - i > NSM_MAX) {\r\n                    throw new Error(\r\n                        `excessive non-spacing marks: ${bidi_qq(\r\n                            safe_str_from_cps(decomposed.slice(i - 1, j)),\r\n                        )} (${j - i}/${NSM_MAX})`,\r\n                    )\r\n                }\r\n                i = j\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction tokens_from_str(input, nf, ef) {\r\n    let ret = []\r\n    let chars = []\r\n    input = input.slice().reverse()\r\n    while (input.length) {\r\n        let emoji = consume_emoji_reversed(input)\r\n        if (emoji) {\r\n            if (chars.length) {\r\n                ret.push(nf(chars))\r\n                chars = []\r\n            }\r\n            ret.push(ef(emoji))\r\n        } else {\r\n            let cp = input.pop()\r\n            if (VALID.has(cp)) {\r\n                chars.push(cp)\r\n            } else {\r\n                let cps = MAPPED.get(cp)\r\n                if (cps) {\r\n                    chars.push(...cps)\r\n                } else if (!IGNORED.has(cp)) {\r\n                    throw error_disallowed(cp)\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (chars.length) {\r\n        ret.push(nf(chars))\r\n    }\r\n    return ret\r\n}\r\nfunction filter_fe0f(cps) {\r\n    return cps.filter((cp) => cp != FE0F)\r\n}\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n    let node = EMOJI_ROOT\r\n    let emoji\r\n    let pos = cps.length\r\n    while (pos) {\r\n        node = node.get(cps[--pos])\r\n        if (!node) break\r\n        let { V } = node\r\n        if (V) {\r\n            emoji = V\r\n            if (eaten) eaten.push(...cps.slice(pos).reverse())\r\n            cps.length = pos\r\n        }\r\n    }\r\n    return emoji\r\n}\r\nconst Zeros = new Uint8Array(32)\r\nZeros.fill(0)\r\nfunction checkComponent(comp) {\r\n    assertArgument(\r\n        comp.length !== 0,\r\n        \"invalid ENS name; empty component\",\r\n        \"comp\",\r\n        comp,\r\n    )\r\n    return comp\r\n}\r\nfunction ensNameSplit(name) {\r\n    const bytes = toUtf8Bytes(ensNormalize(name))\r\n    const comps = []\r\n    if (name.length === 0) {\r\n        return comps\r\n    }\r\n    let last = 0\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        const d = bytes[i]\r\n        if (d === 46) {\r\n            comps.push(checkComponent(bytes.slice(last, i)))\r\n            last = i + 1\r\n        }\r\n    }\r\n    assertArgument(\r\n        last < bytes.length,\r\n        \"invalid ENS name; empty component\",\r\n        \"name\",\r\n        name,\r\n    )\r\n    comps.push(checkComponent(bytes.slice(last)))\r\n    return comps\r\n}\r\nfunction ensNormalize(name) {\r\n    try {\r\n        if (name.length === 0) {\r\n            throw new Error(\"empty label\")\r\n        }\r\n        return ens_normalize(name)\r\n    } catch (error) {\r\n        assertArgument(\r\n            false,\r\n            `invalid ENS name (${error.message})`,\r\n            \"name\",\r\n            name,\r\n        )\r\n    }\r\n}\r\nfunction isValidName(name) {\r\n    try {\r\n        return ensNameSplit(name).length !== 0\r\n    } catch (error) {}\r\n    return false\r\n}\r\nfunction namehash(name) {\r\n    assertArgument(\r\n        typeof name === \"string\",\r\n        \"invalid ENS name; not a string\",\r\n        \"name\",\r\n        name,\r\n    )\r\n    assertArgument(name.length, `invalid ENS name (empty label)`, \"name\", name)\r\n    let result = Zeros\r\n    const comps = ensNameSplit(name)\r\n    while (comps.length) {\r\n        result = keccak256(concat([result, keccak256(comps.pop())]))\r\n    }\r\n    return hexlify(result)\r\n}\r\nfunction dnsEncode(name) {\r\n    return (\r\n        hexlify(\r\n            concat(\r\n                ensNameSplit(name).map((comp) => {\r\n                    if (comp.length > 63) {\r\n                        throw new Error(\r\n                            \"invalid DNS encoded entry; length exceeds 63 bytes\",\r\n                        )\r\n                    }\r\n                    const bytes = new Uint8Array(comp.length + 1)\r\n                    bytes.set(comp, 1)\r\n                    bytes[0] = bytes.length - 1\r\n                    return bytes\r\n                }),\r\n            ),\r\n        ) + \"00\"\r\n    )\r\n}\r\nfunction accessSetify(addr, storageKeys) {\r\n    return {\r\n        address: getAddress(addr),\r\n        storageKeys: storageKeys.map((storageKey, index) => {\r\n            assertArgument(\r\n                isHexString(storageKey, 32),\r\n                \"invalid slot\",\r\n                `storageKeys[${index}]`,\r\n                storageKey,\r\n            )\r\n            return storageKey.toLowerCase()\r\n        }),\r\n    }\r\n}\r\nfunction accessListify(value) {\r\n    if (Array.isArray(value)) {\r\n        return value.map((set, index) => {\r\n            if (Array.isArray(set)) {\r\n                assertArgument(\r\n                    set.length === 2,\r\n                    \"invalid slot set\",\r\n                    `value[${index}]`,\r\n                    set,\r\n                )\r\n                return accessSetify(set[0], set[1])\r\n            }\r\n            assertArgument(\r\n                set != null && typeof set === \"object\",\r\n                \"invalid address-slot set\",\r\n                \"value\",\r\n                value,\r\n            )\r\n            return accessSetify(set.address, set.storageKeys)\r\n        })\r\n    }\r\n    assertArgument(\r\n        value != null && typeof value === \"object\",\r\n        \"invalid access list\",\r\n        \"value\",\r\n        value,\r\n    )\r\n    const result = Object.keys(value).map((addr) => {\r\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\r\n            accum[storageKey] = true\r\n            return accum\r\n        }, {})\r\n        return accessSetify(addr, Object.keys(storageKeys).sort())\r\n    })\r\n    result.sort((a, b) => a.address.localeCompare(b.address))\r\n    return result\r\n}\r\nfunction computeAddress(key) {\r\n    let pubkey\r\n    if (typeof key === \"string\") {\r\n        pubkey = SigningKey.computePublicKey(key, false)\r\n    } else {\r\n        pubkey = key.publicKey\r\n    }\r\n    return getAddress(keccak256(\"0x\" + pubkey.substring(4)).substring(26))\r\n}\r\nfunction recoverAddress(digest, signature) {\r\n    return computeAddress(SigningKey.recoverPublicKey(digest, signature))\r\n}\r\nconst BN_0$4 = BigInt(0)\r\nconst BN_2$2 = BigInt(2)\r\nconst BN_27 = BigInt(27)\r\nconst BN_28 = BigInt(28)\r\nconst BN_35 = BigInt(35)\r\nconst BN_MAX_UINT = BigInt(\r\n    \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\r\n)\r\nfunction handleAddress(value) {\r\n    if (value === \"0x\") {\r\n        return null\r\n    }\r\n    return getAddress(value)\r\n}\r\nfunction handleAccessList(value, param) {\r\n    try {\r\n        return accessListify(value)\r\n    } catch (error) {\r\n        assertArgument(false, error.message, param, value)\r\n    }\r\n}\r\nfunction handleNumber(_value, param) {\r\n    if (_value === \"0x\") {\r\n        return 0\r\n    }\r\n    return getNumber(_value, param)\r\n}\r\nfunction handleUint(_value, param) {\r\n    if (_value === \"0x\") {\r\n        return BN_0$4\r\n    }\r\n    const value = getBigInt(_value, param)\r\n    assertArgument(\r\n        value <= BN_MAX_UINT,\r\n        \"value exceeds uint size\",\r\n        param,\r\n        value,\r\n    )\r\n    return value\r\n}\r\nfunction formatNumber(_value, name) {\r\n    const value = getBigInt(_value, \"value\")\r\n    const result = toBeArray(value)\r\n    assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value)\r\n    return result\r\n}\r\nfunction formatAccessList(value) {\r\n    return accessListify(value).map((set) => [set.address, set.storageKeys])\r\n}\r\nfunction _parseLegacy(data) {\r\n    const fields = decodeRlp(data)\r\n    assertArgument(\r\n        Array.isArray(fields) && (fields.length === 9 || fields.length === 6),\r\n        \"invalid field count for legacy transaction\",\r\n        \"data\",\r\n        data,\r\n    )\r\n    const tx = {\r\n        type: 0,\r\n        nonce: handleNumber(fields[0], \"nonce\"),\r\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\r\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\r\n        to: handleAddress(fields[3]),\r\n        value: handleUint(fields[4], \"value\"),\r\n        data: hexlify(fields[5]),\r\n        chainId: BN_0$4,\r\n    }\r\n    if (fields.length === 6) {\r\n        return tx\r\n    }\r\n    const v = handleUint(fields[6], \"v\")\r\n    const r = handleUint(fields[7], \"r\")\r\n    const s = handleUint(fields[8], \"s\")\r\n    if (r === BN_0$4 && s === BN_0$4) {\r\n        tx.chainId = v\r\n    } else {\r\n        let chainId = (v - BN_35) / BN_2$2\r\n        if (chainId < BN_0$4) {\r\n            chainId = BN_0$4\r\n        }\r\n        tx.chainId = chainId\r\n        assertArgument(\r\n            chainId !== BN_0$4 || v === BN_27 || v === BN_28,\r\n            \"non-canonical legacy v\",\r\n            \"v\",\r\n            fields[6],\r\n        )\r\n        tx.signature = Signature.from({\r\n            r: zeroPadValue(fields[7], 32),\r\n            s: zeroPadValue(fields[8], 32),\r\n            v: v,\r\n        })\r\n        tx.hash = keccak256(data)\r\n    }\r\n    return tx\r\n}\r\nfunction _serializeLegacy(tx, sig) {\r\n    const fields = [\r\n        formatNumber(tx.nonce || 0, \"nonce\"),\r\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\r\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\r\n        tx.to != null ? getAddress(tx.to) : \"0x\",\r\n        formatNumber(tx.value || 0, \"value\"),\r\n        tx.data || \"0x\",\r\n    ]\r\n    let chainId = BN_0$4\r\n    if (tx.chainId != BN_0$4) {\r\n        chainId = getBigInt(tx.chainId, \"tx.chainId\")\r\n        assertArgument(\r\n            !sig || sig.networkV == null || sig.legacyChainId === chainId,\r\n            \"tx.chainId/sig.v mismatch\",\r\n            \"sig\",\r\n            sig,\r\n        )\r\n    } else if (tx.signature) {\r\n        const legacy = tx.signature.legacyChainId\r\n        if (legacy != null) {\r\n            chainId = legacy\r\n        }\r\n    }\r\n    if (!sig) {\r\n        if (chainId !== BN_0$4) {\r\n            fields.push(toBeArray(chainId))\r\n            fields.push(\"0x\")\r\n            fields.push(\"0x\")\r\n        }\r\n        return encodeRlp(fields)\r\n    }\r\n    let v = BigInt(27 + sig.yParity)\r\n    if (chainId !== BN_0$4) {\r\n        v = Signature.getChainIdV(chainId, sig.v)\r\n    } else if (BigInt(sig.v) !== v) {\r\n        assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig)\r\n    }\r\n    fields.push(toBeArray(v))\r\n    fields.push(toBeArray(sig.r))\r\n    fields.push(toBeArray(sig.s))\r\n    return encodeRlp(fields)\r\n}\r\nfunction _parseEipSignature(tx, fields) {\r\n    let yParity\r\n    try {\r\n        yParity = handleNumber(fields[0], \"yParity\")\r\n        if (yParity !== 0 && yParity !== 1) {\r\n            throw new Error(\"bad yParity\")\r\n        }\r\n    } catch (error) {\r\n        assertArgument(false, \"invalid yParity\", \"yParity\", fields[0])\r\n    }\r\n    const r = zeroPadValue(fields[1], 32)\r\n    const s = zeroPadValue(fields[2], 32)\r\n    const signature = Signature.from({\r\n        r: r,\r\n        s: s,\r\n        yParity: yParity,\r\n    })\r\n    tx.signature = signature\r\n}\r\nfunction _parseEip1559(data) {\r\n    const fields = decodeRlp(getBytes(data).slice(1))\r\n    assertArgument(\r\n        Array.isArray(fields) && (fields.length === 9 || fields.length === 12),\r\n        \"invalid field count for transaction type: 2\",\r\n        \"data\",\r\n        hexlify(data),\r\n    )\r\n    const maxPriorityFeePerGas = handleUint(fields[2], \"maxPriorityFeePerGas\")\r\n    const maxFeePerGas = handleUint(fields[3], \"maxFeePerGas\")\r\n    const tx = {\r\n        type: 2,\r\n        chainId: handleUint(fields[0], \"chainId\"),\r\n        nonce: handleNumber(fields[1], \"nonce\"),\r\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\r\n        maxFeePerGas: maxFeePerGas,\r\n        gasPrice: null,\r\n        gasLimit: handleUint(fields[4], \"gasLimit\"),\r\n        to: handleAddress(fields[5]),\r\n        value: handleUint(fields[6], \"value\"),\r\n        data: hexlify(fields[7]),\r\n        accessList: handleAccessList(fields[8], \"accessList\"),\r\n    }\r\n    if (fields.length === 9) {\r\n        return tx\r\n    }\r\n    tx.hash = keccak256(data)\r\n    _parseEipSignature(tx, fields.slice(9))\r\n    return tx\r\n}\r\nfunction _serializeEip1559(tx, sig) {\r\n    const fields = [\r\n        formatNumber(tx.chainId || 0, \"chainId\"),\r\n        formatNumber(tx.nonce || 0, \"nonce\"),\r\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\r\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\r\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\r\n        tx.to != null ? getAddress(tx.to) : \"0x\",\r\n        formatNumber(tx.value || 0, \"value\"),\r\n        tx.data || \"0x\",\r\n        formatAccessList(tx.accessList || []),\r\n    ]\r\n    if (sig) {\r\n        fields.push(formatNumber(sig.yParity, \"yParity\"))\r\n        fields.push(toBeArray(sig.r))\r\n        fields.push(toBeArray(sig.s))\r\n    }\r\n    return concat([\"0x02\", encodeRlp(fields)])\r\n}\r\nfunction _parseEip2930(data) {\r\n    const fields = decodeRlp(getBytes(data).slice(1))\r\n    assertArgument(\r\n        Array.isArray(fields) && (fields.length === 8 || fields.length === 11),\r\n        \"invalid field count for transaction type: 1\",\r\n        \"data\",\r\n        hexlify(data),\r\n    )\r\n    const tx = {\r\n        type: 1,\r\n        chainId: handleUint(fields[0], \"chainId\"),\r\n        nonce: handleNumber(fields[1], \"nonce\"),\r\n        gasPrice: handleUint(fields[2], \"gasPrice\"),\r\n        gasLimit: handleUint(fields[3], \"gasLimit\"),\r\n        to: handleAddress(fields[4]),\r\n        value: handleUint(fields[5], \"value\"),\r\n        data: hexlify(fields[6]),\r\n        accessList: handleAccessList(fields[7], \"accessList\"),\r\n    }\r\n    if (fields.length === 8) {\r\n        return tx\r\n    }\r\n    tx.hash = keccak256(data)\r\n    _parseEipSignature(tx, fields.slice(8))\r\n    return tx\r\n}\r\nfunction _serializeEip2930(tx, sig) {\r\n    const fields = [\r\n        formatNumber(tx.chainId || 0, \"chainId\"),\r\n        formatNumber(tx.nonce || 0, \"nonce\"),\r\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\r\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\r\n        tx.to != null ? getAddress(tx.to) : \"0x\",\r\n        formatNumber(tx.value || 0, \"value\"),\r\n        tx.data || \"0x\",\r\n        formatAccessList(tx.accessList || []),\r\n    ]\r\n    if (sig) {\r\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"))\r\n        fields.push(toBeArray(sig.r))\r\n        fields.push(toBeArray(sig.s))\r\n    }\r\n    return concat([\"0x01\", encodeRlp(fields)])\r\n}\r\nclass Transaction {\r\n    #type\r\n    #to\r\n    #data\r\n    #nonce\r\n    #gasLimit\r\n    #gasPrice\r\n    #maxPriorityFeePerGas\r\n    #maxFeePerGas\r\n    #value\r\n    #chainId\r\n    #sig\r\n    #accessList\r\n    get type() {\r\n        return this.#type\r\n    }\r\n    set type(value) {\r\n        switch (value) {\r\n            case null:\r\n                this.#type = null\r\n                break\r\n            case 0:\r\n            case \"legacy\":\r\n                this.#type = 0\r\n                break\r\n            case 1:\r\n            case \"berlin\":\r\n            case \"eip-2930\":\r\n                this.#type = 1\r\n                break\r\n            case 2:\r\n            case \"london\":\r\n            case \"eip-1559\":\r\n                this.#type = 2\r\n                break\r\n            default:\r\n                assertArgument(\r\n                    false,\r\n                    \"unsupported transaction type\",\r\n                    \"type\",\r\n                    value,\r\n                )\r\n        }\r\n    }\r\n    get typeName() {\r\n        switch (this.type) {\r\n            case 0:\r\n                return \"legacy\"\r\n            case 1:\r\n                return \"eip-2930\"\r\n            case 2:\r\n                return \"eip-1559\"\r\n        }\r\n        return null\r\n    }\r\n    get to() {\r\n        return this.#to\r\n    }\r\n    set to(value) {\r\n        this.#to = value == null ? null : getAddress(value)\r\n    }\r\n    get nonce() {\r\n        return this.#nonce\r\n    }\r\n    set nonce(value) {\r\n        this.#nonce = getNumber(value, \"value\")\r\n    }\r\n    get gasLimit() {\r\n        return this.#gasLimit\r\n    }\r\n    set gasLimit(value) {\r\n        this.#gasLimit = getBigInt(value)\r\n    }\r\n    get gasPrice() {\r\n        const value = this.#gasPrice\r\n        if (value == null && (this.type === 0 || this.type === 1)) {\r\n            return BN_0$4\r\n        }\r\n        return value\r\n    }\r\n    set gasPrice(value) {\r\n        this.#gasPrice = value == null ? null : getBigInt(value, \"gasPrice\")\r\n    }\r\n    get maxPriorityFeePerGas() {\r\n        const value = this.#maxPriorityFeePerGas\r\n        if (value == null) {\r\n            if (this.type === 2) {\r\n                return BN_0$4\r\n            }\r\n            return null\r\n        }\r\n        return value\r\n    }\r\n    set maxPriorityFeePerGas(value) {\r\n        this.#maxPriorityFeePerGas =\r\n            value == null ? null : getBigInt(value, \"maxPriorityFeePerGas\")\r\n    }\r\n    get maxFeePerGas() {\r\n        const value = this.#maxFeePerGas\r\n        if (value == null) {\r\n            if (this.type === 2) {\r\n                return BN_0$4\r\n            }\r\n            return null\r\n        }\r\n        return value\r\n    }\r\n    set maxFeePerGas(value) {\r\n        this.#maxFeePerGas =\r\n            value == null ? null : getBigInt(value, \"maxFeePerGas\")\r\n    }\r\n    get data() {\r\n        return this.#data\r\n    }\r\n    set data(value) {\r\n        this.#data = hexlify(value)\r\n    }\r\n    get value() {\r\n        return this.#value\r\n    }\r\n    set value(value) {\r\n        this.#value = getBigInt(value, \"value\")\r\n    }\r\n    get chainId() {\r\n        return this.#chainId\r\n    }\r\n    set chainId(value) {\r\n        this.#chainId = getBigInt(value)\r\n    }\r\n    get signature() {\r\n        return this.#sig || null\r\n    }\r\n    set signature(value) {\r\n        this.#sig = value == null ? null : Signature.from(value)\r\n    }\r\n    get accessList() {\r\n        const value = this.#accessList || null\r\n        if (value == null) {\r\n            if (this.type === 1 || this.type === 2) {\r\n                return []\r\n            }\r\n            return null\r\n        }\r\n        return value\r\n    }\r\n    set accessList(value) {\r\n        this.#accessList = value == null ? null : accessListify(value)\r\n    }\r\n    constructor() {\r\n        this.#type = null\r\n        this.#to = null\r\n        this.#nonce = 0\r\n        this.#gasLimit = BigInt(0)\r\n        this.#gasPrice = null\r\n        this.#maxPriorityFeePerGas = null\r\n        this.#maxFeePerGas = null\r\n        this.#data = \"0x\"\r\n        this.#value = BigInt(0)\r\n        this.#chainId = BigInt(0)\r\n        this.#sig = null\r\n        this.#accessList = null\r\n    }\r\n    get hash() {\r\n        if (this.signature == null) {\r\n            return null\r\n        }\r\n        return keccak256(this.serialized)\r\n    }\r\n    get unsignedHash() {\r\n        return keccak256(this.unsignedSerialized)\r\n    }\r\n    get from() {\r\n        if (this.signature == null) {\r\n            return null\r\n        }\r\n        return recoverAddress(this.unsignedHash, this.signature)\r\n    }\r\n    get fromPublicKey() {\r\n        if (this.signature == null) {\r\n            return null\r\n        }\r\n        return SigningKey.recoverPublicKey(this.unsignedHash, this.signature)\r\n    }\r\n    isSigned() {\r\n        return this.signature != null\r\n    }\r\n    get serialized() {\r\n        assert(\r\n            this.signature != null,\r\n            \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \".serialized\",\r\n            },\r\n        )\r\n        switch (this.inferType()) {\r\n            case 0:\r\n                return _serializeLegacy(this, this.signature)\r\n            case 1:\r\n                return _serializeEip2930(this, this.signature)\r\n            case 2:\r\n                return _serializeEip1559(this, this.signature)\r\n        }\r\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \".serialized\",\r\n        })\r\n    }\r\n    get unsignedSerialized() {\r\n        switch (this.inferType()) {\r\n            case 0:\r\n                return _serializeLegacy(this)\r\n            case 1:\r\n                return _serializeEip2930(this)\r\n            case 2:\r\n                return _serializeEip1559(this)\r\n        }\r\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \".unsignedSerialized\",\r\n        })\r\n    }\r\n    inferType() {\r\n        return this.inferTypes().pop()\r\n    }\r\n    inferTypes() {\r\n        const hasGasPrice = this.gasPrice != null\r\n        const hasFee =\r\n            this.maxFeePerGas != null || this.maxPriorityFeePerGas != null\r\n        const hasAccessList = this.accessList != null\r\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\r\n            assert(\r\n                this.maxFeePerGas >= this.maxPriorityFeePerGas,\r\n                \"priorityFee cannot be more than maxFee\",\r\n                \"BAD_DATA\",\r\n                {\r\n                    value: this,\r\n                },\r\n            )\r\n        }\r\n        assert(\r\n            !hasFee || (this.type !== 0 && this.type !== 1),\r\n            \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\",\r\n            \"BAD_DATA\",\r\n            {\r\n                value: this,\r\n            },\r\n        )\r\n        assert(\r\n            this.type !== 0 || !hasAccessList,\r\n            \"legacy transaction cannot have accessList\",\r\n            \"BAD_DATA\",\r\n            {\r\n                value: this,\r\n            },\r\n        )\r\n        const types = []\r\n        if (this.type != null) {\r\n            types.push(this.type)\r\n        } else {\r\n            if (hasFee) {\r\n                types.push(2)\r\n            } else if (hasGasPrice) {\r\n                types.push(1)\r\n                if (!hasAccessList) {\r\n                    types.push(0)\r\n                }\r\n            } else if (hasAccessList) {\r\n                types.push(1)\r\n                types.push(2)\r\n            } else {\r\n                types.push(0)\r\n                types.push(1)\r\n                types.push(2)\r\n            }\r\n        }\r\n        types.sort()\r\n        return types\r\n    }\r\n    isLegacy() {\r\n        return this.type === 0\r\n    }\r\n    isBerlin() {\r\n        return this.type === 1\r\n    }\r\n    isLondon() {\r\n        return this.type === 2\r\n    }\r\n    clone() {\r\n        return Transaction.from(this)\r\n    }\r\n    toJSON() {\r\n        const s = (v) => {\r\n            if (v == null) {\r\n                return null\r\n            }\r\n            return v.toString()\r\n        }\r\n        return {\r\n            type: this.type,\r\n            to: this.to,\r\n            data: this.data,\r\n            nonce: this.nonce,\r\n            gasLimit: s(this.gasLimit),\r\n            gasPrice: s(this.gasPrice),\r\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\r\n            maxFeePerGas: s(this.maxFeePerGas),\r\n            value: s(this.value),\r\n            chainId: s(this.chainId),\r\n            sig: this.signature ? this.signature.toJSON() : null,\r\n            accessList: this.accessList,\r\n        }\r\n    }\r\n    static from(tx) {\r\n        if (tx == null) {\r\n            return new Transaction()\r\n        }\r\n        if (typeof tx === \"string\") {\r\n            const payload = getBytes(tx)\r\n            if (payload[0] >= 127) {\r\n                return Transaction.from(_parseLegacy(payload))\r\n            }\r\n            switch (payload[0]) {\r\n                case 1:\r\n                    return Transaction.from(_parseEip2930(payload))\r\n                case 2:\r\n                    return Transaction.from(_parseEip1559(payload))\r\n            }\r\n            assert(\r\n                false,\r\n                \"unsupported transaction type\",\r\n                \"UNSUPPORTED_OPERATION\",\r\n                {\r\n                    operation: \"from\",\r\n                },\r\n            )\r\n        }\r\n        const result = new Transaction()\r\n        if (tx.type != null) {\r\n            result.type = tx.type\r\n        }\r\n        if (tx.to != null) {\r\n            result.to = tx.to\r\n        }\r\n        if (tx.nonce != null) {\r\n            result.nonce = tx.nonce\r\n        }\r\n        if (tx.gasLimit != null) {\r\n            result.gasLimit = tx.gasLimit\r\n        }\r\n        if (tx.gasPrice != null) {\r\n            result.gasPrice = tx.gasPrice\r\n        }\r\n        if (tx.maxPriorityFeePerGas != null) {\r\n            result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas\r\n        }\r\n        if (tx.maxFeePerGas != null) {\r\n            result.maxFeePerGas = tx.maxFeePerGas\r\n        }\r\n        if (tx.data != null) {\r\n            result.data = tx.data\r\n        }\r\n        if (tx.value != null) {\r\n            result.value = tx.value\r\n        }\r\n        if (tx.chainId != null) {\r\n            result.chainId = tx.chainId\r\n        }\r\n        if (tx.signature != null) {\r\n            result.signature = Signature.from(tx.signature)\r\n        }\r\n        if (tx.accessList != null) {\r\n            result.accessList = tx.accessList\r\n        }\r\n        if (tx.hash != null) {\r\n            assertArgument(\r\n                result.isSigned(),\r\n                \"unsigned transaction cannot define hash\",\r\n                \"tx\",\r\n                tx,\r\n            )\r\n            assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx)\r\n        }\r\n        if (tx.from != null) {\r\n            assertArgument(\r\n                result.isSigned(),\r\n                \"unsigned transaction cannot define from\",\r\n                \"tx\",\r\n                tx,\r\n            )\r\n            assertArgument(\r\n                result.from.toLowerCase() === (tx.from || \"\").toLowerCase(),\r\n                \"from mismatch\",\r\n                \"tx\",\r\n                tx,\r\n            )\r\n        }\r\n        return result\r\n    }\r\n}\r\nfunction hashMessage(message) {\r\n    if (typeof message === \"string\") {\r\n        message = toUtf8Bytes(message)\r\n    }\r\n    return keccak256(\r\n        concat([\r\n            toUtf8Bytes(MessagePrefix),\r\n            toUtf8Bytes(String(message.length)),\r\n            message,\r\n        ]),\r\n    )\r\n}\r\nfunction verifyMessage(message, sig) {\r\n    const digest = hashMessage(message)\r\n    return recoverAddress(digest, sig)\r\n}\r\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\")\r\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\")\r\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\")\r\nfunction _pack(type, value, isArray) {\r\n    switch (type) {\r\n        case \"address\":\r\n            if (isArray) {\r\n                return getBytes(zeroPadValue(value, 32))\r\n            }\r\n            return getBytes(getAddress(value))\r\n        case \"string\":\r\n            return toUtf8Bytes(value)\r\n        case \"bytes\":\r\n            return getBytes(value)\r\n        case \"bool\":\r\n            value = !!value ? \"0x01\" : \"0x00\"\r\n            if (isArray) {\r\n                return getBytes(zeroPadValue(value, 32))\r\n            }\r\n            return getBytes(value)\r\n    }\r\n    let match = type.match(regexNumber)\r\n    if (match) {\r\n        let signed = match[1] === \"int\"\r\n        let size = parseInt(match[2] || \"256\")\r\n        assertArgument(\r\n            (!match[2] || match[2] === String(size)) &&\r\n                size % 8 === 0 &&\r\n                size !== 0 &&\r\n                size <= 256,\r\n            \"invalid number type\",\r\n            \"type\",\r\n            type,\r\n        )\r\n        if (isArray) {\r\n            size = 256\r\n        }\r\n        if (signed) {\r\n            value = toTwos(value, size)\r\n        }\r\n        return getBytes(zeroPadValue(toBeArray(value), size / 8))\r\n    }\r\n    match = type.match(regexBytes)\r\n    if (match) {\r\n        const size = parseInt(match[1])\r\n        assertArgument(\r\n            String(size) === match[1] && size !== 0 && size <= 32,\r\n            \"invalid bytes type\",\r\n            \"type\",\r\n            type,\r\n        )\r\n        assertArgument(\r\n            dataLength(value) === size,\r\n            `invalid value for ${type}`,\r\n            \"value\",\r\n            value,\r\n        )\r\n        if (isArray) {\r\n            return getBytes(zeroPadBytes(value, 32))\r\n        }\r\n        return value\r\n    }\r\n    match = type.match(regexArray)\r\n    if (match && Array.isArray(value)) {\r\n        const baseType = match[1]\r\n        const count = parseInt(match[2] || String(value.length))\r\n        assertArgument(\r\n            count === value.length,\r\n            `invalid array length for ${type}`,\r\n            \"value\",\r\n            value,\r\n        )\r\n        const result = []\r\n        value.forEach(function (value) {\r\n            result.push(_pack(baseType, value, true))\r\n        })\r\n        return getBytes(concat(result))\r\n    }\r\n    assertArgument(false, \"invalid type\", \"type\", type)\r\n}\r\nfunction solidityPacked(types, values) {\r\n    assertArgument(\r\n        types.length === values.length,\r\n        \"wrong number of values; expected ${ types.length }\",\r\n        \"values\",\r\n        values,\r\n    )\r\n    const tight = []\r\n    types.forEach(function (type, index) {\r\n        tight.push(_pack(type, values[index]))\r\n    })\r\n    return hexlify(concat(tight))\r\n}\r\nfunction solidityPackedKeccak256(types, values) {\r\n    return keccak256(solidityPacked(types, values))\r\n}\r\nfunction solidityPackedSha256(types, values) {\r\n    return sha256(solidityPacked(types, values))\r\n}\r\nconst padding = new Uint8Array(32)\r\npadding.fill(0)\r\nconst BN__1 = BigInt(-1)\r\nconst BN_0$3 = BigInt(0)\r\nconst BN_1$1 = BigInt(1)\r\nconst BN_MAX_UINT256 = BigInt(\r\n    \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\r\n)\r\nfunction hexPadRight(value) {\r\n    const bytes = getBytes(value)\r\n    const padOffset = bytes.length % 32\r\n    if (padOffset) {\r\n        return concat([bytes, padding.slice(padOffset)])\r\n    }\r\n    return hexlify(bytes)\r\n}\r\nconst hexTrue = toBeHex(BN_1$1, 32)\r\nconst hexFalse = toBeHex(BN_0$3, 32)\r\nconst domainFieldTypes = {\r\n    name: \"string\",\r\n    version: \"string\",\r\n    chainId: \"uint256\",\r\n    verifyingContract: \"address\",\r\n    salt: \"bytes32\",\r\n}\r\nconst domainFieldNames = [\r\n    \"name\",\r\n    \"version\",\r\n    \"chainId\",\r\n    \"verifyingContract\",\r\n    \"salt\",\r\n]\r\nfunction checkString(key) {\r\n    return function (value) {\r\n        assertArgument(\r\n            typeof value === \"string\",\r\n            `invalid domain value for ${JSON.stringify(key)}`,\r\n            `domain.${key}`,\r\n            value,\r\n        )\r\n        return value\r\n    }\r\n}\r\nconst domainChecks = {\r\n    name: checkString(\"name\"),\r\n    version: checkString(\"version\"),\r\n    chainId: function (_value) {\r\n        const value = getBigInt(_value, \"domain.chainId\")\r\n        assertArgument(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value)\r\n        if (Number.isSafeInteger(value)) {\r\n            return Number(value)\r\n        }\r\n        return toQuantity(value)\r\n    },\r\n    verifyingContract: function (value) {\r\n        try {\r\n            return getAddress(value).toLowerCase()\r\n        } catch (error) {}\r\n        assertArgument(\r\n            false,\r\n            `invalid domain value \"verifyingContract\"`,\r\n            \"domain.verifyingContract\",\r\n            value,\r\n        )\r\n    },\r\n    salt: function (value) {\r\n        const bytes = getBytes(value, \"domain.salt\")\r\n        assertArgument(\r\n            bytes.length === 32,\r\n            `invalid domain value \"salt\"`,\r\n            \"domain.salt\",\r\n            value,\r\n        )\r\n        return hexlify(bytes)\r\n    },\r\n}\r\nfunction getBaseEncoder(type) {\r\n    {\r\n        const match = type.match(/^(u?)int(\\d*)$/)\r\n        if (match) {\r\n            const signed = match[1] === \"\"\r\n            const width = parseInt(match[2] || \"256\")\r\n            assertArgument(\r\n                width % 8 === 0 &&\r\n                    width !== 0 &&\r\n                    width <= 256 &&\r\n                    (match[2] == null || match[2] === String(width)),\r\n                \"invalid numeric width\",\r\n                \"type\",\r\n                type,\r\n            )\r\n            const boundsUpper = mask(BN_MAX_UINT256, signed ? width - 1 : width)\r\n            const boundsLower = signed ? (boundsUpper + BN_1$1) * BN__1 : BN_0$3\r\n            return function (_value) {\r\n                const value = getBigInt(_value, \"value\")\r\n                assertArgument(\r\n                    value >= boundsLower && value <= boundsUpper,\r\n                    `value out-of-bounds for ${type}`,\r\n                    \"value\",\r\n                    value,\r\n                )\r\n                return toBeHex(signed ? toTwos(value, 256) : value, 32)\r\n            }\r\n        }\r\n    }\r\n    {\r\n        const match = type.match(/^bytes(\\d+)$/)\r\n        if (match) {\r\n            const width = parseInt(match[1])\r\n            assertArgument(\r\n                width !== 0 && width <= 32 && match[1] === String(width),\r\n                \"invalid bytes width\",\r\n                \"type\",\r\n                type,\r\n            )\r\n            return function (value) {\r\n                const bytes = getBytes(value)\r\n                assertArgument(\r\n                    bytes.length === width,\r\n                    `invalid length for ${type}`,\r\n                    \"value\",\r\n                    value,\r\n                )\r\n                return hexPadRight(value)\r\n            }\r\n        }\r\n    }\r\n    switch (type) {\r\n        case \"address\":\r\n            return function (value) {\r\n                return zeroPadValue(getAddress(value), 32)\r\n            }\r\n        case \"bool\":\r\n            return function (value) {\r\n                return !value ? hexFalse : hexTrue\r\n            }\r\n        case \"bytes\":\r\n            return function (value) {\r\n                return keccak256(value)\r\n            }\r\n        case \"string\":\r\n            return function (value) {\r\n                return id(value)\r\n            }\r\n    }\r\n    return null\r\n}\r\nfunction encodeType(name, fields) {\r\n    return `${name}(${fields\r\n        .map(({ name, type }) => type + \" \" + name)\r\n        .join(\",\")})`\r\n}\r\nclass TypedDataEncoder {\r\n    primaryType\r\n    #types\r\n    get types() {\r\n        return JSON.parse(this.#types)\r\n    }\r\n    #fullTypes\r\n    #encoderCache\r\n    constructor(types) {\r\n        this.#types = JSON.stringify(types)\r\n        this.#fullTypes = new Map()\r\n        this.#encoderCache = new Map()\r\n        const links = new Map()\r\n        const parents = new Map()\r\n        const subtypes = new Map()\r\n        Object.keys(types).forEach((type) => {\r\n            links.set(type, new Set())\r\n            parents.set(type, [])\r\n            subtypes.set(type, new Set())\r\n        })\r\n        for (const name in types) {\r\n            const uniqueNames = new Set()\r\n            for (const field of types[name]) {\r\n                assertArgument(\r\n                    !uniqueNames.has(field.name),\r\n                    `duplicate variable name ${JSON.stringify(\r\n                        field.name,\r\n                    )} in ${JSON.stringify(name)}`,\r\n                    \"types\",\r\n                    types,\r\n                )\r\n                uniqueNames.add(field.name)\r\n                const baseType =\r\n                    field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1] || null\r\n                assertArgument(\r\n                    baseType !== name,\r\n                    `circular type reference to ${JSON.stringify(baseType)}`,\r\n                    \"types\",\r\n                    types,\r\n                )\r\n                const encoder = getBaseEncoder(baseType)\r\n                if (encoder) {\r\n                    continue\r\n                }\r\n                assertArgument(\r\n                    parents.has(baseType),\r\n                    `unknown type ${JSON.stringify(baseType)}`,\r\n                    \"types\",\r\n                    types,\r\n                )\r\n                parents.get(baseType).push(name)\r\n                links.get(name).add(baseType)\r\n            }\r\n        }\r\n        const primaryTypes = Array.from(parents.keys()).filter(\r\n            (n) => parents.get(n).length === 0,\r\n        )\r\n        assertArgument(\r\n            primaryTypes.length !== 0,\r\n            \"missing primary type\",\r\n            \"types\",\r\n            types,\r\n        )\r\n        assertArgument(\r\n            primaryTypes.length === 1,\r\n            `ambiguous primary types or unused types: ${primaryTypes\r\n                .map((t) => JSON.stringify(t))\r\n                .join(\", \")}`,\r\n            \"types\",\r\n            types,\r\n        )\r\n        defineProperties(this, {\r\n            primaryType: primaryTypes[0],\r\n        })\r\n        function checkCircular(type, found) {\r\n            assertArgument(\r\n                !found.has(type),\r\n                `circular type reference to ${JSON.stringify(type)}`,\r\n                \"types\",\r\n                types,\r\n            )\r\n            found.add(type)\r\n            for (const child of links.get(type)) {\r\n                if (!parents.has(child)) {\r\n                    continue\r\n                }\r\n                checkCircular(child, found)\r\n                for (const subtype of found) {\r\n                    subtypes.get(subtype).add(child)\r\n                }\r\n            }\r\n            found.delete(type)\r\n        }\r\n        checkCircular(this.primaryType, new Set())\r\n        for (const [name, set] of subtypes) {\r\n            const st = Array.from(set)\r\n            st.sort()\r\n            this.#fullTypes.set(\r\n                name,\r\n                encodeType(name, types[name]) +\r\n                    st.map((t) => encodeType(t, types[t])).join(\"\"),\r\n            )\r\n        }\r\n    }\r\n    getEncoder(type) {\r\n        let encoder = this.#encoderCache.get(type)\r\n        if (!encoder) {\r\n            encoder = this.#getEncoder(type)\r\n            this.#encoderCache.set(type, encoder)\r\n        }\r\n        return encoder\r\n    }\r\n    #getEncoder(type) {\r\n        {\r\n            const encoder = getBaseEncoder(type)\r\n            if (encoder) {\r\n                return encoder\r\n            }\r\n        }\r\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/)\r\n        if (match) {\r\n            const subtype = match[1]\r\n            const subEncoder = this.getEncoder(subtype)\r\n            return (value) => {\r\n                assertArgument(\r\n                    !match[3] || parseInt(match[3]) === value.length,\r\n                    `array length mismatch; expected length ${parseInt(\r\n                        match[3],\r\n                    )}`,\r\n                    \"value\",\r\n                    value,\r\n                )\r\n                let result = value.map(subEncoder)\r\n                if (this.#fullTypes.has(subtype)) {\r\n                    result = result.map(keccak256)\r\n                }\r\n                return keccak256(concat(result))\r\n            }\r\n        }\r\n        const fields = this.types[type]\r\n        if (fields) {\r\n            const encodedType = id(this.#fullTypes.get(type))\r\n            return (value) => {\r\n                const values = fields.map(({ name, type }) => {\r\n                    const result = this.getEncoder(type)(value[name])\r\n                    if (this.#fullTypes.has(type)) {\r\n                        return keccak256(result)\r\n                    }\r\n                    return result\r\n                })\r\n                values.unshift(encodedType)\r\n                return concat(values)\r\n            }\r\n        }\r\n        assertArgument(false, `unknown type: ${type}`, \"type\", type)\r\n    }\r\n    encodeType(name) {\r\n        const result = this.#fullTypes.get(name)\r\n        assertArgument(\r\n            result,\r\n            `unknown type: ${JSON.stringify(name)}`,\r\n            \"name\",\r\n            name,\r\n        )\r\n        return result\r\n    }\r\n    encodeData(type, value) {\r\n        return this.getEncoder(type)(value)\r\n    }\r\n    hashStruct(name, value) {\r\n        return keccak256(this.encodeData(name, value))\r\n    }\r\n    encode(value) {\r\n        return this.encodeData(this.primaryType, value)\r\n    }\r\n    hash(value) {\r\n        return this.hashStruct(this.primaryType, value)\r\n    }\r\n    _visit(type, value, callback) {\r\n        {\r\n            const encoder = getBaseEncoder(type)\r\n            if (encoder) {\r\n                return callback(type, value)\r\n            }\r\n        }\r\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/)\r\n        if (match) {\r\n            assertArgument(\r\n                !match[3] || parseInt(match[3]) === value.length,\r\n                `array length mismatch; expected length ${parseInt(match[3])}`,\r\n                \"value\",\r\n                value,\r\n            )\r\n            return value.map((v) => this._visit(match[1], v, callback))\r\n        }\r\n        const fields = this.types[type]\r\n        if (fields) {\r\n            return fields.reduce((accum, { name, type }) => {\r\n                accum[name] = this._visit(type, value[name], callback)\r\n                return accum\r\n            }, {})\r\n        }\r\n        assertArgument(false, `unknown type: ${type}`, \"type\", type)\r\n    }\r\n    visit(value, callback) {\r\n        return this._visit(this.primaryType, value, callback)\r\n    }\r\n    static from(types) {\r\n        return new TypedDataEncoder(types)\r\n    }\r\n    static getPrimaryType(types) {\r\n        return TypedDataEncoder.from(types).primaryType\r\n    }\r\n    static hashStruct(name, types, value) {\r\n        return TypedDataEncoder.from(types).hashStruct(name, value)\r\n    }\r\n    static hashDomain(domain) {\r\n        const domainFields = []\r\n        for (const name in domain) {\r\n            if (domain[name] == null) {\r\n                continue\r\n            }\r\n            const type = domainFieldTypes[name]\r\n            assertArgument(\r\n                type,\r\n                `invalid typed-data domain key: ${JSON.stringify(name)}`,\r\n                \"domain\",\r\n                domain,\r\n            )\r\n            domainFields.push({\r\n                name: name,\r\n                type: type,\r\n            })\r\n        }\r\n        domainFields.sort((a, b) => {\r\n            return (\r\n                domainFieldNames.indexOf(a.name) -\r\n                domainFieldNames.indexOf(b.name)\r\n            )\r\n        })\r\n        return TypedDataEncoder.hashStruct(\r\n            \"EIP712Domain\",\r\n            {\r\n                EIP712Domain: domainFields,\r\n            },\r\n            domain,\r\n        )\r\n    }\r\n    static encode(domain, types, value) {\r\n        return concat([\r\n            \"0x1901\",\r\n            TypedDataEncoder.hashDomain(domain),\r\n            TypedDataEncoder.from(types).hash(value),\r\n        ])\r\n    }\r\n    static hash(domain, types, value) {\r\n        return keccak256(TypedDataEncoder.encode(domain, types, value))\r\n    }\r\n    static async resolveNames(domain, types, value, resolveName) {\r\n        domain = Object.assign({}, domain)\r\n        for (const key in domain) {\r\n            if (domain[key] == null) {\r\n                delete domain[key]\r\n            }\r\n        }\r\n        const ensCache = {}\r\n        if (\r\n            domain.verifyingContract &&\r\n            !isHexString(domain.verifyingContract, 20)\r\n        ) {\r\n            ensCache[domain.verifyingContract] = \"0x\"\r\n        }\r\n        const encoder = TypedDataEncoder.from(types)\r\n        encoder.visit(value, (type, value) => {\r\n            if (type === \"address\" && !isHexString(value, 20)) {\r\n                ensCache[value] = \"0x\"\r\n            }\r\n            return value\r\n        })\r\n        for (const name in ensCache) {\r\n            ensCache[name] = await resolveName(name)\r\n        }\r\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\r\n            domain.verifyingContract = ensCache[domain.verifyingContract]\r\n        }\r\n        value = encoder.visit(value, (type, value) => {\r\n            if (type === \"address\" && ensCache[value]) {\r\n                return ensCache[value]\r\n            }\r\n            return value\r\n        })\r\n        return {\r\n            domain: domain,\r\n            value: value,\r\n        }\r\n    }\r\n    static getPayload(domain, types, value) {\r\n        TypedDataEncoder.hashDomain(domain)\r\n        const domainValues = {}\r\n        const domainTypes = []\r\n        domainFieldNames.forEach((name) => {\r\n            const value = domain[name]\r\n            if (value == null) {\r\n                return\r\n            }\r\n            domainValues[name] = domainChecks[name](value)\r\n            domainTypes.push({\r\n                name: name,\r\n                type: domainFieldTypes[name],\r\n            })\r\n        })\r\n        const encoder = TypedDataEncoder.from(types)\r\n        const typesWithDomain = Object.assign({}, types)\r\n        assertArgument(\r\n            typesWithDomain.EIP712Domain == null,\r\n            \"types must not contain EIP712Domain type\",\r\n            \"types.EIP712Domain\",\r\n            types,\r\n        )\r\n        typesWithDomain.EIP712Domain = domainTypes\r\n        encoder.encode(value)\r\n        return {\r\n            types: typesWithDomain,\r\n            domain: domainValues,\r\n            primaryType: encoder.primaryType,\r\n            message: encoder.visit(value, (type, value) => {\r\n                if (type.match(/^bytes(\\d*)/)) {\r\n                    return hexlify(getBytes(value))\r\n                }\r\n                if (type.match(/^u?int/)) {\r\n                    return getBigInt(value).toString()\r\n                }\r\n                switch (type) {\r\n                    case \"address\":\r\n                        return value.toLowerCase()\r\n                    case \"bool\":\r\n                        return !!value\r\n                    case \"string\":\r\n                        assertArgument(\r\n                            typeof value === \"string\",\r\n                            \"invalid string\",\r\n                            \"value\",\r\n                            value,\r\n                        )\r\n                        return value\r\n                }\r\n                assertArgument(false, \"unsupported type\", \"type\", type)\r\n            }),\r\n        }\r\n    }\r\n}\r\nfunction verifyTypedData(domain, types, value, signature) {\r\n    return recoverAddress(\r\n        TypedDataEncoder.hash(domain, types, value),\r\n        signature,\r\n    )\r\n}\r\nfunction setify(items) {\r\n    const result = new Set()\r\n    items.forEach((k) => result.add(k))\r\n    return Object.freeze(result)\r\n}\r\nconst _kwVisibDeploy = \"external public payable\"\r\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"))\r\nconst _kwVisib = \"constant external internal payable private public pure view\"\r\nconst KwVisib = setify(_kwVisib.split(\" \"))\r\nconst _kwTypes = \"constructor error event fallback function receive struct\"\r\nconst KwTypes = setify(_kwTypes.split(\" \"))\r\nconst _kwModifiers = \"calldata memory storage payable indexed\"\r\nconst KwModifiers = setify(_kwModifiers.split(\" \"))\r\nconst _kwOther = \"tuple returns\"\r\nconst _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(\" \")\r\nconst Keywords = setify(_keywords.split(\" \"))\r\nconst SimpleTokens = {\r\n    \"(\": \"OPEN_PAREN\",\r\n    \")\": \"CLOSE_PAREN\",\r\n    \"[\": \"OPEN_BRACKET\",\r\n    \"]\": \"CLOSE_BRACKET\",\r\n    \",\": \"COMMA\",\r\n    \"@\": \"AT\",\r\n}\r\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\")\r\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\")\r\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\")\r\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\")\r\nconst regexType = new RegExp(\r\n    \"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\",\r\n)\r\nclass TokenString {\r\n    #offset\r\n    #tokens\r\n    get offset() {\r\n        return this.#offset\r\n    }\r\n    get length() {\r\n        return this.#tokens.length - this.#offset\r\n    }\r\n    constructor(tokens) {\r\n        this.#offset = 0\r\n        this.#tokens = tokens.slice()\r\n    }\r\n    clone() {\r\n        return new TokenString(this.#tokens)\r\n    }\r\n    reset() {\r\n        this.#offset = 0\r\n    }\r\n    #subTokenString(from = 0, to = 0) {\r\n        return new TokenString(\r\n            this.#tokens.slice(from, to).map((t) => {\r\n                return Object.freeze(\r\n                    Object.assign({}, t, {\r\n                        match: t.match - from,\r\n                        linkBack: t.linkBack - from,\r\n                        linkNext: t.linkNext - from,\r\n                    }),\r\n                )\r\n            }),\r\n        )\r\n    }\r\n    popKeyword(allowed) {\r\n        const top = this.peek()\r\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\r\n            throw new Error(`expected keyword ${top.text}`)\r\n        }\r\n        return this.pop().text\r\n    }\r\n    popType(type) {\r\n        if (this.peek().type !== type) {\r\n            throw new Error(\r\n                `expected ${type}; got ${JSON.stringify(this.peek())}`,\r\n            )\r\n        }\r\n        return this.pop().text\r\n    }\r\n    popParen() {\r\n        const top = this.peek()\r\n        if (top.type !== \"OPEN_PAREN\") {\r\n            throw new Error(\"bad start\")\r\n        }\r\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1)\r\n        this.#offset = top.match + 1\r\n        return result\r\n    }\r\n    popParams() {\r\n        const top = this.peek()\r\n        if (top.type !== \"OPEN_PAREN\") {\r\n            throw new Error(\"bad start\")\r\n        }\r\n        const result = []\r\n        while (this.#offset < top.match - 1) {\r\n            const link = this.peek().linkNext\r\n            result.push(this.#subTokenString(this.#offset + 1, link))\r\n            this.#offset = link\r\n        }\r\n        this.#offset = top.match + 1\r\n        return result\r\n    }\r\n    peek() {\r\n        if (this.#offset >= this.#tokens.length) {\r\n            throw new Error(\"out-of-bounds\")\r\n        }\r\n        return this.#tokens[this.#offset]\r\n    }\r\n    peekKeyword(allowed) {\r\n        const top = this.peekType(\"KEYWORD\")\r\n        return top != null && allowed.has(top) ? top : null\r\n    }\r\n    peekType(type) {\r\n        if (this.length === 0) {\r\n            return null\r\n        }\r\n        const top = this.peek()\r\n        return top.type === type ? top.text : null\r\n    }\r\n    pop() {\r\n        const result = this.peek()\r\n        this.#offset++\r\n        return result\r\n    }\r\n    toString() {\r\n        const tokens = []\r\n        for (let i = this.#offset; i < this.#tokens.length; i++) {\r\n            const token = this.#tokens[i]\r\n            tokens.push(`${token.type}:${token.text}`)\r\n        }\r\n        return `<TokenString ${tokens.join(\" \")}>`\r\n    }\r\n}\r\nfunction lex(text) {\r\n    const tokens = []\r\n    const throwError = (message) => {\r\n        const token =\r\n            offset < text.length ? JSON.stringify(text[offset]) : \"$EOI\"\r\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`)\r\n    }\r\n    let brackets = []\r\n    let commas = []\r\n    let offset = 0\r\n    while (offset < text.length) {\r\n        let cur = text.substring(offset)\r\n        let match = cur.match(regexWhitespacePrefix)\r\n        if (match) {\r\n            offset += match[1].length\r\n            cur = text.substring(offset)\r\n        }\r\n        const token = {\r\n            depth: brackets.length,\r\n            linkBack: -1,\r\n            linkNext: -1,\r\n            match: -1,\r\n            type: \"\",\r\n            text: \"\",\r\n            offset: offset,\r\n            value: -1,\r\n        }\r\n        tokens.push(token)\r\n        let type = SimpleTokens[cur[0]] || \"\"\r\n        if (type) {\r\n            token.type = type\r\n            token.text = cur[0]\r\n            offset++\r\n            if (type === \"OPEN_PAREN\") {\r\n                brackets.push(tokens.length - 1)\r\n                commas.push(tokens.length - 1)\r\n            } else if (type == \"CLOSE_PAREN\") {\r\n                if (brackets.length === 0) {\r\n                    throwError(\"no matching open bracket\")\r\n                }\r\n                token.match = brackets.pop()\r\n                tokens[token.match].match = tokens.length - 1\r\n                token.depth--\r\n                token.linkBack = commas.pop()\r\n                tokens[token.linkBack].linkNext = tokens.length - 1\r\n            } else if (type === \"COMMA\") {\r\n                token.linkBack = commas.pop()\r\n                tokens[token.linkBack].linkNext = tokens.length - 1\r\n                commas.push(tokens.length - 1)\r\n            } else if (type === \"OPEN_BRACKET\") {\r\n                token.type = \"BRACKET\"\r\n            } else if (type === \"CLOSE_BRACKET\") {\r\n                let suffix = tokens.pop().text\r\n                if (\r\n                    tokens.length > 0 &&\r\n                    tokens[tokens.length - 1].type === \"NUMBER\"\r\n                ) {\r\n                    const value = tokens.pop().text\r\n                    suffix = value + suffix\r\n                    tokens[tokens.length - 1].value = getNumber(value)\r\n                }\r\n                if (\r\n                    tokens.length === 0 ||\r\n                    tokens[tokens.length - 1].type !== \"BRACKET\"\r\n                ) {\r\n                    throw new Error(\"missing opening bracket\")\r\n                }\r\n                tokens[tokens.length - 1].text += suffix\r\n            }\r\n            continue\r\n        }\r\n        match = cur.match(regexIdPrefix)\r\n        if (match) {\r\n            token.text = match[1]\r\n            offset += token.text.length\r\n            if (Keywords.has(token.text)) {\r\n                token.type = \"KEYWORD\"\r\n                continue\r\n            }\r\n            if (token.text.match(regexType)) {\r\n                token.type = \"TYPE\"\r\n                continue\r\n            }\r\n            token.type = \"ID\"\r\n            continue\r\n        }\r\n        match = cur.match(regexNumberPrefix)\r\n        if (match) {\r\n            token.text = match[1]\r\n            token.type = \"NUMBER\"\r\n            offset += token.text.length\r\n            continue\r\n        }\r\n        throw new Error(\r\n            `unexpected token ${JSON.stringify(cur[0])} at position ${offset}`,\r\n        )\r\n    }\r\n    return new TokenString(tokens.map((t) => Object.freeze(t)))\r\n}\r\nfunction allowSingle(set, allowed) {\r\n    let included = []\r\n    for (const key in allowed.keys()) {\r\n        if (set.has(key)) {\r\n            included.push(key)\r\n        }\r\n    }\r\n    if (included.length > 1) {\r\n        throw new Error(`conflicting types: ${included.join(\", \")}`)\r\n    }\r\n}\r\nfunction consumeName(type, tokens) {\r\n    if (tokens.peekKeyword(KwTypes)) {\r\n        const keyword = tokens.pop().text\r\n        if (keyword !== type) {\r\n            throw new Error(`expected ${type}, got ${keyword}`)\r\n        }\r\n    }\r\n    return tokens.popType(\"ID\")\r\n}\r\nfunction consumeKeywords(tokens, allowed) {\r\n    const keywords = new Set()\r\n    while (true) {\r\n        const keyword = tokens.peekType(\"KEYWORD\")\r\n        if (keyword == null || (allowed && !allowed.has(keyword))) {\r\n            break\r\n        }\r\n        tokens.pop()\r\n        if (keywords.has(keyword)) {\r\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`)\r\n        }\r\n        keywords.add(keyword)\r\n    }\r\n    return Object.freeze(keywords)\r\n}\r\nfunction consumeMutability(tokens) {\r\n    let modifiers = consumeKeywords(tokens, KwVisib)\r\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")))\r\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")))\r\n    if (modifiers.has(\"view\")) {\r\n        return \"view\"\r\n    }\r\n    if (modifiers.has(\"pure\")) {\r\n        return \"pure\"\r\n    }\r\n    if (modifiers.has(\"payable\")) {\r\n        return \"payable\"\r\n    }\r\n    if (modifiers.has(\"nonpayable\")) {\r\n        return \"nonpayable\"\r\n    }\r\n    if (modifiers.has(\"constant\")) {\r\n        return \"view\"\r\n    }\r\n    return \"nonpayable\"\r\n}\r\nfunction consumeParams(tokens, allowIndexed) {\r\n    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed))\r\n}\r\nfunction consumeGas(tokens) {\r\n    if (tokens.peekType(\"AT\")) {\r\n        tokens.pop()\r\n        if (tokens.peekType(\"NUMBER\")) {\r\n            return getBigInt(tokens.pop().text)\r\n        }\r\n        throw new Error(\"invalid gas\")\r\n    }\r\n    return null\r\n}\r\nfunction consumeEoi(tokens) {\r\n    if (tokens.length) {\r\n        throw new Error(`unexpected tokens: ${tokens.toString()}`)\r\n    }\r\n}\r\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/)\r\nfunction verifyBasicType(type) {\r\n    const match = type.match(regexType)\r\n    assertArgument(match, \"invalid type\", \"type\", type)\r\n    if (type === \"uint\") {\r\n        return \"uint256\"\r\n    }\r\n    if (type === \"int\") {\r\n        return \"int256\"\r\n    }\r\n    if (match[2]) {\r\n        const length = parseInt(match[2])\r\n        assertArgument(\r\n            length !== 0 && length <= 32,\r\n            \"invalid bytes length\",\r\n            \"type\",\r\n            type,\r\n        )\r\n    } else if (match[3]) {\r\n        const size = parseInt(match[3])\r\n        assertArgument(\r\n            size !== 0 && size <= 256 && size % 8 === 0,\r\n            \"invalid numeric width\",\r\n            \"type\",\r\n            type,\r\n        )\r\n    }\r\n    return type\r\n}\r\nconst _guard$2 = {}\r\nconst internal$1 = Symbol.for(\"_ethers_internal\")\r\nconst ParamTypeInternal = \"_ParamTypeInternal\"\r\nconst ErrorFragmentInternal = \"_ErrorInternal\"\r\nconst EventFragmentInternal = \"_EventInternal\"\r\nconst ConstructorFragmentInternal = \"_ConstructorInternal\"\r\nconst FallbackFragmentInternal = \"_FallbackInternal\"\r\nconst FunctionFragmentInternal = \"_FunctionInternal\"\r\nconst StructFragmentInternal = \"_StructInternal\"\r\nclass ParamType {\r\n    name\r\n    type\r\n    baseType\r\n    indexed\r\n    components\r\n    arrayLength\r\n    arrayChildren\r\n    constructor(\r\n        guard,\r\n        name,\r\n        type,\r\n        baseType,\r\n        indexed,\r\n        components,\r\n        arrayLength,\r\n        arrayChildren,\r\n    ) {\r\n        assertPrivate(guard, _guard$2, \"ParamType\")\r\n        Object.defineProperty(this, internal$1, {\r\n            value: ParamTypeInternal,\r\n        })\r\n        if (components) {\r\n            components = Object.freeze(components.slice())\r\n        }\r\n        if (baseType === \"array\") {\r\n            if (arrayLength == null || arrayChildren == null) {\r\n                throw new Error(\"\")\r\n            }\r\n        } else if (arrayLength != null || arrayChildren != null) {\r\n            throw new Error(\"\")\r\n        }\r\n        if (baseType === \"tuple\") {\r\n            if (components == null) {\r\n                throw new Error(\"\")\r\n            }\r\n        } else if (components != null) {\r\n            throw new Error(\"\")\r\n        }\r\n        defineProperties(this, {\r\n            name: name,\r\n            type: type,\r\n            baseType: baseType,\r\n            indexed: indexed,\r\n            components: components,\r\n            arrayLength: arrayLength,\r\n            arrayChildren: arrayChildren,\r\n        })\r\n    }\r\n    format(format) {\r\n        if (format == null) {\r\n            format = \"sighash\"\r\n        }\r\n        if (format === \"json\") {\r\n            const name = this.name || \"\"\r\n            if (this.isArray()) {\r\n                const result = JSON.parse(this.arrayChildren.format(\"json\"))\r\n                result.name = name\r\n                result.type += `[${\r\n                    this.arrayLength < 0 ? \"\" : String(this.arrayLength)\r\n                }]`\r\n                return JSON.stringify(result)\r\n            }\r\n            const result = {\r\n                type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\r\n                name: name,\r\n            }\r\n            if (typeof this.indexed === \"boolean\") {\r\n                result.indexed = this.indexed\r\n            }\r\n            if (this.isTuple()) {\r\n                result.components = this.components.map((c) =>\r\n                    JSON.parse(c.format(format)),\r\n                )\r\n            }\r\n            return JSON.stringify(result)\r\n        }\r\n        let result = \"\"\r\n        if (this.isArray()) {\r\n            result += this.arrayChildren.format(format)\r\n            result += `[${\r\n                this.arrayLength < 0 ? \"\" : String(this.arrayLength)\r\n            }]`\r\n        } else {\r\n            if (this.isTuple()) {\r\n                result +=\r\n                    \"(\" +\r\n                    this.components\r\n                        .map((comp) => comp.format(format))\r\n                        .join(format === \"full\" ? \", \" : \",\") +\r\n                    \")\"\r\n            } else {\r\n                result += this.type\r\n            }\r\n        }\r\n        if (format !== \"sighash\") {\r\n            if (this.indexed === true) {\r\n                result += \" indexed\"\r\n            }\r\n            if (format === \"full\" && this.name) {\r\n                result += \" \" + this.name\r\n            }\r\n        }\r\n        return result\r\n    }\r\n    isArray() {\r\n        return this.baseType === \"array\"\r\n    }\r\n    isTuple() {\r\n        return this.baseType === \"tuple\"\r\n    }\r\n    isIndexable() {\r\n        return this.indexed != null\r\n    }\r\n    walk(value, process) {\r\n        if (this.isArray()) {\r\n            if (!Array.isArray(value)) {\r\n                throw new Error(\"invalid array value\")\r\n            }\r\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\r\n                throw new Error(\"array is wrong length\")\r\n            }\r\n            const _this = this\r\n            return value.map((v) => _this.arrayChildren.walk(v, process))\r\n        }\r\n        if (this.isTuple()) {\r\n            if (!Array.isArray(value)) {\r\n                throw new Error(\"invalid tuple value\")\r\n            }\r\n            if (value.length !== this.components.length) {\r\n                throw new Error(\"array is wrong length\")\r\n            }\r\n            const _this = this\r\n            return value.map((v, i) => _this.components[i].walk(v, process))\r\n        }\r\n        return process(this.type, value)\r\n    }\r\n    #walkAsync(promises, value, process, setValue) {\r\n        if (this.isArray()) {\r\n            if (!Array.isArray(value)) {\r\n                throw new Error(\"invalid array value\")\r\n            }\r\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\r\n                throw new Error(\"array is wrong length\")\r\n            }\r\n            const childType = this.arrayChildren\r\n            const result = value.slice()\r\n            result.forEach((value, index) => {\r\n                childType.#walkAsync(promises, value, process, (value) => {\r\n                    result[index] = value\r\n                })\r\n            })\r\n            setValue(result)\r\n            return\r\n        }\r\n        if (this.isTuple()) {\r\n            const components = this.components\r\n            let result\r\n            if (Array.isArray(value)) {\r\n                result = value.slice()\r\n            } else {\r\n                if (value == null || typeof value !== \"object\") {\r\n                    throw new Error(\"invalid tuple value\")\r\n                }\r\n                result = components.map((param) => {\r\n                    if (!param.name) {\r\n                        throw new Error(\r\n                            \"cannot use object value with unnamed components\",\r\n                        )\r\n                    }\r\n                    if (!(param.name in value)) {\r\n                        throw new Error(\r\n                            `missing value for component ${param.name}`,\r\n                        )\r\n                    }\r\n                    return value[param.name]\r\n                })\r\n            }\r\n            if (result.length !== this.components.length) {\r\n                throw new Error(\"array is wrong length\")\r\n            }\r\n            result.forEach((value, index) => {\r\n                components[index].#walkAsync(\r\n                    promises,\r\n                    value,\r\n                    process,\r\n                    (value) => {\r\n                        result[index] = value\r\n                    },\r\n                )\r\n            })\r\n            setValue(result)\r\n            return\r\n        }\r\n        const result = process(this.type, value)\r\n        if (result.then) {\r\n            promises.push(\r\n                (async function () {\r\n                    setValue(await result)\r\n                })(),\r\n            )\r\n        } else {\r\n            setValue(result)\r\n        }\r\n    }\r\n    async walkAsync(value, process) {\r\n        const promises = []\r\n        const result = [value]\r\n        this.#walkAsync(promises, value, process, (value) => {\r\n            result[0] = value\r\n        })\r\n        if (promises.length) {\r\n            await Promise.all(promises)\r\n        }\r\n        return result[0]\r\n    }\r\n    static from(obj, allowIndexed) {\r\n        if (ParamType.isParamType(obj)) {\r\n            return obj\r\n        }\r\n        if (typeof obj === \"string\") {\r\n            try {\r\n                return ParamType.from(lex(obj), allowIndexed)\r\n            } catch (error) {\r\n                assertArgument(false, \"invalid param type\", \"obj\", obj)\r\n            }\r\n        } else if (obj instanceof TokenString) {\r\n            let type = \"\",\r\n                baseType = \"\"\r\n            let comps = null\r\n            if (\r\n                consumeKeywords(obj, setify([\"tuple\"])).has(\"tuple\") ||\r\n                obj.peekType(\"OPEN_PAREN\")\r\n            ) {\r\n                baseType = \"tuple\"\r\n                comps = obj.popParams().map((t) => ParamType.from(t))\r\n                type = `tuple(${comps.map((c) => c.format()).join(\",\")})`\r\n            } else {\r\n                type = verifyBasicType(obj.popType(\"TYPE\"))\r\n                baseType = type\r\n            }\r\n            let arrayChildren = null\r\n            let arrayLength = null\r\n            while (obj.length && obj.peekType(\"BRACKET\")) {\r\n                const bracket = obj.pop()\r\n                arrayChildren = new ParamType(\r\n                    _guard$2,\r\n                    \"\",\r\n                    type,\r\n                    baseType,\r\n                    null,\r\n                    comps,\r\n                    arrayLength,\r\n                    arrayChildren,\r\n                )\r\n                arrayLength = bracket.value\r\n                type += bracket.text\r\n                baseType = \"array\"\r\n                comps = null\r\n            }\r\n            let indexed = null\r\n            const keywords = consumeKeywords(obj, KwModifiers)\r\n            if (keywords.has(\"indexed\")) {\r\n                if (!allowIndexed) {\r\n                    throw new Error(\"\")\r\n                }\r\n                indexed = true\r\n            }\r\n            const name = obj.peekType(\"ID\") ? obj.pop().text : \"\"\r\n            if (obj.length) {\r\n                throw new Error(\"leftover tokens\")\r\n            }\r\n            return new ParamType(\r\n                _guard$2,\r\n                name,\r\n                type,\r\n                baseType,\r\n                indexed,\r\n                comps,\r\n                arrayLength,\r\n                arrayChildren,\r\n            )\r\n        }\r\n        const name = obj.name\r\n        assertArgument(\r\n            !name || (typeof name === \"string\" && name.match(regexId)),\r\n            \"invalid name\",\r\n            \"obj.name\",\r\n            name,\r\n        )\r\n        let indexed = obj.indexed\r\n        if (indexed != null) {\r\n            assertArgument(\r\n                allowIndexed,\r\n                \"parameter cannot be indexed\",\r\n                \"obj.indexed\",\r\n                obj.indexed,\r\n            )\r\n            indexed = !!indexed\r\n        }\r\n        let type = obj.type\r\n        let arrayMatch = type.match(regexArrayType)\r\n        if (arrayMatch) {\r\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\")\r\n            const arrayChildren = ParamType.from({\r\n                type: arrayMatch[1],\r\n                components: obj.components,\r\n            })\r\n            return new ParamType(\r\n                _guard$2,\r\n                name || \"\",\r\n                type,\r\n                \"array\",\r\n                indexed,\r\n                null,\r\n                arrayLength,\r\n                arrayChildren,\r\n            )\r\n        }\r\n        if (\r\n            type === \"tuple\" ||\r\n            type.startsWith(\"tuple(\") ||\r\n            type.startsWith(\"(\")\r\n        ) {\r\n            const comps =\r\n                obj.components != null\r\n                    ? obj.components.map((c) => ParamType.from(c))\r\n                    : null\r\n            const tuple = new ParamType(\r\n                _guard$2,\r\n                name || \"\",\r\n                type,\r\n                \"tuple\",\r\n                indexed,\r\n                comps,\r\n                null,\r\n                null,\r\n            )\r\n            return tuple\r\n        }\r\n        type = verifyBasicType(obj.type)\r\n        return new ParamType(\r\n            _guard$2,\r\n            name || \"\",\r\n            type,\r\n            type,\r\n            indexed,\r\n            null,\r\n            null,\r\n            null,\r\n        )\r\n    }\r\n    static isParamType(value) {\r\n        return value && value[internal$1] === ParamTypeInternal\r\n    }\r\n}\r\nclass Fragment {\r\n    type\r\n    inputs\r\n    constructor(guard, type, inputs) {\r\n        assertPrivate(guard, _guard$2, \"Fragment\")\r\n        inputs = Object.freeze(inputs.slice())\r\n        defineProperties(this, {\r\n            type: type,\r\n            inputs: inputs,\r\n        })\r\n    }\r\n    static from(obj) {\r\n        if (typeof obj === \"string\") {\r\n            try {\r\n                Fragment.from(JSON.parse(obj))\r\n            } catch (e) {}\r\n            return Fragment.from(lex(obj))\r\n        }\r\n        if (obj instanceof TokenString) {\r\n            const type = obj.peekKeyword(KwTypes)\r\n            switch (type) {\r\n                case \"constructor\":\r\n                    return ConstructorFragment.from(obj)\r\n                case \"error\":\r\n                    return ErrorFragment.from(obj)\r\n                case \"event\":\r\n                    return EventFragment.from(obj)\r\n                case \"fallback\":\r\n                case \"receive\":\r\n                    return FallbackFragment.from(obj)\r\n                case \"function\":\r\n                    return FunctionFragment.from(obj)\r\n                case \"struct\":\r\n                    return StructFragment.from(obj)\r\n            }\r\n        } else if (typeof obj === \"object\") {\r\n            switch (obj.type) {\r\n                case \"constructor\":\r\n                    return ConstructorFragment.from(obj)\r\n                case \"error\":\r\n                    return ErrorFragment.from(obj)\r\n                case \"event\":\r\n                    return EventFragment.from(obj)\r\n                case \"fallback\":\r\n                case \"receive\":\r\n                    return FallbackFragment.from(obj)\r\n                case \"function\":\r\n                    return FunctionFragment.from(obj)\r\n                case \"struct\":\r\n                    return StructFragment.from(obj)\r\n            }\r\n            assert(\r\n                false,\r\n                `unsupported type: ${obj.type}`,\r\n                \"UNSUPPORTED_OPERATION\",\r\n                {\r\n                    operation: \"Fragment.from\",\r\n                },\r\n            )\r\n        }\r\n        assertArgument(false, \"unsupported frgament object\", \"obj\", obj)\r\n    }\r\n    static isConstructor(value) {\r\n        return ConstructorFragment.isFragment(value)\r\n    }\r\n    static isError(value) {\r\n        return ErrorFragment.isFragment(value)\r\n    }\r\n    static isEvent(value) {\r\n        return EventFragment.isFragment(value)\r\n    }\r\n    static isFunction(value) {\r\n        return FunctionFragment.isFragment(value)\r\n    }\r\n    static isStruct(value) {\r\n        return StructFragment.isFragment(value)\r\n    }\r\n}\r\nclass NamedFragment extends Fragment {\r\n    name\r\n    constructor(guard, type, name, inputs) {\r\n        super(guard, type, inputs)\r\n        assertArgument(\r\n            typeof name === \"string\" && name.match(regexId),\r\n            \"invalid identifier\",\r\n            \"name\",\r\n            name,\r\n        )\r\n        inputs = Object.freeze(inputs.slice())\r\n        defineProperties(this, {\r\n            name: name,\r\n        })\r\n    }\r\n}\r\nfunction joinParams(format, params) {\r\n    return (\r\n        \"(\" +\r\n        params\r\n            .map((p) => p.format(format))\r\n            .join(format === \"full\" ? \", \" : \",\") +\r\n        \")\"\r\n    )\r\n}\r\nclass ErrorFragment extends NamedFragment {\r\n    constructor(guard, name, inputs) {\r\n        super(guard, \"error\", name, inputs)\r\n        Object.defineProperty(this, internal$1, {\r\n            value: ErrorFragmentInternal,\r\n        })\r\n    }\r\n    get selector() {\r\n        return id(this.format(\"sighash\")).substring(0, 10)\r\n    }\r\n    format(format) {\r\n        if (format == null) {\r\n            format = \"sighash\"\r\n        }\r\n        if (format === \"json\") {\r\n            return JSON.stringify({\r\n                type: \"error\",\r\n                name: this.name,\r\n                inputs: this.inputs.map((input) =>\r\n                    JSON.parse(input.format(format)),\r\n                ),\r\n            })\r\n        }\r\n        const result = []\r\n        if (format !== \"sighash\") {\r\n            result.push(\"error\")\r\n        }\r\n        result.push(this.name + joinParams(format, this.inputs))\r\n        return result.join(\" \")\r\n    }\r\n    static from(obj) {\r\n        if (ErrorFragment.isFragment(obj)) {\r\n            return obj\r\n        }\r\n        if (typeof obj === \"string\") {\r\n            return ErrorFragment.from(lex(obj))\r\n        } else if (obj instanceof TokenString) {\r\n            const name = consumeName(\"error\", obj)\r\n            const inputs = consumeParams(obj)\r\n            consumeEoi(obj)\r\n            return new ErrorFragment(_guard$2, name, inputs)\r\n        }\r\n        return new ErrorFragment(\r\n            _guard$2,\r\n            obj.name,\r\n            obj.inputs ? obj.inputs.map(ParamType.from) : [],\r\n        )\r\n    }\r\n    static isFragment(value) {\r\n        return value && value[internal$1] === ErrorFragmentInternal\r\n    }\r\n}\r\nclass EventFragment extends NamedFragment {\r\n    anonymous\r\n    constructor(guard, name, inputs, anonymous) {\r\n        super(guard, \"event\", name, inputs)\r\n        Object.defineProperty(this, internal$1, {\r\n            value: EventFragmentInternal,\r\n        })\r\n        defineProperties(this, {\r\n            anonymous: anonymous,\r\n        })\r\n    }\r\n    get topicHash() {\r\n        return id(this.format(\"sighash\"))\r\n    }\r\n    format(format) {\r\n        if (format == null) {\r\n            format = \"sighash\"\r\n        }\r\n        if (format === \"json\") {\r\n            return JSON.stringify({\r\n                type: \"event\",\r\n                anonymous: this.anonymous,\r\n                name: this.name,\r\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\r\n            })\r\n        }\r\n        const result = []\r\n        if (format !== \"sighash\") {\r\n            result.push(\"event\")\r\n        }\r\n        result.push(this.name + joinParams(format, this.inputs))\r\n        if (format !== \"sighash\" && this.anonymous) {\r\n            result.push(\"anonymous\")\r\n        }\r\n        return result.join(\" \")\r\n    }\r\n    static getTopicHash(name, params) {\r\n        params = (params || []).map((p) => ParamType.from(p))\r\n        const fragment = new EventFragment(_guard$2, name, params, false)\r\n        return fragment.topicHash\r\n    }\r\n    static from(obj) {\r\n        if (EventFragment.isFragment(obj)) {\r\n            return obj\r\n        }\r\n        if (typeof obj === \"string\") {\r\n            try {\r\n                return EventFragment.from(lex(obj))\r\n            } catch (error) {\r\n                assertArgument(false, \"invalid event fragment\", \"obj\", obj)\r\n            }\r\n        } else if (obj instanceof TokenString) {\r\n            const name = consumeName(\"event\", obj)\r\n            const inputs = consumeParams(obj, true)\r\n            const anonymous = !!consumeKeywords(obj, setify([\"anonymous\"])).has(\r\n                \"anonymous\",\r\n            )\r\n            consumeEoi(obj)\r\n            return new EventFragment(_guard$2, name, inputs, anonymous)\r\n        }\r\n        return new EventFragment(\r\n            _guard$2,\r\n            obj.name,\r\n            obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [],\r\n            !!obj.anonymous,\r\n        )\r\n    }\r\n    static isFragment(value) {\r\n        return value && value[internal$1] === EventFragmentInternal\r\n    }\r\n}\r\nclass ConstructorFragment extends Fragment {\r\n    payable\r\n    gas\r\n    constructor(guard, type, inputs, payable, gas) {\r\n        super(guard, type, inputs)\r\n        Object.defineProperty(this, internal$1, {\r\n            value: ConstructorFragmentInternal,\r\n        })\r\n        defineProperties(this, {\r\n            payable: payable,\r\n            gas: gas,\r\n        })\r\n    }\r\n    format(format) {\r\n        assert(\r\n            format != null && format !== \"sighash\",\r\n            \"cannot format a constructor for sighash\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"format(sighash)\",\r\n            },\r\n        )\r\n        if (format === \"json\") {\r\n            return JSON.stringify({\r\n                type: \"constructor\",\r\n                stateMutability: this.payable ? \"payable\" : \"undefined\",\r\n                payable: this.payable,\r\n                gas: this.gas != null ? this.gas : undefined,\r\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\r\n            })\r\n        }\r\n        const result = [`constructor${joinParams(format, this.inputs)}`]\r\n        if (this.payable) {\r\n            result.push(\"payable\")\r\n        }\r\n        if (this.gas != null) {\r\n            result.push(`@${this.gas.toString()}`)\r\n        }\r\n        return result.join(\" \")\r\n    }\r\n    static from(obj) {\r\n        if (ConstructorFragment.isFragment(obj)) {\r\n            return obj\r\n        }\r\n        if (typeof obj === \"string\") {\r\n            try {\r\n                return ConstructorFragment.from(lex(obj))\r\n            } catch (error) {\r\n                assertArgument(false, \"invalid constuctor fragment\", \"obj\", obj)\r\n            }\r\n        } else if (obj instanceof TokenString) {\r\n            consumeKeywords(obj, setify([\"constructor\"]))\r\n            const inputs = consumeParams(obj)\r\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\")\r\n            const gas = consumeGas(obj)\r\n            consumeEoi(obj)\r\n            return new ConstructorFragment(\r\n                _guard$2,\r\n                \"constructor\",\r\n                inputs,\r\n                payable,\r\n                gas,\r\n            )\r\n        }\r\n        return new ConstructorFragment(\r\n            _guard$2,\r\n            \"constructor\",\r\n            obj.inputs ? obj.inputs.map(ParamType.from) : [],\r\n            !!obj.payable,\r\n            obj.gas != null ? obj.gas : null,\r\n        )\r\n    }\r\n    static isFragment(value) {\r\n        return value && value[internal$1] === ConstructorFragmentInternal\r\n    }\r\n}\r\nclass FallbackFragment extends Fragment {\r\n    payable\r\n    constructor(guard, inputs, payable) {\r\n        super(guard, \"fallback\", inputs)\r\n        Object.defineProperty(this, internal$1, {\r\n            value: FallbackFragmentInternal,\r\n        })\r\n        defineProperties(this, {\r\n            payable: payable,\r\n        })\r\n    }\r\n    format(format) {\r\n        const type = this.inputs.length === 0 ? \"receive\" : \"fallback\"\r\n        if (format === \"json\") {\r\n            const stateMutability = this.payable ? \"payable\" : \"nonpayable\"\r\n            return JSON.stringify({\r\n                type: type,\r\n                stateMutability: stateMutability,\r\n            })\r\n        }\r\n        return `${type}()${this.payable ? \" payable\" : \"\"}`\r\n    }\r\n    static from(obj) {\r\n        if (FallbackFragment.isFragment(obj)) {\r\n            return obj\r\n        }\r\n        if (typeof obj === \"string\") {\r\n            try {\r\n                return FallbackFragment.from(lex(obj))\r\n            } catch (error) {\r\n                assertArgument(false, \"invalid fallback fragment\", \"obj\", obj)\r\n            }\r\n        } else if (obj instanceof TokenString) {\r\n            const errorObj = obj.toString()\r\n            const topIsValid = obj.peekKeyword(setify([\"fallback\", \"receive\"]))\r\n            assertArgument(\r\n                topIsValid,\r\n                \"type must be fallback or receive\",\r\n                \"obj\",\r\n                errorObj,\r\n            )\r\n            const type = obj.popKeyword(setify([\"fallback\", \"receive\"]))\r\n            if (type === \"receive\") {\r\n                const inputs = consumeParams(obj)\r\n                assertArgument(\r\n                    inputs.length === 0,\r\n                    `receive cannot have arguments`,\r\n                    \"obj.inputs\",\r\n                    inputs,\r\n                )\r\n                consumeKeywords(obj, setify([\"payable\"]))\r\n                consumeEoi(obj)\r\n                return new FallbackFragment(_guard$2, [], true)\r\n            }\r\n            let inputs = consumeParams(obj)\r\n            if (inputs.length) {\r\n                assertArgument(\r\n                    inputs.length === 1 && inputs[0].type === \"bytes\",\r\n                    \"invalid fallback inputs\",\r\n                    \"obj.inputs\",\r\n                    inputs.map((i) => i.format(\"minimal\")).join(\", \"),\r\n                )\r\n            } else {\r\n                inputs = [ParamType.from(\"bytes\")]\r\n            }\r\n            const mutability = consumeMutability(obj)\r\n            assertArgument(\r\n                mutability === \"nonpayable\" || mutability === \"payable\",\r\n                \"fallback cannot be constants\",\r\n                \"obj.stateMutability\",\r\n                mutability,\r\n            )\r\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\r\n                const outputs = consumeParams(obj)\r\n                assertArgument(\r\n                    outputs.length === 1 && outputs[0].type === \"bytes\",\r\n                    \"invalid fallback outputs\",\r\n                    \"obj.outputs\",\r\n                    outputs.map((i) => i.format(\"minimal\")).join(\", \"),\r\n                )\r\n            }\r\n            consumeEoi(obj)\r\n            return new FallbackFragment(\r\n                _guard$2,\r\n                inputs,\r\n                mutability === \"payable\",\r\n            )\r\n        }\r\n        if (obj.type === \"receive\") {\r\n            return new FallbackFragment(_guard$2, [], true)\r\n        }\r\n        if (obj.type === \"fallback\") {\r\n            const inputs = [ParamType.from(\"bytes\")]\r\n            const payable = obj.stateMutability === \"payable\"\r\n            return new FallbackFragment(_guard$2, inputs, payable)\r\n        }\r\n        assertArgument(false, \"invalid fallback description\", \"obj\", obj)\r\n    }\r\n    static isFragment(value) {\r\n        return value && value[internal$1] === FallbackFragmentInternal\r\n    }\r\n}\r\nclass FunctionFragment extends NamedFragment {\r\n    constant\r\n    outputs\r\n    stateMutability\r\n    payable\r\n    gas\r\n    constructor(guard, name, stateMutability, inputs, outputs, gas) {\r\n        super(guard, \"function\", name, inputs)\r\n        Object.defineProperty(this, internal$1, {\r\n            value: FunctionFragmentInternal,\r\n        })\r\n        outputs = Object.freeze(outputs.slice())\r\n        const constant =\r\n            stateMutability === \"view\" || stateMutability === \"pure\"\r\n        const payable = stateMutability === \"payable\"\r\n        defineProperties(this, {\r\n            constant: constant,\r\n            gas: gas,\r\n            outputs: outputs,\r\n            payable: payable,\r\n            stateMutability: stateMutability,\r\n        })\r\n    }\r\n    get selector() {\r\n        return id(this.format(\"sighash\")).substring(0, 10)\r\n    }\r\n    format(format) {\r\n        if (format == null) {\r\n            format = \"sighash\"\r\n        }\r\n        if (format === \"json\") {\r\n            return JSON.stringify({\r\n                type: \"function\",\r\n                name: this.name,\r\n                constant: this.constant,\r\n                stateMutability:\r\n                    this.stateMutability !== \"nonpayable\"\r\n                        ? this.stateMutability\r\n                        : undefined,\r\n                payable: this.payable,\r\n                gas: this.gas != null ? this.gas : undefined,\r\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\r\n                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),\r\n            })\r\n        }\r\n        const result = []\r\n        if (format !== \"sighash\") {\r\n            result.push(\"function\")\r\n        }\r\n        result.push(this.name + joinParams(format, this.inputs))\r\n        if (format !== \"sighash\") {\r\n            if (this.stateMutability !== \"nonpayable\") {\r\n                result.push(this.stateMutability)\r\n            }\r\n            if (this.outputs && this.outputs.length) {\r\n                result.push(\"returns\")\r\n                result.push(joinParams(format, this.outputs))\r\n            }\r\n            if (this.gas != null) {\r\n                result.push(`@${this.gas.toString()}`)\r\n            }\r\n        }\r\n        return result.join(\" \")\r\n    }\r\n    static getSelector(name, params) {\r\n        params = (params || []).map((p) => ParamType.from(p))\r\n        const fragment = new FunctionFragment(\r\n            _guard$2,\r\n            name,\r\n            \"view\",\r\n            params,\r\n            [],\r\n            null,\r\n        )\r\n        return fragment.selector\r\n    }\r\n    static from(obj) {\r\n        if (FunctionFragment.isFragment(obj)) {\r\n            return obj\r\n        }\r\n        if (typeof obj === \"string\") {\r\n            try {\r\n                return FunctionFragment.from(lex(obj))\r\n            } catch (error) {\r\n                assertArgument(false, \"invalid function fragment\", \"obj\", obj)\r\n            }\r\n        } else if (obj instanceof TokenString) {\r\n            const name = consumeName(\"function\", obj)\r\n            const inputs = consumeParams(obj)\r\n            const mutability = consumeMutability(obj)\r\n            let outputs = []\r\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\r\n                outputs = consumeParams(obj)\r\n            }\r\n            const gas = consumeGas(obj)\r\n            consumeEoi(obj)\r\n            return new FunctionFragment(\r\n                _guard$2,\r\n                name,\r\n                mutability,\r\n                inputs,\r\n                outputs,\r\n                gas,\r\n            )\r\n        }\r\n        let stateMutability = obj.stateMutability\r\n        if (stateMutability == null) {\r\n            stateMutability = \"payable\"\r\n            if (typeof obj.constant === \"boolean\") {\r\n                stateMutability = \"view\"\r\n                if (!obj.constant) {\r\n                    stateMutability = \"payable\"\r\n                    if (typeof obj.payable === \"boolean\" && !obj.payable) {\r\n                        stateMutability = \"nonpayable\"\r\n                    }\r\n                }\r\n            } else if (typeof obj.payable === \"boolean\" && !obj.payable) {\r\n                stateMutability = \"nonpayable\"\r\n            }\r\n        }\r\n        return new FunctionFragment(\r\n            _guard$2,\r\n            obj.name,\r\n            stateMutability,\r\n            obj.inputs ? obj.inputs.map(ParamType.from) : [],\r\n            obj.outputs ? obj.outputs.map(ParamType.from) : [],\r\n            obj.gas != null ? obj.gas : null,\r\n        )\r\n    }\r\n    static isFragment(value) {\r\n        return value && value[internal$1] === FunctionFragmentInternal\r\n    }\r\n}\r\nclass StructFragment extends NamedFragment {\r\n    constructor(guard, name, inputs) {\r\n        super(guard, \"struct\", name, inputs)\r\n        Object.defineProperty(this, internal$1, {\r\n            value: StructFragmentInternal,\r\n        })\r\n    }\r\n    format() {\r\n        throw new Error(\"@TODO\")\r\n    }\r\n    static from(obj) {\r\n        if (typeof obj === \"string\") {\r\n            try {\r\n                return StructFragment.from(lex(obj))\r\n            } catch (error) {\r\n                assertArgument(false, \"invalid struct fragment\", \"obj\", obj)\r\n            }\r\n        } else if (obj instanceof TokenString) {\r\n            const name = consumeName(\"struct\", obj)\r\n            const inputs = consumeParams(obj)\r\n            consumeEoi(obj)\r\n            return new StructFragment(_guard$2, name, inputs)\r\n        }\r\n        return new StructFragment(\r\n            _guard$2,\r\n            obj.name,\r\n            obj.inputs ? obj.inputs.map(ParamType.from) : [],\r\n        )\r\n    }\r\n    static isFragment(value) {\r\n        return value && value[internal$1] === StructFragmentInternal\r\n    }\r\n}\r\nconst PanicReasons$1 = new Map()\r\nPanicReasons$1.set(0, \"GENERIC_PANIC\")\r\nPanicReasons$1.set(1, \"ASSERT_FALSE\")\r\nPanicReasons$1.set(17, \"OVERFLOW\")\r\nPanicReasons$1.set(18, \"DIVIDE_BY_ZERO\")\r\nPanicReasons$1.set(33, \"ENUM_RANGE_ERROR\")\r\nPanicReasons$1.set(34, \"BAD_STORAGE_DATA\")\r\nPanicReasons$1.set(49, \"STACK_UNDERFLOW\")\r\nPanicReasons$1.set(50, \"ARRAY_RANGE_ERROR\")\r\nPanicReasons$1.set(65, \"OUT_OF_MEMORY\")\r\nPanicReasons$1.set(81, \"UNINITIALIZED_FUNCTION_CALL\")\r\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/)\r\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/)\r\nlet defaultCoder = null\r\nfunction getBuiltinCallException(action, tx, data, abiCoder) {\r\n    let message = \"missing revert data\"\r\n    let reason = null\r\n    const invocation = null\r\n    let revert = null\r\n    if (data) {\r\n        message = \"execution reverted\"\r\n        const bytes = getBytes(data)\r\n        data = hexlify(data)\r\n        if (bytes.length === 0) {\r\n            message += \" (no data present; likely require(false) occurred\"\r\n            reason = \"require(false)\"\r\n        } else if (bytes.length % 32 !== 4) {\r\n            message += \" (could not decode reason; invalid data length)\"\r\n        } else if (hexlify(bytes.slice(0, 4)) === \"0x08c379a0\") {\r\n            try {\r\n                reason = abiCoder.decode([\"string\"], bytes.slice(4))[0]\r\n                revert = {\r\n                    signature: \"Error(string)\",\r\n                    name: \"Error\",\r\n                    args: [reason],\r\n                }\r\n                message += `: ${JSON.stringify(reason)}`\r\n            } catch (error) {\r\n                message += \" (could not decode reason; invalid string data)\"\r\n            }\r\n        } else if (hexlify(bytes.slice(0, 4)) === \"0x4e487b71\") {\r\n            try {\r\n                const code = Number(\r\n                    abiCoder.decode([\"uint256\"], bytes.slice(4))[0],\r\n                )\r\n                revert = {\r\n                    signature: \"Panic(uint256)\",\r\n                    name: \"Panic\",\r\n                    args: [code],\r\n                }\r\n                reason = `Panic due to ${\r\n                    PanicReasons$1.get(code) || \"UNKNOWN\"\r\n                }(${code})`\r\n                message += `: ${reason}`\r\n            } catch (error) {\r\n                message += \" (could not decode panic code)\"\r\n            }\r\n        } else {\r\n            message += \" (unknown custom error)\"\r\n        }\r\n    }\r\n    const transaction = {\r\n        to: tx.to ? getAddress(tx.to) : null,\r\n        data: tx.data || \"0x\",\r\n    }\r\n    if (tx.from) {\r\n        transaction.from = getAddress(tx.from)\r\n    }\r\n    return makeError(message, \"CALL_EXCEPTION\", {\r\n        action: action,\r\n        data: data,\r\n        reason: reason,\r\n        transaction: transaction,\r\n        invocation: invocation,\r\n        revert: revert,\r\n    })\r\n}\r\nclass AbiCoder {\r\n    #getCoder(param) {\r\n        if (param.isArray()) {\r\n            return new ArrayCoder(\r\n                this.#getCoder(param.arrayChildren),\r\n                param.arrayLength,\r\n                param.name,\r\n            )\r\n        }\r\n        if (param.isTuple()) {\r\n            return new TupleCoder(\r\n                param.components.map((c) => this.#getCoder(c)),\r\n                param.name,\r\n            )\r\n        }\r\n        switch (param.baseType) {\r\n            case \"address\":\r\n                return new AddressCoder(param.name)\r\n            case \"bool\":\r\n                return new BooleanCoder(param.name)\r\n            case \"string\":\r\n                return new StringCoder(param.name)\r\n            case \"bytes\":\r\n                return new BytesCoder(param.name)\r\n            case \"\":\r\n                return new NullCoder(param.name)\r\n        }\r\n        let match = param.type.match(paramTypeNumber)\r\n        if (match) {\r\n            let size = parseInt(match[2] || \"256\")\r\n            assertArgument(\r\n                size !== 0 && size <= 256 && size % 8 === 0,\r\n                \"invalid \" + match[1] + \" bit length\",\r\n                \"param\",\r\n                param,\r\n            )\r\n            return new NumberCoder(size / 8, match[1] === \"int\", param.name)\r\n        }\r\n        match = param.type.match(paramTypeBytes)\r\n        if (match) {\r\n            let size = parseInt(match[1])\r\n            assertArgument(\r\n                size !== 0 && size <= 32,\r\n                \"invalid bytes length\",\r\n                \"param\",\r\n                param,\r\n            )\r\n            return new FixedBytesCoder(size, param.name)\r\n        }\r\n        assertArgument(false, \"invalid type\", \"type\", param.type)\r\n    }\r\n    getDefaultValue(types) {\r\n        const coders = types.map((type) => this.#getCoder(ParamType.from(type)))\r\n        const coder = new TupleCoder(coders, \"_\")\r\n        return coder.defaultValue()\r\n    }\r\n    encode(types, values) {\r\n        assertArgumentCount(\r\n            values.length,\r\n            types.length,\r\n            \"types/values length mismatch\",\r\n        )\r\n        const coders = types.map((type) => this.#getCoder(ParamType.from(type)))\r\n        const coder = new TupleCoder(coders, \"_\")\r\n        const writer = new Writer()\r\n        coder.encode(writer, values)\r\n        return writer.data\r\n    }\r\n    decode(types, data, loose) {\r\n        const coders = types.map((type) => this.#getCoder(ParamType.from(type)))\r\n        const coder = new TupleCoder(coders, \"_\")\r\n        return coder.decode(new Reader(data, loose))\r\n    }\r\n    static defaultAbiCoder() {\r\n        if (defaultCoder == null) {\r\n            defaultCoder = new AbiCoder()\r\n        }\r\n        return defaultCoder\r\n    }\r\n    static getBuiltinCallException(action, tx, data) {\r\n        return getBuiltinCallException(\r\n            action,\r\n            tx,\r\n            data,\r\n            AbiCoder.defaultAbiCoder(),\r\n        )\r\n    }\r\n}\r\nfunction encodeBytes32String(text) {\r\n    const bytes = toUtf8Bytes(text)\r\n    if (bytes.length > 31) {\r\n        throw new Error(\"bytes32 string must be less than 32 bytes\")\r\n    }\r\n    return zeroPadBytes(bytes, 32)\r\n}\r\nfunction decodeBytes32String(_bytes) {\r\n    const data = getBytes(_bytes, \"bytes\")\r\n    if (data.length !== 32) {\r\n        throw new Error(\"invalid bytes32 - not 32 bytes long\")\r\n    }\r\n    if (data[31] !== 0) {\r\n        throw new Error(\"invalid bytes32 string - no null terminator\")\r\n    }\r\n    let length = 31\r\n    while (data[length - 1] === 0) {\r\n        length--\r\n    }\r\n    return toUtf8String(data.slice(0, length))\r\n}\r\nclass LogDescription {\r\n    fragment\r\n    name\r\n    signature\r\n    topic\r\n    args\r\n    constructor(fragment, topic, args) {\r\n        const name = fragment.name,\r\n            signature = fragment.format()\r\n        defineProperties(this, {\r\n            fragment: fragment,\r\n            name: name,\r\n            signature: signature,\r\n            topic: topic,\r\n            args: args,\r\n        })\r\n    }\r\n}\r\nclass TransactionDescription {\r\n    fragment\r\n    name\r\n    args\r\n    signature\r\n    selector\r\n    value\r\n    constructor(fragment, selector, args, value) {\r\n        const name = fragment.name,\r\n            signature = fragment.format()\r\n        defineProperties(this, {\r\n            fragment: fragment,\r\n            name: name,\r\n            args: args,\r\n            signature: signature,\r\n            selector: selector,\r\n            value: value,\r\n        })\r\n    }\r\n}\r\nclass ErrorDescription {\r\n    fragment\r\n    name\r\n    args\r\n    signature\r\n    selector\r\n    constructor(fragment, selector, args) {\r\n        const name = fragment.name,\r\n            signature = fragment.format()\r\n        defineProperties(this, {\r\n            fragment: fragment,\r\n            name: name,\r\n            args: args,\r\n            signature: signature,\r\n            selector: selector,\r\n        })\r\n    }\r\n}\r\nclass Indexed {\r\n    hash\r\n    _isIndexed\r\n    static isIndexed(value) {\r\n        return !!(value && value._isIndexed)\r\n    }\r\n    constructor(hash) {\r\n        defineProperties(this, {\r\n            hash: hash,\r\n            _isIndexed: true,\r\n        })\r\n    }\r\n}\r\nconst PanicReasons = {\r\n    0: \"generic panic\",\r\n    1: \"assert(false)\",\r\n    17: \"arithmetic overflow\",\r\n    18: \"division or modulo by zero\",\r\n    33: \"enum overflow\",\r\n    34: \"invalid encoded storage byte array accessed\",\r\n    49: \"out-of-bounds array access; popping on an empty array\",\r\n    50: \"out-of-bounds access of an array or bytesN\",\r\n    65: \"out of memory\",\r\n    81: \"uninitialized function\",\r\n}\r\nconst BuiltinErrors = {\r\n    \"0x08c379a0\": {\r\n        signature: \"Error(string)\",\r\n        name: \"Error\",\r\n        inputs: [\"string\"],\r\n        reason: (message) => {\r\n            return `reverted with reason string ${JSON.stringify(message)}`\r\n        },\r\n    },\r\n    \"0x4e487b71\": {\r\n        signature: \"Panic(uint256)\",\r\n        name: \"Panic\",\r\n        inputs: [\"uint256\"],\r\n        reason: (code) => {\r\n            let reason = \"unknown panic code\"\r\n            if (code >= 0 && code <= 255 && PanicReasons[code.toString()]) {\r\n                reason = PanicReasons[code.toString()]\r\n            }\r\n            return `reverted with panic code 0x${code.toString(16)} (${reason})`\r\n        },\r\n    },\r\n}\r\nclass Interface {\r\n    fragments\r\n    deploy\r\n    fallback\r\n    receive\r\n    #errors\r\n    #events\r\n    #functions\r\n    #abiCoder\r\n    constructor(fragments) {\r\n        let abi = []\r\n        if (typeof fragments === \"string\") {\r\n            abi = JSON.parse(fragments)\r\n        } else {\r\n            abi = fragments\r\n        }\r\n        this.#functions = new Map()\r\n        this.#errors = new Map()\r\n        this.#events = new Map()\r\n        const frags = []\r\n        for (const a of abi) {\r\n            try {\r\n                frags.push(Fragment.from(a))\r\n            } catch (error) {\r\n                console.log(\"EE\", error)\r\n            }\r\n        }\r\n        defineProperties(this, {\r\n            fragments: Object.freeze(frags),\r\n        })\r\n        let fallback = null\r\n        let receive = false\r\n        this.#abiCoder = this.getAbiCoder()\r\n        this.fragments.forEach((fragment, index) => {\r\n            let bucket\r\n            switch (fragment.type) {\r\n                case \"constructor\":\r\n                    if (this.deploy) {\r\n                        console.log(\"duplicate definition - constructor\")\r\n                        return\r\n                    }\r\n                    defineProperties(this, {\r\n                        deploy: fragment,\r\n                    })\r\n                    return\r\n                case \"fallback\":\r\n                    if (fragment.inputs.length === 0) {\r\n                        receive = true\r\n                    } else {\r\n                        assertArgument(\r\n                            !fallback || fragment.payable !== fallback.payable,\r\n                            \"conflicting fallback fragments\",\r\n                            `fragments[${index}]`,\r\n                            fragment,\r\n                        )\r\n                        fallback = fragment\r\n                        receive = fallback.payable\r\n                    }\r\n                    return\r\n                case \"function\":\r\n                    bucket = this.#functions\r\n                    break\r\n                case \"event\":\r\n                    bucket = this.#events\r\n                    break\r\n                case \"error\":\r\n                    bucket = this.#errors\r\n                    break\r\n                default:\r\n                    return\r\n            }\r\n            const signature = fragment.format()\r\n            if (bucket.has(signature)) {\r\n                return\r\n            }\r\n            bucket.set(signature, fragment)\r\n        })\r\n        if (!this.deploy) {\r\n            defineProperties(this, {\r\n                deploy: ConstructorFragment.from(\"constructor()\"),\r\n            })\r\n        }\r\n        defineProperties(this, {\r\n            fallback: fallback,\r\n            receive: receive,\r\n        })\r\n    }\r\n    format(minimal) {\r\n        const format = minimal ? \"minimal\" : \"full\"\r\n        const abi = this.fragments.map((f) => f.format(format))\r\n        return abi\r\n    }\r\n    formatJson() {\r\n        const abi = this.fragments.map((f) => f.format(\"json\"))\r\n        return JSON.stringify(abi.map((j) => JSON.parse(j)))\r\n    }\r\n    getAbiCoder() {\r\n        return AbiCoder.defaultAbiCoder()\r\n    }\r\n    #getFunction(key, values, forceUnique) {\r\n        if (isHexString(key)) {\r\n            const selector = key.toLowerCase()\r\n            for (const fragment of this.#functions.values()) {\r\n                if (selector === fragment.selector) {\r\n                    return fragment\r\n                }\r\n            }\r\n            return null\r\n        }\r\n        if (key.indexOf(\"(\") === -1) {\r\n            const matching = []\r\n            for (const [name, fragment] of this.#functions) {\r\n                if (name.split(\"(\")[0] === key) {\r\n                    matching.push(fragment)\r\n                }\r\n            }\r\n            if (values) {\r\n                const lastValue =\r\n                    values.length > 0 ? values[values.length - 1] : null\r\n                let valueLength = values.length\r\n                let allowOptions = true\r\n                if (\r\n                    Typed.isTyped(lastValue) &&\r\n                    lastValue.type === \"overrides\"\r\n                ) {\r\n                    allowOptions = false\r\n                    valueLength--\r\n                }\r\n                for (let i = matching.length - 1; i >= 0; i--) {\r\n                    const inputs = matching[i].inputs.length\r\n                    if (\r\n                        inputs !== valueLength &&\r\n                        (!allowOptions || inputs !== valueLength - 1)\r\n                    ) {\r\n                        matching.splice(i, 1)\r\n                    }\r\n                }\r\n                for (let i = matching.length - 1; i >= 0; i--) {\r\n                    const inputs = matching[i].inputs\r\n                    for (let j = 0; j < values.length; j++) {\r\n                        if (!Typed.isTyped(values[j])) {\r\n                            continue\r\n                        }\r\n                        if (j >= inputs.length) {\r\n                            if (values[j].type === \"overrides\") {\r\n                                continue\r\n                            }\r\n                            matching.splice(i, 1)\r\n                            break\r\n                        }\r\n                        if (values[j].type !== inputs[j].baseType) {\r\n                            matching.splice(i, 1)\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (\r\n                matching.length === 1 &&\r\n                values &&\r\n                values.length !== matching[0].inputs.length\r\n            ) {\r\n                const lastArg = values[values.length - 1]\r\n                if (\r\n                    lastArg == null ||\r\n                    Array.isArray(lastArg) ||\r\n                    typeof lastArg !== \"object\"\r\n                ) {\r\n                    matching.splice(0, 1)\r\n                }\r\n            }\r\n            if (matching.length === 0) {\r\n                return null\r\n            }\r\n            if (matching.length > 1 && forceUnique) {\r\n                const matchStr = matching\r\n                    .map((m) => JSON.stringify(m.format()))\r\n                    .join(\", \")\r\n                assertArgument(\r\n                    false,\r\n                    `ambiguous function description (i.e. matches ${matchStr})`,\r\n                    \"key\",\r\n                    key,\r\n                )\r\n            }\r\n            return matching[0]\r\n        }\r\n        const result = this.#functions.get(FunctionFragment.from(key).format())\r\n        if (result) {\r\n            return result\r\n        }\r\n        return null\r\n    }\r\n    getFunctionName(key) {\r\n        const fragment = this.#getFunction(key, null, false)\r\n        assertArgument(fragment, \"no matching function\", \"key\", key)\r\n        return fragment.name\r\n    }\r\n    hasFunction(key) {\r\n        return !!this.#getFunction(key, null, false)\r\n    }\r\n    getFunction(key, values) {\r\n        return this.#getFunction(key, values || null, true)\r\n    }\r\n    forEachFunction(callback) {\r\n        const names = Array.from(this.#functions.keys())\r\n        names.sort((a, b) => a.localeCompare(b))\r\n        for (let i = 0; i < names.length; i++) {\r\n            const name = names[i]\r\n            callback(this.#functions.get(name), i)\r\n        }\r\n    }\r\n    #getEvent(key, values, forceUnique) {\r\n        if (isHexString(key)) {\r\n            const eventTopic = key.toLowerCase()\r\n            for (const fragment of this.#events.values()) {\r\n                if (eventTopic === fragment.topicHash) {\r\n                    return fragment\r\n                }\r\n            }\r\n            return null\r\n        }\r\n        if (key.indexOf(\"(\") === -1) {\r\n            const matching = []\r\n            for (const [name, fragment] of this.#events) {\r\n                if (name.split(\"(\")[0] === key) {\r\n                    matching.push(fragment)\r\n                }\r\n            }\r\n            if (values) {\r\n                for (let i = matching.length - 1; i >= 0; i--) {\r\n                    if (matching[i].inputs.length < values.length) {\r\n                        matching.splice(i, 1)\r\n                    }\r\n                }\r\n                for (let i = matching.length - 1; i >= 0; i--) {\r\n                    const inputs = matching[i].inputs\r\n                    for (let j = 0; j < values.length; j++) {\r\n                        if (!Typed.isTyped(values[j])) {\r\n                            continue\r\n                        }\r\n                        if (values[j].type !== inputs[j].baseType) {\r\n                            matching.splice(i, 1)\r\n                            break\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (matching.length === 0) {\r\n                return null\r\n            }\r\n            if (matching.length > 1 && forceUnique) {\r\n                const matchStr = matching\r\n                    .map((m) => JSON.stringify(m.format()))\r\n                    .join(\", \")\r\n                assertArgument(\r\n                    false,\r\n                    `ambiguous event description (i.e. matches ${matchStr})`,\r\n                    \"key\",\r\n                    key,\r\n                )\r\n            }\r\n            return matching[0]\r\n        }\r\n        const result = this.#events.get(EventFragment.from(key).format())\r\n        if (result) {\r\n            return result\r\n        }\r\n        return null\r\n    }\r\n    getEventName(key) {\r\n        const fragment = this.#getEvent(key, null, false)\r\n        assertArgument(fragment, \"no matching event\", \"key\", key)\r\n        return fragment.name\r\n    }\r\n    hasEvent(key) {\r\n        return !!this.#getEvent(key, null, false)\r\n    }\r\n    getEvent(key, values) {\r\n        return this.#getEvent(key, values || null, true)\r\n    }\r\n    forEachEvent(callback) {\r\n        const names = Array.from(this.#events.keys())\r\n        names.sort((a, b) => a.localeCompare(b))\r\n        for (let i = 0; i < names.length; i++) {\r\n            const name = names[i]\r\n            callback(this.#events.get(name), i)\r\n        }\r\n    }\r\n    getError(key, values) {\r\n        if (isHexString(key)) {\r\n            const selector = key.toLowerCase()\r\n            if (BuiltinErrors[selector]) {\r\n                return ErrorFragment.from(BuiltinErrors[selector].signature)\r\n            }\r\n            for (const fragment of this.#errors.values()) {\r\n                if (selector === fragment.selector) {\r\n                    return fragment\r\n                }\r\n            }\r\n            return null\r\n        }\r\n        if (key.indexOf(\"(\") === -1) {\r\n            const matching = []\r\n            for (const [name, fragment] of this.#errors) {\r\n                if (name.split(\"(\")[0] === key) {\r\n                    matching.push(fragment)\r\n                }\r\n            }\r\n            if (matching.length === 0) {\r\n                if (key === \"Error\") {\r\n                    return ErrorFragment.from(\"error Error(string)\")\r\n                }\r\n                if (key === \"Panic\") {\r\n                    return ErrorFragment.from(\"error Panic(uint256)\")\r\n                }\r\n                return null\r\n            } else if (matching.length > 1) {\r\n                const matchStr = matching\r\n                    .map((m) => JSON.stringify(m.format()))\r\n                    .join(\", \")\r\n                assertArgument(\r\n                    false,\r\n                    `ambiguous error description (i.e. ${matchStr})`,\r\n                    \"name\",\r\n                    key,\r\n                )\r\n            }\r\n            return matching[0]\r\n        }\r\n        key = ErrorFragment.from(key).format()\r\n        if (key === \"Error(string)\") {\r\n            return ErrorFragment.from(\"error Error(string)\")\r\n        }\r\n        if (key === \"Panic(uint256)\") {\r\n            return ErrorFragment.from(\"error Panic(uint256)\")\r\n        }\r\n        const result = this.#errors.get(key)\r\n        if (result) {\r\n            return result\r\n        }\r\n        return null\r\n    }\r\n    forEachError(callback) {\r\n        const names = Array.from(this.#errors.keys())\r\n        names.sort((a, b) => a.localeCompare(b))\r\n        for (let i = 0; i < names.length; i++) {\r\n            const name = names[i]\r\n            callback(this.#errors.get(name), i)\r\n        }\r\n    }\r\n    _decodeParams(params, data) {\r\n        return this.#abiCoder.decode(params, data)\r\n    }\r\n    _encodeParams(params, values) {\r\n        return this.#abiCoder.encode(params, values)\r\n    }\r\n    encodeDeploy(values) {\r\n        return this._encodeParams(this.deploy.inputs, values || [])\r\n    }\r\n    decodeErrorResult(fragment, data) {\r\n        if (typeof fragment === \"string\") {\r\n            const f = this.getError(fragment)\r\n            assertArgument(f, \"unknown error\", \"fragment\", fragment)\r\n            fragment = f\r\n        }\r\n        assertArgument(\r\n            dataSlice(data, 0, 4) === fragment.selector,\r\n            `data signature does not match error ${fragment.name}.`,\r\n            \"data\",\r\n            data,\r\n        )\r\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4))\r\n    }\r\n    encodeErrorResult(fragment, values) {\r\n        if (typeof fragment === \"string\") {\r\n            const f = this.getError(fragment)\r\n            assertArgument(f, \"unknown error\", \"fragment\", fragment)\r\n            fragment = f\r\n        }\r\n        return concat([\r\n            fragment.selector,\r\n            this._encodeParams(fragment.inputs, values || []),\r\n        ])\r\n    }\r\n    decodeFunctionData(fragment, data) {\r\n        if (typeof fragment === \"string\") {\r\n            const f = this.getFunction(fragment)\r\n            assertArgument(f, \"unknown function\", \"fragment\", fragment)\r\n            fragment = f\r\n        }\r\n        assertArgument(\r\n            dataSlice(data, 0, 4) === fragment.selector,\r\n            `data signature does not match function ${fragment.name}.`,\r\n            \"data\",\r\n            data,\r\n        )\r\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4))\r\n    }\r\n    encodeFunctionData(fragment, values) {\r\n        if (typeof fragment === \"string\") {\r\n            const f = this.getFunction(fragment)\r\n            assertArgument(f, \"unknown function\", \"fragment\", fragment)\r\n            fragment = f\r\n        }\r\n        return concat([\r\n            fragment.selector,\r\n            this._encodeParams(fragment.inputs, values || []),\r\n        ])\r\n    }\r\n    decodeFunctionResult(fragment, data) {\r\n        if (typeof fragment === \"string\") {\r\n            const f = this.getFunction(fragment)\r\n            assertArgument(f, \"unknown function\", \"fragment\", fragment)\r\n            fragment = f\r\n        }\r\n        let message = \"invalid length for result data\"\r\n        const bytes = getBytesCopy(data)\r\n        if (bytes.length % 32 === 0) {\r\n            try {\r\n                return this.#abiCoder.decode(fragment.outputs, bytes)\r\n            } catch (error) {\r\n                message = \"could not decode result data\"\r\n            }\r\n        }\r\n        assert(false, message, \"BAD_DATA\", {\r\n            value: hexlify(bytes),\r\n            info: {\r\n                method: fragment.name,\r\n                signature: fragment.format(),\r\n            },\r\n        })\r\n    }\r\n    makeError(_data, tx) {\r\n        const data = getBytes(_data, \"data\")\r\n        const error = AbiCoder.getBuiltinCallException(\"call\", tx, data)\r\n        const customPrefix = \"execution reverted (unknown custom error)\"\r\n        if (error.message.startsWith(customPrefix)) {\r\n            const selector = hexlify(data.slice(0, 4))\r\n            const ef = this.getError(selector)\r\n            if (ef) {\r\n                try {\r\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4))\r\n                    error.revert = {\r\n                        name: ef.name,\r\n                        signature: ef.format(),\r\n                        args: args,\r\n                    }\r\n                    error.reason = error.revert.signature\r\n                    error.message = `execution reverted: ${error.reason}`\r\n                } catch (e) {\r\n                    error.message = `execution reverted (coult not decode custom error)`\r\n                }\r\n            }\r\n        }\r\n        const parsed = this.parseTransaction(tx)\r\n        if (parsed) {\r\n            error.invocation = {\r\n                method: parsed.name,\r\n                signature: parsed.signature,\r\n                args: parsed.args,\r\n            }\r\n        }\r\n        return error\r\n    }\r\n    encodeFunctionResult(fragment, values) {\r\n        if (typeof fragment === \"string\") {\r\n            const f = this.getFunction(fragment)\r\n            assertArgument(f, \"unknown function\", \"fragment\", fragment)\r\n            fragment = f\r\n        }\r\n        return hexlify(this.#abiCoder.encode(fragment.outputs, values || []))\r\n    }\r\n    encodeFilterTopics(fragment, values) {\r\n        if (typeof fragment === \"string\") {\r\n            const f = this.getEvent(fragment)\r\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment)\r\n            fragment = f\r\n        }\r\n        assert(\r\n            values.length <= fragment.inputs.length,\r\n            `too many arguments for ${fragment.format()}`,\r\n            \"UNEXPECTED_ARGUMENT\",\r\n            {\r\n                count: values.length,\r\n                expectedCount: fragment.inputs.length,\r\n            },\r\n        )\r\n        const topics = []\r\n        if (!fragment.anonymous) {\r\n            topics.push(fragment.topicHash)\r\n        }\r\n        const encodeTopic = (param, value) => {\r\n            if (param.type === \"string\") {\r\n                return id(value)\r\n            } else if (param.type === \"bytes\") {\r\n                return keccak256(hexlify(value))\r\n            }\r\n            if (param.type === \"bool\" && typeof value === \"boolean\") {\r\n                value = value ? \"0x01\" : \"0x00\"\r\n            } else if (param.type.match(/^u?int/)) {\r\n                value = toBeHex(value)\r\n            } else if (param.type.match(/^bytes/)) {\r\n                value = zeroPadBytes(value, 32)\r\n            } else if (param.type === \"address\") {\r\n                this.#abiCoder.encode([\"address\"], [value])\r\n            }\r\n            return zeroPadValue(hexlify(value), 32)\r\n        }\r\n        values.forEach((value, index) => {\r\n            const param = fragment.inputs[index]\r\n            if (!param.indexed) {\r\n                assertArgument(\r\n                    value == null,\r\n                    \"cannot filter non-indexed parameters; must be null\",\r\n                    \"contract.\" + param.name,\r\n                    value,\r\n                )\r\n                return\r\n            }\r\n            if (value == null) {\r\n                topics.push(null)\r\n            } else if (\r\n                param.baseType === \"array\" ||\r\n                param.baseType === \"tuple\"\r\n            ) {\r\n                assertArgument(\r\n                    false,\r\n                    \"filtering with tuples or arrays not supported\",\r\n                    \"contract.\" + param.name,\r\n                    value,\r\n                )\r\n            } else if (Array.isArray(value)) {\r\n                topics.push(value.map((value) => encodeTopic(param, value)))\r\n            } else {\r\n                topics.push(encodeTopic(param, value))\r\n            }\r\n        })\r\n        while (topics.length && topics[topics.length - 1] === null) {\r\n            topics.pop()\r\n        }\r\n        return topics\r\n    }\r\n    encodeEventLog(fragment, values) {\r\n        if (typeof fragment === \"string\") {\r\n            const f = this.getEvent(fragment)\r\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment)\r\n            fragment = f\r\n        }\r\n        const topics = []\r\n        const dataTypes = []\r\n        const dataValues = []\r\n        if (!fragment.anonymous) {\r\n            topics.push(fragment.topicHash)\r\n        }\r\n        assertArgument(\r\n            values.length === fragment.inputs.length,\r\n            \"event arguments/values mismatch\",\r\n            \"values\",\r\n            values,\r\n        )\r\n        fragment.inputs.forEach((param, index) => {\r\n            const value = values[index]\r\n            if (param.indexed) {\r\n                if (param.type === \"string\") {\r\n                    topics.push(id(value))\r\n                } else if (param.type === \"bytes\") {\r\n                    topics.push(keccak256(value))\r\n                } else if (\r\n                    param.baseType === \"tuple\" ||\r\n                    param.baseType === \"array\"\r\n                ) {\r\n                    throw new Error(\"not implemented\")\r\n                } else {\r\n                    topics.push(this.#abiCoder.encode([param.type], [value]))\r\n                }\r\n            } else {\r\n                dataTypes.push(param)\r\n                dataValues.push(value)\r\n            }\r\n        })\r\n        return {\r\n            data: this.#abiCoder.encode(dataTypes, dataValues),\r\n            topics: topics,\r\n        }\r\n    }\r\n    decodeEventLog(fragment, data, topics) {\r\n        if (typeof fragment === \"string\") {\r\n            const f = this.getEvent(fragment)\r\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment)\r\n            fragment = f\r\n        }\r\n        if (topics != null && !fragment.anonymous) {\r\n            const eventTopic = fragment.topicHash\r\n            assertArgument(\r\n                isHexString(topics[0], 32) &&\r\n                    topics[0].toLowerCase() === eventTopic,\r\n                \"fragment/topic mismatch\",\r\n                \"topics[0]\",\r\n                topics[0],\r\n            )\r\n            topics = topics.slice(1)\r\n        }\r\n        const indexed = []\r\n        const nonIndexed = []\r\n        const dynamic = []\r\n        fragment.inputs.forEach((param, index) => {\r\n            if (param.indexed) {\r\n                if (\r\n                    param.type === \"string\" ||\r\n                    param.type === \"bytes\" ||\r\n                    param.baseType === \"tuple\" ||\r\n                    param.baseType === \"array\"\r\n                ) {\r\n                    indexed.push(\r\n                        ParamType.from({\r\n                            type: \"bytes32\",\r\n                            name: param.name,\r\n                        }),\r\n                    )\r\n                    dynamic.push(true)\r\n                } else {\r\n                    indexed.push(param)\r\n                    dynamic.push(false)\r\n                }\r\n            } else {\r\n                nonIndexed.push(param)\r\n                dynamic.push(false)\r\n            }\r\n        })\r\n        const resultIndexed =\r\n            topics != null\r\n                ? this.#abiCoder.decode(indexed, concat(topics))\r\n                : null\r\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true)\r\n        const values = []\r\n        const keys = []\r\n        let nonIndexedIndex = 0,\r\n            indexedIndex = 0\r\n        fragment.inputs.forEach((param, index) => {\r\n            let value = null\r\n            if (param.indexed) {\r\n                if (resultIndexed == null) {\r\n                    value = new Indexed(null)\r\n                } else if (dynamic[index]) {\r\n                    value = new Indexed(resultIndexed[indexedIndex++])\r\n                } else {\r\n                    try {\r\n                        value = resultIndexed[indexedIndex++]\r\n                    } catch (error) {\r\n                        value = error\r\n                    }\r\n                }\r\n            } else {\r\n                try {\r\n                    value = resultNonIndexed[nonIndexedIndex++]\r\n                } catch (error) {\r\n                    value = error\r\n                }\r\n            }\r\n            values.push(value)\r\n            keys.push(param.name || null)\r\n        })\r\n        return Result.fromItems(values, keys)\r\n    }\r\n    parseTransaction(tx) {\r\n        const data = getBytes(tx.data, \"tx.data\")\r\n        const value = getBigInt(tx.value != null ? tx.value : 0, \"tx.value\")\r\n        const fragment = this.getFunction(hexlify(data.slice(0, 4)))\r\n        if (!fragment) {\r\n            return null\r\n        }\r\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4))\r\n        return new TransactionDescription(\r\n            fragment,\r\n            fragment.selector,\r\n            args,\r\n            value,\r\n        )\r\n    }\r\n    parseCallResult(data) {\r\n        throw new Error(\"@TODO\")\r\n    }\r\n    parseLog(log) {\r\n        const fragment = this.getEvent(log.topics[0])\r\n        if (!fragment || fragment.anonymous) {\r\n            return null\r\n        }\r\n        return new LogDescription(\r\n            fragment,\r\n            fragment.topicHash,\r\n            this.decodeEventLog(fragment, log.data, log.topics),\r\n        )\r\n    }\r\n    parseError(data) {\r\n        const hexData = hexlify(data)\r\n        const fragment = this.getError(dataSlice(hexData, 0, 4))\r\n        if (!fragment) {\r\n            return null\r\n        }\r\n        const args = this.#abiCoder.decode(\r\n            fragment.inputs,\r\n            dataSlice(hexData, 4),\r\n        )\r\n        return new ErrorDescription(fragment, fragment.selector, args)\r\n    }\r\n    static from(value) {\r\n        if (value instanceof Interface) {\r\n            return value\r\n        }\r\n        if (typeof value === \"string\") {\r\n            return new Interface(JSON.parse(value))\r\n        }\r\n        if (typeof value.format === \"function\") {\r\n            return new Interface(value.format(\"json\"))\r\n        }\r\n        return new Interface(value)\r\n    }\r\n}\r\nconst BN_0$2 = BigInt(0)\r\nfunction getValue(value) {\r\n    if (value == null) {\r\n        return null\r\n    }\r\n    return value\r\n}\r\nfunction toJson(value) {\r\n    if (value == null) {\r\n        return null\r\n    }\r\n    return value.toString()\r\n}\r\nclass FeeData {\r\n    gasPrice\r\n    maxFeePerGas\r\n    maxPriorityFeePerGas\r\n    constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {\r\n        defineProperties(this, {\r\n            gasPrice: getValue(gasPrice),\r\n            maxFeePerGas: getValue(maxFeePerGas),\r\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas),\r\n        })\r\n    }\r\n    toJSON() {\r\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this\r\n        return {\r\n            _type: \"FeeData\",\r\n            gasPrice: toJson(gasPrice),\r\n            maxFeePerGas: toJson(maxFeePerGas),\r\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),\r\n        }\r\n    }\r\n}\r\nfunction copyRequest(req) {\r\n    const result = {}\r\n    if (req.to) {\r\n        result.to = req.to\r\n    }\r\n    if (req.from) {\r\n        result.from = req.from\r\n    }\r\n    if (req.data) {\r\n        result.data = hexlify(req.data)\r\n    }\r\n    const bigIntKeys =\r\n        \"chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value\".split(\r\n            /,/,\r\n        )\r\n    for (const key of bigIntKeys) {\r\n        if (!(key in req) || req[key] == null) {\r\n            continue\r\n        }\r\n        result[key] = getBigInt(req[key], `request.${key}`)\r\n    }\r\n    const numberKeys = \"type,nonce\".split(/,/)\r\n    for (const key of numberKeys) {\r\n        if (!(key in req) || req[key] == null) {\r\n            continue\r\n        }\r\n        result[key] = getNumber(req[key], `request.${key}`)\r\n    }\r\n    if (req.accessList) {\r\n        result.accessList = accessListify(req.accessList)\r\n    }\r\n    if (\"blockTag\" in req) {\r\n        result.blockTag = req.blockTag\r\n    }\r\n    if (\"enableCcipRead\" in req) {\r\n        result.enableCcipRead = !!req.enableCcipRead\r\n    }\r\n    if (\"customData\" in req) {\r\n        result.customData = req.customData\r\n    }\r\n    return result\r\n}\r\nclass Block {\r\n    provider\r\n    number\r\n    hash\r\n    timestamp\r\n    parentHash\r\n    nonce\r\n    difficulty\r\n    gasLimit\r\n    gasUsed\r\n    miner\r\n    extraData\r\n    baseFeePerGas\r\n    #transactions\r\n    constructor(block, provider) {\r\n        this.#transactions = block.transactions.map((tx) => {\r\n            if (typeof tx !== \"string\") {\r\n                return new TransactionResponse(tx, provider)\r\n            }\r\n            return tx\r\n        })\r\n        defineProperties(this, {\r\n            provider: provider,\r\n            hash: getValue(block.hash),\r\n            number: block.number,\r\n            timestamp: block.timestamp,\r\n            parentHash: block.parentHash,\r\n            nonce: block.nonce,\r\n            difficulty: block.difficulty,\r\n            gasLimit: block.gasLimit,\r\n            gasUsed: block.gasUsed,\r\n            miner: block.miner,\r\n            extraData: block.extraData,\r\n            baseFeePerGas: getValue(block.baseFeePerGas),\r\n        })\r\n    }\r\n    get transactions() {\r\n        return this.#transactions.map((tx) => {\r\n            if (typeof tx === \"string\") {\r\n                return tx\r\n            }\r\n            return tx.hash\r\n        })\r\n    }\r\n    get prefetchedTransactions() {\r\n        const txs = this.#transactions.slice()\r\n        if (txs.length === 0) {\r\n            return []\r\n        }\r\n        assert(\r\n            typeof txs[0] === \"object\",\r\n            \"transactions were not prefetched with block request\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"transactionResponses()\",\r\n            },\r\n        )\r\n        return txs\r\n    }\r\n    toJSON() {\r\n        const {\r\n            baseFeePerGas,\r\n            difficulty,\r\n            extraData,\r\n            gasLimit,\r\n            gasUsed,\r\n            hash,\r\n            miner,\r\n            nonce,\r\n            number,\r\n            parentHash,\r\n            timestamp,\r\n            transactions,\r\n        } = this\r\n        return {\r\n            _type: \"Block\",\r\n            baseFeePerGas: toJson(baseFeePerGas),\r\n            difficulty: toJson(difficulty),\r\n            extraData: extraData,\r\n            gasLimit: toJson(gasLimit),\r\n            gasUsed: toJson(gasUsed),\r\n            hash: hash,\r\n            miner: miner,\r\n            nonce: nonce,\r\n            number: number,\r\n            parentHash: parentHash,\r\n            timestamp: timestamp,\r\n            transactions: transactions,\r\n        }\r\n    }\r\n    [Symbol.iterator]() {\r\n        let index = 0\r\n        const txs = this.transactions\r\n        return {\r\n            next: () => {\r\n                if (index < this.length) {\r\n                    return {\r\n                        value: txs[index++],\r\n                        done: false,\r\n                    }\r\n                }\r\n                return {\r\n                    value: undefined,\r\n                    done: true,\r\n                }\r\n            },\r\n        }\r\n    }\r\n    get length() {\r\n        return this.#transactions.length\r\n    }\r\n    get date() {\r\n        if (this.timestamp == null) {\r\n            return null\r\n        }\r\n        return new Date(this.timestamp * 1e3)\r\n    }\r\n    async getTransaction(indexOrHash) {\r\n        let tx = undefined\r\n        if (typeof indexOrHash === \"number\") {\r\n            tx = this.#transactions[indexOrHash]\r\n        } else {\r\n            const hash = indexOrHash.toLowerCase()\r\n            for (const v of this.#transactions) {\r\n                if (typeof v === \"string\") {\r\n                    if (v !== hash) {\r\n                        continue\r\n                    }\r\n                    tx = v\r\n                    break\r\n                } else {\r\n                    if (v.hash === hash) {\r\n                        continue\r\n                    }\r\n                    tx = v\r\n                    break\r\n                }\r\n            }\r\n        }\r\n        if (tx == null) {\r\n            throw new Error(\"no such tx\")\r\n        }\r\n        if (typeof tx === \"string\") {\r\n            return await this.provider.getTransaction(tx)\r\n        } else {\r\n            return tx\r\n        }\r\n    }\r\n    getPrefetchedTransaction(indexOrHash) {\r\n        const txs = this.prefetchedTransactions\r\n        if (typeof indexOrHash === \"number\") {\r\n            return txs[indexOrHash]\r\n        }\r\n        indexOrHash = indexOrHash.toLowerCase()\r\n        for (const tx of txs) {\r\n            if (tx.hash === indexOrHash) {\r\n                return tx\r\n            }\r\n        }\r\n        assertArgument(\r\n            false,\r\n            \"no matching transaction\",\r\n            \"indexOrHash\",\r\n            indexOrHash,\r\n        )\r\n    }\r\n    isMined() {\r\n        return !!this.hash\r\n    }\r\n    isLondon() {\r\n        return !!this.baseFeePerGas\r\n    }\r\n    orphanedEvent() {\r\n        if (!this.isMined()) {\r\n            throw new Error(\"\")\r\n        }\r\n        return createOrphanedBlockFilter(this)\r\n    }\r\n}\r\nclass Log {\r\n    provider\r\n    transactionHash\r\n    blockHash\r\n    blockNumber\r\n    removed\r\n    address\r\n    data\r\n    topics\r\n    index\r\n    transactionIndex\r\n    constructor(log, provider) {\r\n        this.provider = provider\r\n        const topics = Object.freeze(log.topics.slice())\r\n        defineProperties(this, {\r\n            transactionHash: log.transactionHash,\r\n            blockHash: log.blockHash,\r\n            blockNumber: log.blockNumber,\r\n            removed: log.removed,\r\n            address: log.address,\r\n            data: log.data,\r\n            topics: topics,\r\n            index: log.index,\r\n            transactionIndex: log.transactionIndex,\r\n        })\r\n    }\r\n    toJSON() {\r\n        const {\r\n            address,\r\n            blockHash,\r\n            blockNumber,\r\n            data,\r\n            index,\r\n            removed,\r\n            topics,\r\n            transactionHash,\r\n            transactionIndex,\r\n        } = this\r\n        return {\r\n            _type: \"log\",\r\n            address: address,\r\n            blockHash: blockHash,\r\n            blockNumber: blockNumber,\r\n            data: data,\r\n            index: index,\r\n            removed: removed,\r\n            topics: topics,\r\n            transactionHash: transactionHash,\r\n            transactionIndex: transactionIndex,\r\n        }\r\n    }\r\n    async getBlock() {\r\n        const block = await this.provider.getBlock(this.blockHash)\r\n        assert(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {})\r\n        return block\r\n    }\r\n    async getTransaction() {\r\n        const tx = await this.provider.getTransaction(this.transactionHash)\r\n        assert(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {})\r\n        return tx\r\n    }\r\n    async getTransactionReceipt() {\r\n        const receipt = await this.provider.getTransactionReceipt(\r\n            this.transactionHash,\r\n        )\r\n        assert(\r\n            !!receipt,\r\n            \"failed to find transaction receipt\",\r\n            \"UNKNOWN_ERROR\",\r\n            {},\r\n        )\r\n        return receipt\r\n    }\r\n    removedEvent() {\r\n        return createRemovedLogFilter(this)\r\n    }\r\n}\r\nclass TransactionReceipt {\r\n    provider\r\n    to\r\n    from\r\n    contractAddress\r\n    hash\r\n    index\r\n    blockHash\r\n    blockNumber\r\n    logsBloom\r\n    gasUsed\r\n    cumulativeGasUsed\r\n    gasPrice\r\n    type\r\n    status\r\n    root\r\n    #logs\r\n    constructor(tx, provider) {\r\n        this.#logs = Object.freeze(\r\n            tx.logs.map((log) => {\r\n                return new Log(log, provider)\r\n            }),\r\n        )\r\n        let gasPrice = BN_0$2\r\n        if (tx.effectiveGasPrice != null) {\r\n            gasPrice = tx.effectiveGasPrice\r\n        } else if (tx.gasPrice != null) {\r\n            gasPrice = tx.gasPrice\r\n        }\r\n        defineProperties(this, {\r\n            provider: provider,\r\n            to: tx.to,\r\n            from: tx.from,\r\n            contractAddress: tx.contractAddress,\r\n            hash: tx.hash,\r\n            index: tx.index,\r\n            blockHash: tx.blockHash,\r\n            blockNumber: tx.blockNumber,\r\n            logsBloom: tx.logsBloom,\r\n            gasUsed: tx.gasUsed,\r\n            cumulativeGasUsed: tx.cumulativeGasUsed,\r\n            gasPrice: gasPrice,\r\n            type: tx.type,\r\n            status: tx.status,\r\n            root: tx.root,\r\n        })\r\n    }\r\n    get logs() {\r\n        return this.#logs\r\n    }\r\n    toJSON() {\r\n        const {\r\n            to,\r\n            from,\r\n            contractAddress,\r\n            hash,\r\n            index,\r\n            blockHash,\r\n            blockNumber,\r\n            logsBloom,\r\n            logs,\r\n            status,\r\n            root,\r\n        } = this\r\n        return {\r\n            _type: \"TransactionReceipt\",\r\n            blockHash: blockHash,\r\n            blockNumber: blockNumber,\r\n            contractAddress: contractAddress,\r\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\r\n            from: from,\r\n            gasPrice: toJson(this.gasPrice),\r\n            gasUsed: toJson(this.gasUsed),\r\n            hash: hash,\r\n            index: index,\r\n            logs: logs,\r\n            logsBloom: logsBloom,\r\n            root: root,\r\n            status: status,\r\n            to: to,\r\n        }\r\n    }\r\n    get length() {\r\n        return this.logs.length\r\n    }\r\n    [Symbol.iterator]() {\r\n        let index = 0\r\n        return {\r\n            next: () => {\r\n                if (index < this.length) {\r\n                    return {\r\n                        value: this.logs[index++],\r\n                        done: false,\r\n                    }\r\n                }\r\n                return {\r\n                    value: undefined,\r\n                    done: true,\r\n                }\r\n            },\r\n        }\r\n    }\r\n    get fee() {\r\n        return this.gasUsed * this.gasPrice\r\n    }\r\n    async getBlock() {\r\n        const block = await this.provider.getBlock(this.blockHash)\r\n        if (block == null) {\r\n            throw new Error(\"TODO\")\r\n        }\r\n        return block\r\n    }\r\n    async getTransaction() {\r\n        const tx = await this.provider.getTransaction(this.hash)\r\n        if (tx == null) {\r\n            throw new Error(\"TODO\")\r\n        }\r\n        return tx\r\n    }\r\n    async getResult() {\r\n        return await this.provider.getTransactionResult(this.hash)\r\n    }\r\n    async confirmations() {\r\n        return (await this.provider.getBlockNumber()) - this.blockNumber + 1\r\n    }\r\n    removedEvent() {\r\n        return createRemovedTransactionFilter(this)\r\n    }\r\n    reorderedEvent(other) {\r\n        assert(\r\n            !other || other.isMined(),\r\n            \"unmined 'other' transction cannot be orphaned\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"reorderedEvent(other)\",\r\n            },\r\n        )\r\n        return createReorderedTransactionFilter(this, other)\r\n    }\r\n}\r\nclass TransactionResponse {\r\n    provider\r\n    blockNumber\r\n    blockHash\r\n    index\r\n    hash\r\n    type\r\n    to\r\n    from\r\n    nonce\r\n    gasLimit\r\n    gasPrice\r\n    maxPriorityFeePerGas\r\n    maxFeePerGas\r\n    data\r\n    value\r\n    chainId\r\n    signature\r\n    accessList\r\n    #startBlock\r\n    constructor(tx, provider) {\r\n        this.provider = provider\r\n        this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null\r\n        this.blockHash = tx.blockHash != null ? tx.blockHash : null\r\n        this.hash = tx.hash\r\n        this.index = tx.index\r\n        this.type = tx.type\r\n        this.from = tx.from\r\n        this.to = tx.to || null\r\n        this.gasLimit = tx.gasLimit\r\n        this.nonce = tx.nonce\r\n        this.data = tx.data\r\n        this.value = tx.value\r\n        this.gasPrice = tx.gasPrice\r\n        this.maxPriorityFeePerGas =\r\n            tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null\r\n        this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null\r\n        this.chainId = tx.chainId\r\n        this.signature = tx.signature\r\n        this.accessList = tx.accessList != null ? tx.accessList : null\r\n        this.#startBlock = -1\r\n    }\r\n    toJSON() {\r\n        const {\r\n            blockNumber,\r\n            blockHash,\r\n            index,\r\n            hash,\r\n            type,\r\n            to,\r\n            from,\r\n            nonce,\r\n            data,\r\n            signature,\r\n            accessList,\r\n        } = this\r\n        return {\r\n            _type: \"TransactionReceipt\",\r\n            accessList: accessList,\r\n            blockNumber: blockNumber,\r\n            blockHash: blockHash,\r\n            chainId: toJson(this.chainId),\r\n            data: data,\r\n            from: from,\r\n            gasLimit: toJson(this.gasLimit),\r\n            gasPrice: toJson(this.gasPrice),\r\n            hash: hash,\r\n            maxFeePerGas: toJson(this.maxFeePerGas),\r\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\r\n            nonce: nonce,\r\n            signature: signature,\r\n            to: to,\r\n            index: index,\r\n            type: type,\r\n            value: toJson(this.value),\r\n        }\r\n    }\r\n    async getBlock() {\r\n        let blockNumber = this.blockNumber\r\n        if (blockNumber == null) {\r\n            const tx = await this.getTransaction()\r\n            if (tx) {\r\n                blockNumber = tx.blockNumber\r\n            }\r\n        }\r\n        if (blockNumber == null) {\r\n            return null\r\n        }\r\n        const block = this.provider.getBlock(blockNumber)\r\n        if (block == null) {\r\n            throw new Error(\"TODO\")\r\n        }\r\n        return block\r\n    }\r\n    async getTransaction() {\r\n        return this.provider.getTransaction(this.hash)\r\n    }\r\n    async confirmations() {\r\n        if (this.blockNumber == null) {\r\n            const { tx, blockNumber } = await resolveProperties({\r\n                tx: this.getTransaction(),\r\n                blockNumber: this.provider.getBlockNumber(),\r\n            })\r\n            if (tx == null || tx.blockNumber == null) {\r\n                return 0\r\n            }\r\n            return blockNumber - tx.blockNumber + 1\r\n        }\r\n        const blockNumber = await this.provider.getBlockNumber()\r\n        return blockNumber - this.blockNumber + 1\r\n    }\r\n    async wait(_confirms, _timeout) {\r\n        const confirms = _confirms == null ? 1 : _confirms\r\n        const timeout = _timeout == null ? 0 : _timeout\r\n        let startBlock = this.#startBlock\r\n        let nextScan = -1\r\n        let stopScanning = startBlock === -1 ? true : false\r\n        const checkReplacement = async () => {\r\n            if (stopScanning) {\r\n                return null\r\n            }\r\n            const { blockNumber, nonce } = await resolveProperties({\r\n                blockNumber: this.provider.getBlockNumber(),\r\n                nonce: this.provider.getTransactionCount(this.from),\r\n            })\r\n            if (nonce < this.nonce) {\r\n                startBlock = blockNumber\r\n                return\r\n            }\r\n            if (stopScanning) {\r\n                return null\r\n            }\r\n            const mined = await this.getTransaction()\r\n            if (mined && mined.blockNumber != null) {\r\n                return\r\n            }\r\n            if (nextScan === -1) {\r\n                nextScan = startBlock - 3\r\n                if (nextScan < this.#startBlock) {\r\n                    nextScan = this.#startBlock\r\n                }\r\n            }\r\n            while (nextScan <= blockNumber) {\r\n                if (stopScanning) {\r\n                    return null\r\n                }\r\n                const block = await this.provider.getBlock(nextScan, true)\r\n                if (block == null) {\r\n                    return\r\n                }\r\n                for (const hash of block) {\r\n                    if (hash === this.hash) {\r\n                        return\r\n                    }\r\n                }\r\n                for (let i = 0; i < block.length; i++) {\r\n                    const tx = await block.getTransaction(i)\r\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\r\n                        if (stopScanning) {\r\n                            return null\r\n                        }\r\n                        const receipt =\r\n                            await this.provider.getTransactionReceipt(tx.hash)\r\n                        if (receipt == null) {\r\n                            return\r\n                        }\r\n                        if (blockNumber - receipt.blockNumber + 1 < confirms) {\r\n                            return\r\n                        }\r\n                        let reason = \"replaced\"\r\n                        if (\r\n                            tx.data === this.data &&\r\n                            tx.to === this.to &&\r\n                            tx.value === this.value\r\n                        ) {\r\n                            reason = \"repriced\"\r\n                        } else if (\r\n                            tx.data === \"0x\" &&\r\n                            tx.from === tx.to &&\r\n                            tx.value === BN_0$2\r\n                        ) {\r\n                            reason = \"cancelled\"\r\n                        }\r\n                        assert(\r\n                            false,\r\n                            \"transaction was replaced\",\r\n                            \"TRANSACTION_REPLACED\",\r\n                            {\r\n                                cancelled:\r\n                                    reason === \"replaced\" ||\r\n                                    reason === \"cancelled\",\r\n                                reason: reason,\r\n                                replacement:\r\n                                    tx.replaceableTransaction(startBlock),\r\n                                hash: tx.hash,\r\n                                receipt: receipt,\r\n                            },\r\n                        )\r\n                    }\r\n                }\r\n                nextScan++\r\n            }\r\n            return\r\n        }\r\n        const checkReceipt = (receipt) => {\r\n            if (receipt == null || receipt.status !== 0) {\r\n                return receipt\r\n            }\r\n            assert(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\r\n                action: \"sendTransaction\",\r\n                data: null,\r\n                reason: null,\r\n                invocation: null,\r\n                revert: null,\r\n                transaction: {\r\n                    to: receipt.to,\r\n                    from: receipt.from,\r\n                    data: \"\",\r\n                },\r\n                receipt: receipt,\r\n            })\r\n        }\r\n        const receipt = await this.provider.getTransactionReceipt(this.hash)\r\n        if (confirms === 0) {\r\n            return checkReceipt(receipt)\r\n        }\r\n        if (receipt) {\r\n            if ((await receipt.confirmations()) >= confirms) {\r\n                return checkReceipt(receipt)\r\n            }\r\n        } else {\r\n            await checkReplacement()\r\n            if (confirms === 0) {\r\n                return null\r\n            }\r\n        }\r\n        const waiter = new Promise((resolve, reject) => {\r\n            const cancellers = []\r\n            const cancel = () => {\r\n                cancellers.forEach((c) => c())\r\n            }\r\n            cancellers.push(() => {\r\n                stopScanning = true\r\n            })\r\n            if (timeout > 0) {\r\n                const timer = setTimeout(() => {\r\n                    cancel()\r\n                    reject(makeError(\"wait for transaction timeout\", \"TIMEOUT\"))\r\n                }, timeout)\r\n                cancellers.push(() => {\r\n                    clearTimeout(timer)\r\n                })\r\n            }\r\n            const txListener = async (receipt) => {\r\n                if ((await receipt.confirmations()) >= confirms) {\r\n                    cancel()\r\n                    try {\r\n                        resolve(checkReceipt(receipt))\r\n                    } catch (error) {\r\n                        reject(error)\r\n                    }\r\n                }\r\n            }\r\n            cancellers.push(() => {\r\n                this.provider.off(this.hash, txListener)\r\n            })\r\n            this.provider.on(this.hash, txListener)\r\n            if (startBlock >= 0) {\r\n                const replaceListener = async () => {\r\n                    try {\r\n                        await checkReplacement()\r\n                    } catch (error) {\r\n                        if (isError(error, \"TRANSACTION_REPLACED\")) {\r\n                            cancel()\r\n                            reject(error)\r\n                            return\r\n                        }\r\n                    }\r\n                    if (!stopScanning) {\r\n                        this.provider.once(\"block\", replaceListener)\r\n                    }\r\n                }\r\n                cancellers.push(() => {\r\n                    this.provider.off(\"block\", replaceListener)\r\n                })\r\n                this.provider.once(\"block\", replaceListener)\r\n            }\r\n        })\r\n        return await waiter\r\n    }\r\n    isMined() {\r\n        return this.blockHash != null\r\n    }\r\n    isLegacy() {\r\n        return this.type === 0\r\n    }\r\n    isBerlin() {\r\n        return this.type === 1\r\n    }\r\n    isLondon() {\r\n        return this.type === 2\r\n    }\r\n    removedEvent() {\r\n        assert(\r\n            this.isMined(),\r\n            \"unmined transaction canot be orphaned\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"removeEvent()\",\r\n            },\r\n        )\r\n        return createRemovedTransactionFilter(this)\r\n    }\r\n    reorderedEvent(other) {\r\n        assert(\r\n            this.isMined(),\r\n            \"unmined transaction canot be orphaned\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"removeEvent()\",\r\n            },\r\n        )\r\n        assert(\r\n            !other || other.isMined(),\r\n            \"unmined 'other' transaction canot be orphaned\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"removeEvent()\",\r\n            },\r\n        )\r\n        return createReorderedTransactionFilter(this, other)\r\n    }\r\n    replaceableTransaction(startBlock) {\r\n        assertArgument(\r\n            Number.isInteger(startBlock) && startBlock >= 0,\r\n            \"invalid startBlock\",\r\n            \"startBlock\",\r\n            startBlock,\r\n        )\r\n        const tx = new TransactionResponse(this, this.provider)\r\n        tx.#startBlock = startBlock\r\n        return tx\r\n    }\r\n}\r\nfunction createOrphanedBlockFilter(block) {\r\n    return {\r\n        orphan: \"drop-block\",\r\n        hash: block.hash,\r\n        number: block.number,\r\n    }\r\n}\r\nfunction createReorderedTransactionFilter(tx, other) {\r\n    return {\r\n        orphan: \"reorder-transaction\",\r\n        tx: tx,\r\n        other: other,\r\n    }\r\n}\r\nfunction createRemovedTransactionFilter(tx) {\r\n    return {\r\n        orphan: \"drop-transaction\",\r\n        tx: tx,\r\n    }\r\n}\r\nfunction createRemovedLogFilter(log) {\r\n    return {\r\n        orphan: \"drop-log\",\r\n        log: {\r\n            transactionHash: log.transactionHash,\r\n            blockHash: log.blockHash,\r\n            blockNumber: log.blockNumber,\r\n            address: log.address,\r\n            data: log.data,\r\n            topics: Object.freeze(log.topics.slice()),\r\n            index: log.index,\r\n        },\r\n    }\r\n}\r\nclass EventLog extends Log {\r\n    interface\r\n    fragment\r\n    args\r\n    constructor(log, iface, fragment) {\r\n        super(log, log.provider)\r\n        const args = iface.decodeEventLog(fragment, log.data, log.topics)\r\n        defineProperties(this, {\r\n            args: args,\r\n            fragment: fragment,\r\n            interface: iface,\r\n        })\r\n    }\r\n    get eventName() {\r\n        return this.fragment.name\r\n    }\r\n    get eventSignature() {\r\n        return this.fragment.format()\r\n    }\r\n}\r\nclass UndecodedEventLog extends Log {\r\n    error\r\n    constructor(log, error) {\r\n        super(log, log.provider)\r\n        defineProperties(this, {\r\n            error: error,\r\n        })\r\n    }\r\n}\r\nclass ContractTransactionReceipt extends TransactionReceipt {\r\n    #iface\r\n    constructor(iface, provider, tx) {\r\n        super(tx, provider)\r\n        this.#iface = iface\r\n    }\r\n    get logs() {\r\n        return super.logs.map((log) => {\r\n            const fragment = log.topics.length\r\n                ? this.#iface.getEvent(log.topics[0])\r\n                : null\r\n            if (fragment) {\r\n                try {\r\n                    return new EventLog(log, this.#iface, fragment)\r\n                } catch (error) {\r\n                    return new UndecodedEventLog(log, error)\r\n                }\r\n            }\r\n            return log\r\n        })\r\n    }\r\n}\r\nclass ContractTransactionResponse extends TransactionResponse {\r\n    #iface\r\n    constructor(iface, provider, tx) {\r\n        super(tx, provider)\r\n        this.#iface = iface\r\n    }\r\n    async wait(confirms) {\r\n        const receipt = await super.wait(confirms)\r\n        if (receipt == null) {\r\n            return null\r\n        }\r\n        return new ContractTransactionReceipt(\r\n            this.#iface,\r\n            this.provider,\r\n            receipt,\r\n        )\r\n    }\r\n}\r\nclass ContractUnknownEventPayload extends EventPayload {\r\n    log\r\n    constructor(contract, listener, filter, log) {\r\n        super(contract, listener, filter)\r\n        defineProperties(this, {\r\n            log: log,\r\n        })\r\n    }\r\n    async getBlock() {\r\n        return await this.log.getBlock()\r\n    }\r\n    async getTransaction() {\r\n        return await this.log.getTransaction()\r\n    }\r\n    async getTransactionReceipt() {\r\n        return await this.log.getTransactionReceipt()\r\n    }\r\n}\r\nclass ContractEventPayload extends ContractUnknownEventPayload {\r\n    constructor(contract, listener, filter, fragment, _log) {\r\n        super(\r\n            contract,\r\n            listener,\r\n            filter,\r\n            new EventLog(_log, contract.interface, fragment),\r\n        )\r\n        const args = contract.interface.decodeEventLog(\r\n            fragment,\r\n            this.log.data,\r\n            this.log.topics,\r\n        )\r\n        defineProperties(this, {\r\n            args: args,\r\n            fragment: fragment,\r\n        })\r\n    }\r\n    get eventName() {\r\n        return this.fragment.name\r\n    }\r\n    get eventSignature() {\r\n        return this.fragment.format()\r\n    }\r\n}\r\nconst BN_0$1 = BigInt(0)\r\nfunction canCall(value) {\r\n    return value && typeof value.call === \"function\"\r\n}\r\nfunction canEstimate(value) {\r\n    return value && typeof value.estimateGas === \"function\"\r\n}\r\nfunction canResolve(value) {\r\n    return value && typeof value.resolveName === \"function\"\r\n}\r\nfunction canSend(value) {\r\n    return value && typeof value.sendTransaction === \"function\"\r\n}\r\nfunction getResolver(value) {\r\n    if (value != null) {\r\n        if (canResolve(value)) {\r\n            return value\r\n        }\r\n        if (value.provider) {\r\n            return value.provider\r\n        }\r\n    }\r\n    return undefined\r\n}\r\nclass PreparedTopicFilter {\r\n    #filter\r\n    fragment\r\n    constructor(contract, fragment, args) {\r\n        defineProperties(this, {\r\n            fragment: fragment,\r\n        })\r\n        if (fragment.inputs.length < args.length) {\r\n            throw new Error(\"too many arguments\")\r\n        }\r\n        const runner = getRunner(contract.runner, \"resolveName\")\r\n        const resolver = canResolve(runner) ? runner : null\r\n        this.#filter = (async function () {\r\n            const resolvedArgs = await Promise.all(\r\n                fragment.inputs.map((param, index) => {\r\n                    const arg = args[index]\r\n                    if (arg == null) {\r\n                        return null\r\n                    }\r\n                    return param.walkAsync(args[index], (type, value) => {\r\n                        if (type === \"address\") {\r\n                            if (Array.isArray(value)) {\r\n                                return Promise.all(\r\n                                    value.map((v) =>\r\n                                        resolveAddress(v, resolver),\r\n                                    ),\r\n                                )\r\n                            }\r\n                            return resolveAddress(value, resolver)\r\n                        }\r\n                        return value\r\n                    })\r\n                }),\r\n            )\r\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs)\r\n        })()\r\n    }\r\n    getTopicFilter() {\r\n        return this.#filter\r\n    }\r\n}\r\nfunction getRunner(value, feature) {\r\n    if (value == null) {\r\n        return null\r\n    }\r\n    if (typeof value[feature] === \"function\") {\r\n        return value\r\n    }\r\n    if (value.provider && typeof value.provider[feature] === \"function\") {\r\n        return value.provider\r\n    }\r\n    return null\r\n}\r\nfunction getProvider(value) {\r\n    if (value == null) {\r\n        return null\r\n    }\r\n    return value.provider || null\r\n}\r\nasync function copyOverrides(arg, allowed) {\r\n    const _overrides = Typed.dereference(arg, \"overrides\")\r\n    assertArgument(\r\n        typeof _overrides === \"object\",\r\n        \"invalid overrides parameter\",\r\n        \"overrides\",\r\n        arg,\r\n    )\r\n    const overrides = copyRequest(_overrides)\r\n    assertArgument(\r\n        overrides.to == null || (allowed || []).indexOf(\"to\") >= 0,\r\n        \"cannot override to\",\r\n        \"overrides.to\",\r\n        overrides.to,\r\n    )\r\n    assertArgument(\r\n        overrides.data == null || (allowed || []).indexOf(\"data\") >= 0,\r\n        \"cannot override data\",\r\n        \"overrides.data\",\r\n        overrides.data,\r\n    )\r\n    if (overrides.from) {\r\n        overrides.from = overrides.from\r\n    }\r\n    return overrides\r\n}\r\nasync function resolveArgs(_runner, inputs, args) {\r\n    const runner = getRunner(_runner, \"resolveName\")\r\n    const resolver = canResolve(runner) ? runner : null\r\n    return await Promise.all(\r\n        inputs.map((param, index) => {\r\n            return param.walkAsync(args[index], (type, value) => {\r\n                value = Typed.dereference(value, type)\r\n                if (type === \"address\") {\r\n                    return resolveAddress(value, resolver)\r\n                }\r\n                return value\r\n            })\r\n        }),\r\n    )\r\n}\r\nfunction buildWrappedFallback(contract) {\r\n    const populateTransaction = async function (overrides) {\r\n        const tx = await copyOverrides(overrides, [\"data\"])\r\n        tx.to = await contract.getAddress()\r\n        if (tx.from) {\r\n            tx.from = await resolveAddress(\r\n                tx.from,\r\n                getResolver(contract.runner),\r\n            )\r\n        }\r\n        const iface = contract.interface\r\n        const noValue =\r\n            getBigInt(tx.value || BN_0$1, \"overrides.value\") === BN_0$1\r\n        const noData = (tx.data || \"0x\") === \"0x\"\r\n        if (\r\n            iface.fallback &&\r\n            !iface.fallback.payable &&\r\n            iface.receive &&\r\n            !noData &&\r\n            !noValue\r\n        ) {\r\n            assertArgument(\r\n                false,\r\n                \"cannot send data to receive or send value to non-payable fallback\",\r\n                \"overrides\",\r\n                overrides,\r\n            )\r\n        }\r\n        assertArgument(\r\n            iface.fallback || noData,\r\n            \"cannot send data to receive-only contract\",\r\n            \"overrides.data\",\r\n            tx.data,\r\n        )\r\n        const payable =\r\n            iface.receive || (iface.fallback && iface.fallback.payable)\r\n        assertArgument(\r\n            payable || noValue,\r\n            \"cannot send value to non-payable fallback\",\r\n            \"overrides.value\",\r\n            tx.value,\r\n        )\r\n        assertArgument(\r\n            iface.fallback || noData,\r\n            \"cannot send data to receive-only contract\",\r\n            \"overrides.data\",\r\n            tx.data,\r\n        )\r\n        return tx\r\n    }\r\n    const staticCall = async function (overrides) {\r\n        const runner = getRunner(contract.runner, \"call\")\r\n        assert(\r\n            canCall(runner),\r\n            \"contract runner does not support calling\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"call\",\r\n            },\r\n        )\r\n        const tx = await populateTransaction(overrides)\r\n        try {\r\n            return await runner.call(tx)\r\n        } catch (error) {\r\n            if (isCallException(error) && error.data) {\r\n                throw contract.interface.makeError(error.data, tx)\r\n            }\r\n            throw error\r\n        }\r\n    }\r\n    const send = async function (overrides) {\r\n        const runner = contract.runner\r\n        assert(\r\n            canSend(runner),\r\n            \"contract runner does not support sending transactions\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"sendTransaction\",\r\n            },\r\n        )\r\n        const tx = await runner.sendTransaction(\r\n            await populateTransaction(overrides),\r\n        )\r\n        const provider = getProvider(contract.runner)\r\n        return new ContractTransactionResponse(contract.interface, provider, tx)\r\n    }\r\n    const estimateGas = async function (overrides) {\r\n        const runner = getRunner(contract.runner, \"estimateGas\")\r\n        assert(\r\n            canEstimate(runner),\r\n            \"contract runner does not support gas estimation\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"estimateGas\",\r\n            },\r\n        )\r\n        return await runner.estimateGas(await populateTransaction(overrides))\r\n    }\r\n    const method = async (overrides) => {\r\n        return await send(overrides)\r\n    }\r\n    defineProperties(method, {\r\n        _contract: contract,\r\n        estimateGas: estimateGas,\r\n        populateTransaction: populateTransaction,\r\n        send: send,\r\n        staticCall: staticCall,\r\n    })\r\n    return method\r\n}\r\nfunction buildWrappedMethod(contract, key) {\r\n    const getFragment = function (...args) {\r\n        const fragment = contract.interface.getFunction(key, args)\r\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"fragment\",\r\n            info: {\r\n                key: key,\r\n                args: args,\r\n            },\r\n        })\r\n        return fragment\r\n    }\r\n    const populateTransaction = async function (...args) {\r\n        const fragment = getFragment(...args)\r\n        let overrides = {}\r\n        if (fragment.inputs.length + 1 === args.length) {\r\n            overrides = await copyOverrides(args.pop())\r\n            if (overrides.from) {\r\n                overrides.from = await resolveAddress(\r\n                    overrides.from,\r\n                    getResolver(contract.runner),\r\n                )\r\n            }\r\n        }\r\n        if (fragment.inputs.length !== args.length) {\r\n            throw new Error(\r\n                \"internal error: fragment inputs doesn't match arguments; should not happen\",\r\n            )\r\n        }\r\n        const resolvedArgs = await resolveArgs(\r\n            contract.runner,\r\n            fragment.inputs,\r\n            args,\r\n        )\r\n        return Object.assign(\r\n            {},\r\n            overrides,\r\n            await resolveProperties({\r\n                to: contract.getAddress(),\r\n                data: contract.interface.encodeFunctionData(\r\n                    fragment,\r\n                    resolvedArgs,\r\n                ),\r\n            }),\r\n        )\r\n    }\r\n    const staticCall = async function (...args) {\r\n        const result = await staticCallResult(...args)\r\n        if (result.length === 1) {\r\n            return result[0]\r\n        }\r\n        return result\r\n    }\r\n    const send = async function (...args) {\r\n        const runner = contract.runner\r\n        assert(\r\n            canSend(runner),\r\n            \"contract runner does not support sending transactions\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"sendTransaction\",\r\n            },\r\n        )\r\n        const tx = await runner.sendTransaction(\r\n            await populateTransaction(...args),\r\n        )\r\n        const provider = getProvider(contract.runner)\r\n        return new ContractTransactionResponse(contract.interface, provider, tx)\r\n    }\r\n    const estimateGas = async function (...args) {\r\n        const runner = getRunner(contract.runner, \"estimateGas\")\r\n        assert(\r\n            canEstimate(runner),\r\n            \"contract runner does not support gas estimation\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"estimateGas\",\r\n            },\r\n        )\r\n        return await runner.estimateGas(await populateTransaction(...args))\r\n    }\r\n    const staticCallResult = async function (...args) {\r\n        const runner = getRunner(contract.runner, \"call\")\r\n        assert(\r\n            canCall(runner),\r\n            \"contract runner does not support calling\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"call\",\r\n            },\r\n        )\r\n        const tx = await populateTransaction(...args)\r\n        let result = \"0x\"\r\n        try {\r\n            result = await runner.call(tx)\r\n        } catch (error) {\r\n            if (isCallException(error) && error.data) {\r\n                throw contract.interface.makeError(error.data, tx)\r\n            }\r\n            throw error\r\n        }\r\n        const fragment = getFragment(...args)\r\n        return contract.interface.decodeFunctionResult(fragment, result)\r\n    }\r\n    const method = async (...args) => {\r\n        const fragment = getFragment(...args)\r\n        if (fragment.constant) {\r\n            return await staticCall(...args)\r\n        }\r\n        return await send(...args)\r\n    }\r\n    defineProperties(method, {\r\n        name: contract.interface.getFunctionName(key),\r\n        _contract: contract,\r\n        _key: key,\r\n        getFragment: getFragment,\r\n        estimateGas: estimateGas,\r\n        populateTransaction: populateTransaction,\r\n        send: send,\r\n        staticCall: staticCall,\r\n        staticCallResult: staticCallResult,\r\n    })\r\n    Object.defineProperty(method, \"fragment\", {\r\n        configurable: false,\r\n        enumerable: true,\r\n        get: () => {\r\n            const fragment = contract.interface.getFunction(key)\r\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\r\n                operation: \"fragment\",\r\n                info: {\r\n                    key: key,\r\n                },\r\n            })\r\n            return fragment\r\n        },\r\n    })\r\n    return method\r\n}\r\nfunction buildWrappedEvent(contract, key) {\r\n    const getFragment = function (...args) {\r\n        const fragment = contract.interface.getEvent(key, args)\r\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"fragment\",\r\n            info: {\r\n                key: key,\r\n                args: args,\r\n            },\r\n        })\r\n        return fragment\r\n    }\r\n    const method = function (...args) {\r\n        return new PreparedTopicFilter(contract, getFragment(...args), args)\r\n    }\r\n    defineProperties(method, {\r\n        name: contract.interface.getEventName(key),\r\n        _contract: contract,\r\n        _key: key,\r\n        getFragment: getFragment,\r\n    })\r\n    Object.defineProperty(method, \"fragment\", {\r\n        configurable: false,\r\n        enumerable: true,\r\n        get: () => {\r\n            const fragment = contract.interface.getEvent(key)\r\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\r\n                operation: \"fragment\",\r\n                info: {\r\n                    key: key,\r\n                },\r\n            })\r\n            return fragment\r\n        },\r\n    })\r\n    return method\r\n}\r\nconst internal = Symbol.for(\"_ethersInternal_contract\")\r\nconst internalValues = new WeakMap()\r\nfunction setInternal(contract, values) {\r\n    internalValues.set(contract[internal], values)\r\n}\r\nfunction getInternal(contract) {\r\n    return internalValues.get(contract[internal])\r\n}\r\nfunction isDeferred(value) {\r\n    return (\r\n        value &&\r\n        typeof value === \"object\" &&\r\n        \"getTopicFilter\" in value &&\r\n        typeof value.getTopicFilter === \"function\" &&\r\n        value.fragment\r\n    )\r\n}\r\nasync function getSubInfo(contract, event) {\r\n    let topics\r\n    let fragment = null\r\n    if (Array.isArray(event)) {\r\n        const topicHashify = function (name) {\r\n            if (isHexString(name, 32)) {\r\n                return name\r\n            }\r\n            const fragment = contract.interface.getEvent(name)\r\n            assertArgument(fragment, \"unknown fragment\", \"name\", name)\r\n            return fragment.topicHash\r\n        }\r\n        topics = event.map((e) => {\r\n            if (e == null) {\r\n                return null\r\n            }\r\n            if (Array.isArray(e)) {\r\n                return e.map(topicHashify)\r\n            }\r\n            return topicHashify(e)\r\n        })\r\n    } else if (event === \"*\") {\r\n        topics = [null]\r\n    } else if (typeof event === \"string\") {\r\n        if (isHexString(event, 32)) {\r\n            topics = [event]\r\n        } else {\r\n            fragment = contract.interface.getEvent(event)\r\n            assertArgument(fragment, \"unknown fragment\", \"event\", event)\r\n            topics = [fragment.topicHash]\r\n        }\r\n    } else if (isDeferred(event)) {\r\n        topics = await event.getTopicFilter()\r\n    } else if (\"fragment\" in event) {\r\n        fragment = event.fragment\r\n        topics = [fragment.topicHash]\r\n    } else {\r\n        assertArgument(false, \"unknown event name\", \"event\", event)\r\n    }\r\n    topics = topics.map((t) => {\r\n        if (t == null) {\r\n            return null\r\n        }\r\n        if (Array.isArray(t)) {\r\n            const items = Array.from(\r\n                new Set(t.map((t) => t.toLowerCase())).values(),\r\n            )\r\n            if (items.length === 1) {\r\n                return items[0]\r\n            }\r\n            items.sort()\r\n            return items\r\n        }\r\n        return t.toLowerCase()\r\n    })\r\n    const tag = topics\r\n        .map((t) => {\r\n            if (t == null) {\r\n                return \"null\"\r\n            }\r\n            if (Array.isArray(t)) {\r\n                return t.join(\"|\")\r\n            }\r\n            return t\r\n        })\r\n        .join(\"&\")\r\n    return {\r\n        fragment: fragment,\r\n        tag: tag,\r\n        topics: topics,\r\n    }\r\n}\r\nasync function hasSub(contract, event) {\r\n    const { subs } = getInternal(contract)\r\n    return subs.get((await getSubInfo(contract, event)).tag) || null\r\n}\r\nasync function getSub(contract, operation, event) {\r\n    const provider = getProvider(contract.runner)\r\n    assert(\r\n        provider,\r\n        \"contract runner does not support subscribing\",\r\n        \"UNSUPPORTED_OPERATION\",\r\n        {\r\n            operation: operation,\r\n        },\r\n    )\r\n    const { fragment, tag, topics } = await getSubInfo(contract, event)\r\n    const { addr, subs } = getInternal(contract)\r\n    let sub = subs.get(tag)\r\n    if (!sub) {\r\n        const address = addr ? addr : contract\r\n        const filter = {\r\n            address: address,\r\n            topics: topics,\r\n        }\r\n        const listener = (log) => {\r\n            let foundFragment = fragment\r\n            if (foundFragment == null) {\r\n                try {\r\n                    foundFragment = contract.interface.getEvent(log.topics[0])\r\n                } catch (error) {}\r\n            }\r\n            if (foundFragment) {\r\n                const _foundFragment = foundFragment\r\n                const args = fragment\r\n                    ? contract.interface.decodeEventLog(\r\n                          fragment,\r\n                          log.data,\r\n                          log.topics,\r\n                      )\r\n                    : []\r\n                emit(contract, event, args, (listener) => {\r\n                    return new ContractEventPayload(\r\n                        contract,\r\n                        listener,\r\n                        event,\r\n                        _foundFragment,\r\n                        log,\r\n                    )\r\n                })\r\n            } else {\r\n                emit(contract, event, [], (listener) => {\r\n                    return new ContractUnknownEventPayload(\r\n                        contract,\r\n                        listener,\r\n                        event,\r\n                        log,\r\n                    )\r\n                })\r\n            }\r\n        }\r\n        let starting = []\r\n        const start = () => {\r\n            if (starting.length) {\r\n                return\r\n            }\r\n            starting.push(provider.on(filter, listener))\r\n        }\r\n        const stop = async () => {\r\n            if (starting.length == 0) {\r\n                return\r\n            }\r\n            let started = starting\r\n            starting = []\r\n            await Promise.all(started)\r\n            provider.off(filter, listener)\r\n        }\r\n        sub = {\r\n            tag: tag,\r\n            listeners: [],\r\n            start: start,\r\n            stop: stop,\r\n        }\r\n        subs.set(tag, sub)\r\n    }\r\n    return sub\r\n}\r\nlet lastEmit = Promise.resolve()\r\nasync function _emit(contract, event, args, payloadFunc) {\r\n    await lastEmit\r\n    const sub = await hasSub(contract, event)\r\n    if (!sub) {\r\n        return false\r\n    }\r\n    const count = sub.listeners.length\r\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\r\n        const passArgs = Array.from(args)\r\n        if (payloadFunc) {\r\n            passArgs.push(payloadFunc(once ? null : listener))\r\n        }\r\n        try {\r\n            listener.call(contract, ...passArgs)\r\n        } catch (error) {}\r\n        return !once\r\n    })\r\n    if (sub.listeners.length === 0) {\r\n        sub.stop()\r\n        getInternal(contract).subs.delete(sub.tag)\r\n    }\r\n    return count > 0\r\n}\r\nasync function emit(contract, event, args, payloadFunc) {\r\n    try {\r\n        await lastEmit\r\n    } catch (error) {}\r\n    const resultPromise = _emit(contract, event, args, payloadFunc)\r\n    lastEmit = resultPromise\r\n    return await resultPromise\r\n}\r\nconst passProperties = [\"then\"]\r\nclass BaseContract {\r\n    target\r\n    interface\r\n    runner\r\n    filters;\r\n    [internal]\r\n    fallback\r\n    constructor(target, abi, runner, _deployTx) {\r\n        assertArgument(\r\n            typeof target === \"string\" || isAddressable(target),\r\n            \"invalid value for Contract target\",\r\n            \"target\",\r\n            target,\r\n        )\r\n        if (runner == null) {\r\n            runner = null\r\n        }\r\n        const iface = Interface.from(abi)\r\n        defineProperties(this, {\r\n            target: target,\r\n            runner: runner,\r\n            interface: iface,\r\n        })\r\n        Object.defineProperty(this, internal, {\r\n            value: {},\r\n        })\r\n        let addrPromise\r\n        let addr = null\r\n        let deployTx = null\r\n        if (_deployTx) {\r\n            const provider = getProvider(runner)\r\n            deployTx = new ContractTransactionResponse(\r\n                this.interface,\r\n                provider,\r\n                _deployTx,\r\n            )\r\n        }\r\n        let subs = new Map()\r\n        if (typeof target === \"string\") {\r\n            if (isHexString(target)) {\r\n                addr = target\r\n                addrPromise = Promise.resolve(target)\r\n            } else {\r\n                const resolver = getRunner(runner, \"resolveName\")\r\n                if (!canResolve(resolver)) {\r\n                    throw makeError(\r\n                        \"contract runner does not support name resolution\",\r\n                        \"UNSUPPORTED_OPERATION\",\r\n                        {\r\n                            operation: \"resolveName\",\r\n                        },\r\n                    )\r\n                }\r\n                addrPromise = resolver.resolveName(target).then((addr) => {\r\n                    if (addr == null) {\r\n                        throw makeError(\r\n                            \"an ENS name used for a contract target must be correctly configured\",\r\n                            \"UNCONFIGURED_NAME\",\r\n                            {\r\n                                value: target,\r\n                            },\r\n                        )\r\n                    }\r\n                    getInternal(this).addr = addr\r\n                    return addr\r\n                })\r\n            }\r\n        } else {\r\n            addrPromise = target.getAddress().then((addr) => {\r\n                if (addr == null) {\r\n                    throw new Error(\"TODO\")\r\n                }\r\n                getInternal(this).addr = addr\r\n                return addr\r\n            })\r\n        }\r\n        setInternal(this, {\r\n            addrPromise: addrPromise,\r\n            addr: addr,\r\n            deployTx: deployTx,\r\n            subs: subs,\r\n        })\r\n        const filters = new Proxy(\r\n            {},\r\n            {\r\n                get: (target, prop, receiver) => {\r\n                    if (\r\n                        typeof prop === \"symbol\" ||\r\n                        passProperties.indexOf(prop) >= 0\r\n                    ) {\r\n                        return Reflect.get(target, prop, receiver)\r\n                    }\r\n                    try {\r\n                        return this.getEvent(prop)\r\n                    } catch (error) {\r\n                        if (\r\n                            !isError(error, \"INVALID_ARGUMENT\") ||\r\n                            error.argument !== \"key\"\r\n                        ) {\r\n                            throw error\r\n                        }\r\n                    }\r\n                    return undefined\r\n                },\r\n                has: (target, prop) => {\r\n                    if (passProperties.indexOf(prop) >= 0) {\r\n                        return Reflect.has(target, prop)\r\n                    }\r\n                    return (\r\n                        Reflect.has(target, prop) ||\r\n                        this.interface.hasEvent(String(prop))\r\n                    )\r\n                },\r\n            },\r\n        )\r\n        defineProperties(this, {\r\n            filters: filters,\r\n        })\r\n        defineProperties(this, {\r\n            fallback:\r\n                iface.receive || iface.fallback\r\n                    ? buildWrappedFallback(this)\r\n                    : null,\r\n        })\r\n        return new Proxy(this, {\r\n            get: (target, prop, receiver) => {\r\n                if (\r\n                    typeof prop === \"symbol\" ||\r\n                    prop in target ||\r\n                    passProperties.indexOf(prop) >= 0\r\n                ) {\r\n                    return Reflect.get(target, prop, receiver)\r\n                }\r\n                try {\r\n                    return target.getFunction(prop)\r\n                } catch (error) {\r\n                    if (\r\n                        !isError(error, \"INVALID_ARGUMENT\") ||\r\n                        error.argument !== \"key\"\r\n                    ) {\r\n                        throw error\r\n                    }\r\n                }\r\n                return undefined\r\n            },\r\n            has: (target, prop) => {\r\n                if (\r\n                    typeof prop === \"symbol\" ||\r\n                    prop in target ||\r\n                    passProperties.indexOf(prop) >= 0\r\n                ) {\r\n                    return Reflect.has(target, prop)\r\n                }\r\n                return target.interface.hasFunction(prop)\r\n            },\r\n        })\r\n    }\r\n    connect(runner) {\r\n        return new BaseContract(this.target, this.interface, runner)\r\n    }\r\n    attach(target) {\r\n        return new BaseContract(target, this.interface, this.runner)\r\n    }\r\n    async getAddress() {\r\n        return await getInternal(this).addrPromise\r\n    }\r\n    async getDeployedCode() {\r\n        const provider = getProvider(this.runner)\r\n        assert(\r\n            provider,\r\n            \"runner does not support .provider\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"getDeployedCode\",\r\n            },\r\n        )\r\n        const code = await provider.getCode(await this.getAddress())\r\n        if (code === \"0x\") {\r\n            return null\r\n        }\r\n        return code\r\n    }\r\n    async waitForDeployment() {\r\n        const deployTx = this.deploymentTransaction()\r\n        if (deployTx) {\r\n            await deployTx.wait()\r\n            return this\r\n        }\r\n        const code = await this.getDeployedCode()\r\n        if (code != null) {\r\n            return this\r\n        }\r\n        const provider = getProvider(this.runner)\r\n        assert(\r\n            provider != null,\r\n            \"contract runner does not support .provider\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"waitForDeployment\",\r\n            },\r\n        )\r\n        return new Promise((resolve, reject) => {\r\n            const checkCode = async () => {\r\n                try {\r\n                    const code = await this.getDeployedCode()\r\n                    if (code != null) {\r\n                        return resolve(this)\r\n                    }\r\n                    provider.once(\"block\", checkCode)\r\n                } catch (error) {\r\n                    reject(error)\r\n                }\r\n            }\r\n            checkCode()\r\n        })\r\n    }\r\n    deploymentTransaction() {\r\n        return getInternal(this).deployTx\r\n    }\r\n    getFunction(key) {\r\n        if (typeof key !== \"string\") {\r\n            key = key.format()\r\n        }\r\n        const func = buildWrappedMethod(this, key)\r\n        return func\r\n    }\r\n    getEvent(key) {\r\n        if (typeof key !== \"string\") {\r\n            key = key.format()\r\n        }\r\n        return buildWrappedEvent(this, key)\r\n    }\r\n    async queryTransaction(hash) {\r\n        throw new Error(\"@TODO\")\r\n    }\r\n    async queryFilter(event, fromBlock, toBlock) {\r\n        if (fromBlock == null) {\r\n            fromBlock = 0\r\n        }\r\n        if (toBlock == null) {\r\n            toBlock = \"latest\"\r\n        }\r\n        const { addr, addrPromise } = getInternal(this)\r\n        const address = addr ? addr : await addrPromise\r\n        const { fragment, topics } = await getSubInfo(this, event)\r\n        const filter = {\r\n            address: address,\r\n            topics: topics,\r\n            fromBlock: fromBlock,\r\n            toBlock: toBlock,\r\n        }\r\n        const provider = getProvider(this.runner)\r\n        assert(\r\n            provider,\r\n            \"contract runner does not have a provider\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"queryFilter\",\r\n            },\r\n        )\r\n        return (await provider.getLogs(filter)).map((log) => {\r\n            let foundFragment = fragment\r\n            if (foundFragment == null) {\r\n                try {\r\n                    foundFragment = this.interface.getEvent(log.topics[0])\r\n                } catch (error) {}\r\n            }\r\n            if (foundFragment) {\r\n                try {\r\n                    return new EventLog(log, this.interface, foundFragment)\r\n                } catch (error) {\r\n                    return new UndecodedEventLog(log, error)\r\n                }\r\n            }\r\n            return new Log(log, provider)\r\n        })\r\n    }\r\n    async on(event, listener) {\r\n        const sub = await getSub(this, \"on\", event)\r\n        sub.listeners.push({\r\n            listener: listener,\r\n            once: false,\r\n        })\r\n        sub.start()\r\n        return this\r\n    }\r\n    async once(event, listener) {\r\n        const sub = await getSub(this, \"once\", event)\r\n        sub.listeners.push({\r\n            listener: listener,\r\n            once: true,\r\n        })\r\n        sub.start()\r\n        return this\r\n    }\r\n    async emit(event, ...args) {\r\n        return await emit(this, event, args, null)\r\n    }\r\n    async listenerCount(event) {\r\n        if (event) {\r\n            const sub = await hasSub(this, event)\r\n            if (!sub) {\r\n                return 0\r\n            }\r\n            return sub.listeners.length\r\n        }\r\n        const { subs } = getInternal(this)\r\n        let total = 0\r\n        for (const { listeners } of subs.values()) {\r\n            total += listeners.length\r\n        }\r\n        return total\r\n    }\r\n    async listeners(event) {\r\n        if (event) {\r\n            const sub = await hasSub(this, event)\r\n            if (!sub) {\r\n                return []\r\n            }\r\n            return sub.listeners.map(({ listener }) => listener)\r\n        }\r\n        const { subs } = getInternal(this)\r\n        let result = []\r\n        for (const { listeners } of subs.values()) {\r\n            result = result.concat(listeners.map(({ listener }) => listener))\r\n        }\r\n        return result\r\n    }\r\n    async off(event, listener) {\r\n        const sub = await hasSub(this, event)\r\n        if (!sub) {\r\n            return this\r\n        }\r\n        if (listener) {\r\n            const index = sub.listeners\r\n                .map(({ listener }) => listener)\r\n                .indexOf(listener)\r\n            if (index >= 0) {\r\n                sub.listeners.splice(index, 1)\r\n            }\r\n        }\r\n        if (listener == null || sub.listeners.length === 0) {\r\n            sub.stop()\r\n            getInternal(this).subs.delete(sub.tag)\r\n        }\r\n        return this\r\n    }\r\n    async removeAllListeners(event) {\r\n        if (event) {\r\n            const sub = await hasSub(this, event)\r\n            if (!sub) {\r\n                return this\r\n            }\r\n            sub.stop()\r\n            getInternal(this).subs.delete(sub.tag)\r\n        } else {\r\n            const { subs } = getInternal(this)\r\n            for (const { tag, stop } of subs.values()) {\r\n                stop()\r\n                subs.delete(tag)\r\n            }\r\n        }\r\n        return this\r\n    }\r\n    async addListener(event, listener) {\r\n        return await this.on(event, listener)\r\n    }\r\n    async removeListener(event, listener) {\r\n        return await this.off(event, listener)\r\n    }\r\n    static buildClass(abi) {\r\n        class CustomContract extends BaseContract {\r\n            constructor(address, runner = null) {\r\n                super(address, abi, runner)\r\n            }\r\n        }\r\n        return CustomContract\r\n    }\r\n    static from(target, abi, runner) {\r\n        if (runner == null) {\r\n            runner = null\r\n        }\r\n        const contract = new this(target, abi, runner)\r\n        return contract\r\n    }\r\n}\r\nfunction _ContractBase() {\r\n    return BaseContract\r\n}\r\nclass Contract extends _ContractBase() {}\r\nclass ContractFactory {\r\n    interface\r\n    bytecode\r\n    runner\r\n    constructor(abi, bytecode, runner) {\r\n        const iface = Interface.from(abi)\r\n        if (bytecode instanceof Uint8Array) {\r\n            bytecode = hexlify(getBytes(bytecode))\r\n        } else {\r\n            if (typeof bytecode === \"object\") {\r\n                bytecode = bytecode.object\r\n            }\r\n            if (!bytecode.startsWith(\"0x\")) {\r\n                bytecode = \"0x\" + bytecode\r\n            }\r\n            bytecode = hexlify(getBytes(bytecode))\r\n        }\r\n        defineProperties(this, {\r\n            bytecode: bytecode,\r\n            interface: iface,\r\n            runner: runner || null,\r\n        })\r\n    }\r\n    attach(target) {\r\n        return new BaseContract(target, this.interface, this.runner)\r\n    }\r\n    async getDeployTransaction(...args) {\r\n        let overrides = {}\r\n        const fragment = this.interface.deploy\r\n        if (fragment.inputs.length + 1 === args.length) {\r\n            overrides = await copyOverrides(args.pop())\r\n        }\r\n        if (fragment.inputs.length !== args.length) {\r\n            throw new Error(\"incorrect number of arguments to constructor\")\r\n        }\r\n        const resolvedArgs = await resolveArgs(\r\n            this.runner,\r\n            fragment.inputs,\r\n            args,\r\n        )\r\n        const data = concat([\r\n            this.bytecode,\r\n            this.interface.encodeDeploy(resolvedArgs),\r\n        ])\r\n        return Object.assign({}, overrides, {\r\n            data: data,\r\n        })\r\n    }\r\n    async deploy(...args) {\r\n        const tx = await this.getDeployTransaction(...args)\r\n        assert(\r\n            this.runner && typeof this.runner.sendTransaction === \"function\",\r\n            \"factory runner does not support sending transactions\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"sendTransaction\",\r\n            },\r\n        )\r\n        const sentTx = await this.runner.sendTransaction(tx)\r\n        const address = getCreateAddress(sentTx)\r\n        return new BaseContract(address, this.interface, this.runner, sentTx)\r\n    }\r\n    connect(runner) {\r\n        return new ContractFactory(this.interface, this.bytecode, runner)\r\n    }\r\n    static fromSolidity(output, runner) {\r\n        assertArgument(output != null, \"bad compiler output\", \"output\", output)\r\n        if (typeof output === \"string\") {\r\n            output = JSON.parse(output)\r\n        }\r\n        const abi = output.abi\r\n        let bytecode = \"\"\r\n        if (output.bytecode) {\r\n            bytecode = output.bytecode\r\n        } else if (output.evm && output.evm.bytecode) {\r\n            bytecode = output.evm.bytecode\r\n        }\r\n        return new this(abi, bytecode, runner)\r\n    }\r\n}\r\nfunction getIpfsLink(link) {\r\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\r\n        link = link.substring(12)\r\n    } else if (link.match(/^ipfs:\\/\\//i)) {\r\n        link = link.substring(7)\r\n    } else {\r\n        assertArgument(false, \"unsupported IPFS format\", \"link\", link)\r\n    }\r\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`\r\n}\r\nclass MulticoinProviderPlugin {\r\n    name\r\n    constructor(name) {\r\n        defineProperties(this, {\r\n            name: name,\r\n        })\r\n    }\r\n    connect(proivder) {\r\n        return this\r\n    }\r\n    supportsCoinType(coinType) {\r\n        return false\r\n    }\r\n    async encodeAddress(coinType, address) {\r\n        throw new Error(\"unsupported coin\")\r\n    }\r\n    async decodeAddress(coinType, data) {\r\n        throw new Error(\"unsupported coin\")\r\n    }\r\n}\r\nconst matcherIpfs = new RegExp(\"^(ipfs)://(.*)$\", \"i\")\r\nconst matchers = [\r\n    new RegExp(\"^(https)://(.*)$\", \"i\"),\r\n    new RegExp(\"^(data):(.*)$\", \"i\"),\r\n    matcherIpfs,\r\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\r\n]\r\nclass EnsResolver {\r\n    provider\r\n    address\r\n    name\r\n    #supports2544\r\n    #resolver\r\n    constructor(provider, address, name) {\r\n        defineProperties(this, {\r\n            provider: provider,\r\n            address: address,\r\n            name: name,\r\n        })\r\n        this.#supports2544 = null\r\n        this.#resolver = new Contract(\r\n            address,\r\n            [\r\n                \"function supportsInterface(bytes4) view returns (bool)\",\r\n                \"function resolve(bytes, bytes) view returns (bytes)\",\r\n                \"function addr(bytes32) view returns (address)\",\r\n                \"function addr(bytes32, uint) view returns (bytes)\",\r\n                \"function text(bytes32, string) view returns (string)\",\r\n                \"function contenthash(bytes32) view returns (bytes)\",\r\n            ],\r\n            provider,\r\n        )\r\n    }\r\n    async supportsWildcard() {\r\n        if (this.#supports2544 == null) {\r\n            this.#supports2544 = (async () => {\r\n                try {\r\n                    return await this.#resolver.supportsInterface(\"0x9061b923\")\r\n                } catch (error) {\r\n                    if (isError(error, \"CALL_EXCEPTION\")) {\r\n                        return false\r\n                    }\r\n                    this.#supports2544 = null\r\n                    throw error\r\n                }\r\n            })()\r\n        }\r\n        return await this.#supports2544\r\n    }\r\n    async #fetch(funcName, params) {\r\n        params = (params || []).slice()\r\n        const iface = this.#resolver.interface\r\n        params.unshift(namehash(this.name))\r\n        let fragment = null\r\n        if (await this.supportsWildcard()) {\r\n            fragment = iface.getFunction(funcName)\r\n            assert(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\r\n                info: {\r\n                    funcName: funcName,\r\n                },\r\n            })\r\n            params = [\r\n                dnsEncode(this.name),\r\n                iface.encodeFunctionData(fragment, params),\r\n            ]\r\n            funcName = \"resolve(bytes,bytes)\"\r\n        }\r\n        params.push({\r\n            enableCcipRead: true,\r\n        })\r\n        try {\r\n            const result = await this.#resolver[funcName](...params)\r\n            if (fragment) {\r\n                return iface.decodeFunctionResult(fragment, result)[0]\r\n            }\r\n            return result\r\n        } catch (error) {\r\n            if (!isError(error, \"CALL_EXCEPTION\")) {\r\n                throw error\r\n            }\r\n        }\r\n        return null\r\n    }\r\n    async getAddress(coinType) {\r\n        if (coinType == null) {\r\n            coinType = 60\r\n        }\r\n        if (coinType === 60) {\r\n            try {\r\n                const result = await this.#fetch(\"addr(bytes32)\")\r\n                if (result == null || result === ZeroAddress) {\r\n                    return null\r\n                }\r\n                return result\r\n            } catch (error) {\r\n                if (isError(error, \"CALL_EXCEPTION\")) {\r\n                    return null\r\n                }\r\n                throw error\r\n            }\r\n        }\r\n        if (coinType >= 0 && coinType < 2147483648) {\r\n            let ethCoinType = coinType + 2147483648\r\n            const data = await this.#fetch(\"addr(bytes32,uint)\", [ethCoinType])\r\n            if (isHexString(data, 20)) {\r\n                return getAddress(data)\r\n            }\r\n        }\r\n        let coinPlugin = null\r\n        for (const plugin of this.provider.plugins) {\r\n            if (!(plugin instanceof MulticoinProviderPlugin)) {\r\n                continue\r\n            }\r\n            if (plugin.supportsCoinType(coinType)) {\r\n                coinPlugin = plugin\r\n                break\r\n            }\r\n        }\r\n        if (coinPlugin == null) {\r\n            return null\r\n        }\r\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [coinType])\r\n        if (data == null || data === \"0x\") {\r\n            return null\r\n        }\r\n        const address = await coinPlugin.decodeAddress(coinType, data)\r\n        if (address != null) {\r\n            return address\r\n        }\r\n        assert(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\r\n            operation: `getAddress(${coinType})`,\r\n            info: {\r\n                coinType: coinType,\r\n                data: data,\r\n            },\r\n        })\r\n    }\r\n    async getText(key) {\r\n        const data = await this.#fetch(\"text(bytes32,string)\", [key])\r\n        if (data == null || data === \"0x\") {\r\n            return null\r\n        }\r\n        return data\r\n    }\r\n    async getContentHash() {\r\n        const data = await this.#fetch(\"contenthash(bytes32)\")\r\n        if (data == null || data === \"0x\") {\r\n            return null\r\n        }\r\n        const ipfs = data.match(\r\n            /^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/,\r\n        )\r\n        if (ipfs) {\r\n            const scheme = ipfs[1] === \"e3010170\" ? \"ipfs\" : \"ipns\"\r\n            const length = parseInt(ipfs[4], 16)\r\n            if (ipfs[5].length === length * 2) {\r\n                return `${scheme}:/\\/${encodeBase58(\"0x\" + ipfs[2])}`\r\n            }\r\n        }\r\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/)\r\n        if (swarm && swarm[1].length === 64) {\r\n            return `bzz:/\\/${swarm[1]}`\r\n        }\r\n        assert(\r\n            false,\r\n            `invalid or unsupported content hash data`,\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"getContentHash()\",\r\n                info: {\r\n                    data: data,\r\n                },\r\n            },\r\n        )\r\n    }\r\n    async getAvatar() {\r\n        const avatar = await this._getAvatar()\r\n        return avatar.url\r\n    }\r\n    async _getAvatar() {\r\n        const linkage = [\r\n            {\r\n                type: \"name\",\r\n                value: this.name,\r\n            },\r\n        ]\r\n        try {\r\n            const avatar = await this.getText(\"avatar\")\r\n            if (avatar == null) {\r\n                linkage.push({\r\n                    type: \"!avatar\",\r\n                    value: \"\",\r\n                })\r\n                return {\r\n                    url: null,\r\n                    linkage: linkage,\r\n                }\r\n            }\r\n            linkage.push({\r\n                type: \"avatar\",\r\n                value: avatar,\r\n            })\r\n            for (let i = 0; i < matchers.length; i++) {\r\n                const match = avatar.match(matchers[i])\r\n                if (match == null) {\r\n                    continue\r\n                }\r\n                const scheme = match[1].toLowerCase()\r\n                switch (scheme) {\r\n                    case \"https\":\r\n                    case \"data\":\r\n                        linkage.push({\r\n                            type: \"url\",\r\n                            value: avatar,\r\n                        })\r\n                        return {\r\n                            linkage: linkage,\r\n                            url: avatar,\r\n                        }\r\n                    case \"ipfs\": {\r\n                        const url = getIpfsLink(avatar)\r\n                        linkage.push({\r\n                            type: \"ipfs\",\r\n                            value: avatar,\r\n                        })\r\n                        linkage.push({\r\n                            type: \"url\",\r\n                            value: url,\r\n                        })\r\n                        return {\r\n                            linkage: linkage,\r\n                            url: url,\r\n                        }\r\n                    }\r\n                    case \"erc721\":\r\n                    case \"erc1155\": {\r\n                        const selector =\r\n                            scheme === \"erc721\"\r\n                                ? \"tokenURI(uint256)\"\r\n                                : \"uri(uint256)\"\r\n                        linkage.push({\r\n                            type: scheme,\r\n                            value: avatar,\r\n                        })\r\n                        const owner = await this.getAddress()\r\n                        if (owner == null) {\r\n                            linkage.push({\r\n                                type: \"!owner\",\r\n                                value: \"\",\r\n                            })\r\n                            return {\r\n                                url: null,\r\n                                linkage: linkage,\r\n                            }\r\n                        }\r\n                        const comps = (match[2] || \"\").split(\"/\")\r\n                        if (comps.length !== 2) {\r\n                            linkage.push({\r\n                                type: `!${scheme}caip`,\r\n                                value: match[2] || \"\",\r\n                            })\r\n                            return {\r\n                                url: null,\r\n                                linkage: linkage,\r\n                            }\r\n                        }\r\n                        const tokenId = comps[1]\r\n                        const contract = new Contract(\r\n                            comps[0],\r\n                            [\r\n                                \"function tokenURI(uint) view returns (string)\",\r\n                                \"function ownerOf(uint) view returns (address)\",\r\n                                \"function uri(uint) view returns (string)\",\r\n                                \"function balanceOf(address, uint256) view returns (uint)\",\r\n                            ],\r\n                            this.provider,\r\n                        )\r\n                        if (scheme === \"erc721\") {\r\n                            const tokenOwner = await contract.ownerOf(tokenId)\r\n                            if (owner !== tokenOwner) {\r\n                                linkage.push({\r\n                                    type: \"!owner\",\r\n                                    value: tokenOwner,\r\n                                })\r\n                                return {\r\n                                    url: null,\r\n                                    linkage: linkage,\r\n                                }\r\n                            }\r\n                            linkage.push({\r\n                                type: \"owner\",\r\n                                value: tokenOwner,\r\n                            })\r\n                        } else if (scheme === \"erc1155\") {\r\n                            const balance = await contract.balanceOf(\r\n                                owner,\r\n                                tokenId,\r\n                            )\r\n                            if (!balance) {\r\n                                linkage.push({\r\n                                    type: \"!balance\",\r\n                                    value: \"0\",\r\n                                })\r\n                                return {\r\n                                    url: null,\r\n                                    linkage: linkage,\r\n                                }\r\n                            }\r\n                            linkage.push({\r\n                                type: \"balance\",\r\n                                value: balance.toString(),\r\n                            })\r\n                        }\r\n                        let metadataUrl = await contract[selector](tokenId)\r\n                        if (metadataUrl == null || metadataUrl === \"0x\") {\r\n                            linkage.push({\r\n                                type: \"!metadata-url\",\r\n                                value: \"\",\r\n                            })\r\n                            return {\r\n                                url: null,\r\n                                linkage: linkage,\r\n                            }\r\n                        }\r\n                        linkage.push({\r\n                            type: \"metadata-url-base\",\r\n                            value: metadataUrl,\r\n                        })\r\n                        if (scheme === \"erc1155\") {\r\n                            metadataUrl = metadataUrl.replace(\r\n                                \"{id}\",\r\n                                toBeHex(tokenId, 32).substring(2),\r\n                            )\r\n                            linkage.push({\r\n                                type: \"metadata-url-expanded\",\r\n                                value: metadataUrl,\r\n                            })\r\n                        }\r\n                        if (metadataUrl.match(/^ipfs:/i)) {\r\n                            metadataUrl = getIpfsLink(metadataUrl)\r\n                        }\r\n                        linkage.push({\r\n                            type: \"metadata-url\",\r\n                            value: metadataUrl,\r\n                        })\r\n                        let metadata = {}\r\n                        const response = await new FetchRequest(\r\n                            metadataUrl,\r\n                        ).send()\r\n                        response.assertOk()\r\n                        try {\r\n                            metadata = response.bodyJson\r\n                        } catch (error) {\r\n                            try {\r\n                                linkage.push({\r\n                                    type: \"!metadata\",\r\n                                    value: response.bodyText,\r\n                                })\r\n                            } catch (error) {\r\n                                const bytes = response.body\r\n                                if (bytes) {\r\n                                    linkage.push({\r\n                                        type: \"!metadata\",\r\n                                        value: hexlify(bytes),\r\n                                    })\r\n                                }\r\n                                return {\r\n                                    url: null,\r\n                                    linkage: linkage,\r\n                                }\r\n                            }\r\n                            return {\r\n                                url: null,\r\n                                linkage: linkage,\r\n                            }\r\n                        }\r\n                        if (!metadata) {\r\n                            linkage.push({\r\n                                type: \"!metadata\",\r\n                                value: \"\",\r\n                            })\r\n                            return {\r\n                                url: null,\r\n                                linkage: linkage,\r\n                            }\r\n                        }\r\n                        linkage.push({\r\n                            type: \"metadata\",\r\n                            value: JSON.stringify(metadata),\r\n                        })\r\n                        let imageUrl = metadata.image\r\n                        if (typeof imageUrl !== \"string\") {\r\n                            linkage.push({\r\n                                type: \"!imageUrl\",\r\n                                value: \"\",\r\n                            })\r\n                            return {\r\n                                url: null,\r\n                                linkage: linkage,\r\n                            }\r\n                        }\r\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\r\n                        } else {\r\n                            const ipfs = imageUrl.match(matcherIpfs)\r\n                            if (ipfs == null) {\r\n                                linkage.push({\r\n                                    type: \"!imageUrl-ipfs\",\r\n                                    value: imageUrl,\r\n                                })\r\n                                return {\r\n                                    url: null,\r\n                                    linkage: linkage,\r\n                                }\r\n                            }\r\n                            linkage.push({\r\n                                type: \"imageUrl-ipfs\",\r\n                                value: imageUrl,\r\n                            })\r\n                            imageUrl = getIpfsLink(imageUrl)\r\n                        }\r\n                        linkage.push({\r\n                            type: \"url\",\r\n                            value: imageUrl,\r\n                        })\r\n                        return {\r\n                            linkage: linkage,\r\n                            url: imageUrl,\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } catch (error) {}\r\n        return {\r\n            linkage: linkage,\r\n            url: null,\r\n        }\r\n    }\r\n    static async getEnsAddress(provider) {\r\n        const network = await provider.getNetwork()\r\n        const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\")\r\n        assert(\r\n            ensPlugin,\r\n            \"network does not support ENS\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"getEnsAddress\",\r\n                info: {\r\n                    network: network,\r\n                },\r\n            },\r\n        )\r\n        return ensPlugin.address\r\n    }\r\n    static async #getResolver(provider, name) {\r\n        const ensAddr = await EnsResolver.getEnsAddress(provider)\r\n        try {\r\n            const contract = new Contract(\r\n                ensAddr,\r\n                [\"function resolver(bytes32) view returns (address)\"],\r\n                provider,\r\n            )\r\n            const addr = await contract.resolver(namehash(name), {\r\n                enableCcipRead: true,\r\n            })\r\n            if (addr === ZeroAddress) {\r\n                return null\r\n            }\r\n            return addr\r\n        } catch (error) {\r\n            throw error\r\n        }\r\n        return null\r\n    }\r\n    static async fromName(provider, name) {\r\n        let currentName = name\r\n        while (true) {\r\n            if (currentName === \"\" || currentName === \".\") {\r\n                return null\r\n            }\r\n            if (name !== \"eth\" && currentName === \"eth\") {\r\n                return null\r\n            }\r\n            const addr = await EnsResolver.#getResolver(provider, currentName)\r\n            if (addr != null) {\r\n                const resolver = new EnsResolver(provider, addr, name)\r\n                if (\r\n                    currentName !== name &&\r\n                    !(await resolver.supportsWildcard())\r\n                ) {\r\n                    return null\r\n                }\r\n                return resolver\r\n            }\r\n            currentName = currentName.split(\".\").slice(1).join(\".\")\r\n        }\r\n    }\r\n}\r\nconst BN_0 = BigInt(0)\r\nfunction allowNull(format, nullValue) {\r\n    return function (value) {\r\n        if (value == null) {\r\n            return nullValue\r\n        }\r\n        return format(value)\r\n    }\r\n}\r\nfunction arrayOf(format) {\r\n    return (array) => {\r\n        if (!Array.isArray(array)) {\r\n            throw new Error(\"not an array\")\r\n        }\r\n        return array.map((i) => format(i))\r\n    }\r\n}\r\nfunction object(format, altNames) {\r\n    return (value) => {\r\n        const result = {}\r\n        for (const key in format) {\r\n            let srcKey = key\r\n            if (altNames && key in altNames && !(srcKey in value)) {\r\n                for (const altKey of altNames[key]) {\r\n                    if (altKey in value) {\r\n                        srcKey = altKey\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n            try {\r\n                const nv = format[key](value[srcKey])\r\n                if (nv !== undefined) {\r\n                    result[key] = nv\r\n                }\r\n            } catch (error) {\r\n                const message =\r\n                    error instanceof Error ? error.message : \"not-an-error\"\r\n                assert(\r\n                    false,\r\n                    `invalid value for value.${key} (${message})`,\r\n                    \"BAD_DATA\",\r\n                    {\r\n                        value: value,\r\n                    },\r\n                )\r\n            }\r\n        }\r\n        return result\r\n    }\r\n}\r\nfunction formatBoolean(value) {\r\n    switch (value) {\r\n        case true:\r\n        case \"true\":\r\n            return true\r\n        case false:\r\n        case \"false\":\r\n            return false\r\n    }\r\n    assertArgument(\r\n        false,\r\n        `invalid boolean; ${JSON.stringify(value)}`,\r\n        \"value\",\r\n        value,\r\n    )\r\n}\r\nfunction formatData(value) {\r\n    assertArgument(isHexString(value, true), \"invalid data\", \"value\", value)\r\n    return value\r\n}\r\nfunction formatHash(value) {\r\n    assertArgument(isHexString(value, 32), \"invalid hash\", \"value\", value)\r\n    return value\r\n}\r\nconst _formatLog = object(\r\n    {\r\n        address: getAddress,\r\n        blockHash: formatHash,\r\n        blockNumber: getNumber,\r\n        data: formatData,\r\n        index: getNumber,\r\n        removed: allowNull(formatBoolean, false),\r\n        topics: arrayOf(formatHash),\r\n        transactionHash: formatHash,\r\n        transactionIndex: getNumber,\r\n    },\r\n    {\r\n        index: [\"logIndex\"],\r\n    },\r\n)\r\nfunction formatLog(value) {\r\n    return _formatLog(value)\r\n}\r\nconst _formatBlock = object({\r\n    hash: allowNull(formatHash),\r\n    parentHash: formatHash,\r\n    number: getNumber,\r\n    timestamp: getNumber,\r\n    nonce: allowNull(formatData),\r\n    difficulty: getBigInt,\r\n    gasLimit: getBigInt,\r\n    gasUsed: getBigInt,\r\n    miner: allowNull(getAddress),\r\n    extraData: formatData,\r\n    baseFeePerGas: allowNull(getBigInt),\r\n})\r\nfunction formatBlock(value) {\r\n    const result = _formatBlock(value)\r\n    result.transactions = value.transactions.map((tx) => {\r\n        if (typeof tx === \"string\") {\r\n            return tx\r\n        }\r\n        return formatTransactionResponse(tx)\r\n    })\r\n    return result\r\n}\r\nconst _formatReceiptLog = object(\r\n    {\r\n        transactionIndex: getNumber,\r\n        blockNumber: getNumber,\r\n        transactionHash: formatHash,\r\n        address: getAddress,\r\n        topics: arrayOf(formatHash),\r\n        data: formatData,\r\n        index: getNumber,\r\n        blockHash: formatHash,\r\n    },\r\n    {\r\n        index: [\"logIndex\"],\r\n    },\r\n)\r\nfunction formatReceiptLog(value) {\r\n    return _formatReceiptLog(value)\r\n}\r\nconst _formatTransactionReceipt = object(\r\n    {\r\n        to: allowNull(getAddress, null),\r\n        from: allowNull(getAddress, null),\r\n        contractAddress: allowNull(getAddress, null),\r\n        index: getNumber,\r\n        root: allowNull(hexlify),\r\n        gasUsed: getBigInt,\r\n        logsBloom: allowNull(formatData),\r\n        blockHash: formatHash,\r\n        hash: formatHash,\r\n        logs: arrayOf(formatReceiptLog),\r\n        blockNumber: getNumber,\r\n        cumulativeGasUsed: getBigInt,\r\n        effectiveGasPrice: allowNull(getBigInt),\r\n        status: allowNull(getNumber),\r\n        type: allowNull(getNumber, 0),\r\n    },\r\n    {\r\n        effectiveGasPrice: [\"gasPrice\"],\r\n        hash: [\"transactionHash\"],\r\n        index: [\"transactionIndex\"],\r\n    },\r\n)\r\nfunction formatTransactionReceipt(value) {\r\n    return _formatTransactionReceipt(value)\r\n}\r\nfunction formatTransactionResponse(value) {\r\n    if (value.to && getBigInt(value.to) === BN_0) {\r\n        value.to = \"0x0000000000000000000000000000000000000000\"\r\n    }\r\n    const result = object(\r\n        {\r\n            hash: formatHash,\r\n            type: (value) => {\r\n                if (value === \"0x\" || value == null) {\r\n                    return 0\r\n                }\r\n                return getNumber(value)\r\n            },\r\n            accessList: allowNull(accessListify, null),\r\n            blockHash: allowNull(formatHash, null),\r\n            blockNumber: allowNull(getNumber, null),\r\n            transactionIndex: allowNull(getNumber, null),\r\n            from: getAddress,\r\n            gasPrice: allowNull(getBigInt),\r\n            maxPriorityFeePerGas: allowNull(getBigInt),\r\n            maxFeePerGas: allowNull(getBigInt),\r\n            gasLimit: getBigInt,\r\n            to: allowNull(getAddress, null),\r\n            value: getBigInt,\r\n            nonce: getNumber,\r\n            data: formatData,\r\n            creates: allowNull(getAddress, null),\r\n            chainId: allowNull(getBigInt, null),\r\n        },\r\n        {\r\n            data: [\"input\"],\r\n            gasLimit: [\"gas\"],\r\n        },\r\n    )(value)\r\n    if (result.to == null && result.creates == null) {\r\n        result.creates = getCreateAddress(result)\r\n    }\r\n    if ((value.type === 1 || value.type === 2) && value.accessList == null) {\r\n        result.accessList = []\r\n    }\r\n    if (value.signature) {\r\n        result.signature = Signature.from(value.signature)\r\n    } else {\r\n        result.signature = Signature.from(value)\r\n    }\r\n    if (result.chainId == null) {\r\n        const chainId = result.signature.legacyChainId\r\n        if (chainId != null) {\r\n            result.chainId = chainId\r\n        }\r\n    }\r\n    if (result.blockHash && getBigInt(result.blockHash) === BN_0) {\r\n        result.blockHash = null\r\n    }\r\n    return result\r\n}\r\nconst EnsAddress = \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\"\r\nclass NetworkPlugin {\r\n    name\r\n    constructor(name) {\r\n        defineProperties(this, {\r\n            name: name,\r\n        })\r\n    }\r\n    clone() {\r\n        return new NetworkPlugin(this.name)\r\n    }\r\n}\r\nclass GasCostPlugin extends NetworkPlugin {\r\n    effectiveBlock\r\n    txBase\r\n    txCreate\r\n    txDataZero\r\n    txDataNonzero\r\n    txAccessListStorageKey\r\n    txAccessListAddress\r\n    constructor(effectiveBlock, costs) {\r\n        if (effectiveBlock == null) {\r\n            effectiveBlock = 0\r\n        }\r\n        super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`)\r\n        const props = {\r\n            effectiveBlock: effectiveBlock,\r\n        }\r\n        function set(name, nullish) {\r\n            let value = (costs || {})[name]\r\n            if (value == null) {\r\n                value = nullish\r\n            }\r\n            assertArgument(\r\n                typeof value === \"number\",\r\n                `invalud value for ${name}`,\r\n                \"costs\",\r\n                costs,\r\n            )\r\n            props[name] = value\r\n        }\r\n        set(\"txBase\", 21e3)\r\n        set(\"txCreate\", 32e3)\r\n        set(\"txDataZero\", 4)\r\n        set(\"txDataNonzero\", 16)\r\n        set(\"txAccessListStorageKey\", 1900)\r\n        set(\"txAccessListAddress\", 2400)\r\n        defineProperties(this, props)\r\n    }\r\n    clone() {\r\n        return new GasCostPlugin(this.effectiveBlock, this)\r\n    }\r\n}\r\nclass EnsPlugin extends NetworkPlugin {\r\n    address\r\n    targetNetwork\r\n    constructor(address, targetNetwork) {\r\n        super(\"org.ethers.plugins.network.Ens\")\r\n        defineProperties(this, {\r\n            address: address || EnsAddress,\r\n            targetNetwork: targetNetwork == null ? 1 : targetNetwork,\r\n        })\r\n    }\r\n    clone() {\r\n        return new EnsPlugin(this.address, this.targetNetwork)\r\n    }\r\n}\r\nclass FeeDataNetworkPlugin extends NetworkPlugin {\r\n    #feeDataFunc\r\n    get feeDataFunc() {\r\n        return this.#feeDataFunc\r\n    }\r\n    constructor(feeDataFunc) {\r\n        super(\"org.ethers.plugins.network.FeeData\")\r\n        this.#feeDataFunc = feeDataFunc\r\n    }\r\n    async getFeeData(provider) {\r\n        return await this.#feeDataFunc(provider)\r\n    }\r\n    clone() {\r\n        return new FeeDataNetworkPlugin(this.#feeDataFunc)\r\n    }\r\n}\r\nclass FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\r\n    #url\r\n    #processFunc\r\n    get url() {\r\n        return this.#url\r\n    }\r\n    get processFunc() {\r\n        return this.#processFunc\r\n    }\r\n    constructor(url, processFunc) {\r\n        super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\")\r\n        this.#url = url\r\n        this.#processFunc = processFunc\r\n    }\r\n    clone() {\r\n        return this\r\n    }\r\n}\r\nconst Networks = new Map()\r\nclass Network {\r\n    #name\r\n    #chainId\r\n    #plugins\r\n    constructor(name, chainId) {\r\n        this.#name = name\r\n        this.#chainId = getBigInt(chainId)\r\n        this.#plugins = new Map()\r\n    }\r\n    toJSON() {\r\n        return {\r\n            name: this.name,\r\n            chainId: String(this.chainId),\r\n        }\r\n    }\r\n    get name() {\r\n        return this.#name\r\n    }\r\n    set name(value) {\r\n        this.#name = value\r\n    }\r\n    get chainId() {\r\n        return this.#chainId\r\n    }\r\n    set chainId(value) {\r\n        this.#chainId = getBigInt(value, \"chainId\")\r\n    }\r\n    matches(other) {\r\n        if (other == null) {\r\n            return false\r\n        }\r\n        if (typeof other === \"string\") {\r\n            try {\r\n                return this.chainId === getBigInt(other)\r\n            } catch (error) {}\r\n            return this.name === other\r\n        }\r\n        if (typeof other === \"number\" || typeof other === \"bigint\") {\r\n            try {\r\n                return this.chainId === getBigInt(other)\r\n            } catch (error) {}\r\n            return false\r\n        }\r\n        if (typeof other === \"object\") {\r\n            if (other.chainId != null) {\r\n                try {\r\n                    return this.chainId === getBigInt(other.chainId)\r\n                } catch (error) {}\r\n                return false\r\n            }\r\n            if (other.name != null) {\r\n                return this.name === other.name\r\n            }\r\n            return false\r\n        }\r\n        return false\r\n    }\r\n    get plugins() {\r\n        return Array.from(this.#plugins.values())\r\n    }\r\n    attachPlugin(plugin) {\r\n        if (this.#plugins.get(plugin.name)) {\r\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `)\r\n        }\r\n        this.#plugins.set(plugin.name, plugin.clone())\r\n        return this\r\n    }\r\n    getPlugin(name) {\r\n        return this.#plugins.get(name) || null\r\n    }\r\n    getPlugins(basename) {\r\n        return this.plugins.filter((p) => p.name.split(\"#\")[0] === basename)\r\n    }\r\n    clone() {\r\n        const clone = new Network(this.name, this.chainId)\r\n        this.plugins.forEach((plugin) => {\r\n            clone.attachPlugin(plugin.clone())\r\n        })\r\n        return clone\r\n    }\r\n    computeIntrinsicGas(tx) {\r\n        const costs =\r\n            this.getPlugin(\"org.ethers.plugins.network.GasCost\") ||\r\n            new GasCostPlugin()\r\n        let gas = costs.txBase\r\n        if (tx.to == null) {\r\n            gas += costs.txCreate\r\n        }\r\n        if (tx.data) {\r\n            for (let i = 2; i < tx.data.length; i += 2) {\r\n                if (tx.data.substring(i, i + 2) === \"00\") {\r\n                    gas += costs.txDataZero\r\n                } else {\r\n                    gas += costs.txDataNonzero\r\n                }\r\n            }\r\n        }\r\n        if (tx.accessList) {\r\n            const accessList = accessListify(tx.accessList)\r\n            for (const addr in accessList) {\r\n                gas +=\r\n                    costs.txAccessListAddress +\r\n                    costs.txAccessListStorageKey *\r\n                        accessList[addr].storageKeys.length\r\n            }\r\n        }\r\n        return gas\r\n    }\r\n    static from(network) {\r\n        injectCommonNetworks()\r\n        if (network == null) {\r\n            return Network.from(\"mainnet\")\r\n        }\r\n        if (typeof network === \"number\") {\r\n            network = BigInt(network)\r\n        }\r\n        if (typeof network === \"string\" || typeof network === \"bigint\") {\r\n            const networkFunc = Networks.get(network)\r\n            if (networkFunc) {\r\n                return networkFunc()\r\n            }\r\n            if (typeof network === \"bigint\") {\r\n                return new Network(\"unknown\", network)\r\n            }\r\n            assertArgument(false, \"unknown network\", \"network\", network)\r\n        }\r\n        if (typeof network.clone === \"function\") {\r\n            const clone = network.clone()\r\n            return clone\r\n        }\r\n        if (typeof network === \"object\") {\r\n            assertArgument(\r\n                typeof network.name === \"string\" &&\r\n                    typeof network.chainId === \"number\",\r\n                \"invalid network object name or chainId\",\r\n                \"network\",\r\n                network,\r\n            )\r\n            const custom = new Network(network.name, network.chainId)\r\n            if (network.ensAddress || network.ensNetwork != null) {\r\n                custom.attachPlugin(\r\n                    new EnsPlugin(network.ensAddress, network.ensNetwork),\r\n                )\r\n            }\r\n            return custom\r\n        }\r\n        assertArgument(false, \"invalid network\", \"network\", network)\r\n    }\r\n    static register(nameOrChainId, networkFunc) {\r\n        if (typeof nameOrChainId === \"number\") {\r\n            nameOrChainId = BigInt(nameOrChainId)\r\n        }\r\n        const existing = Networks.get(nameOrChainId)\r\n        if (existing) {\r\n            assertArgument(\r\n                false,\r\n                `conflicting network for ${JSON.stringify(existing.name)}`,\r\n                \"nameOrChainId\",\r\n                nameOrChainId,\r\n            )\r\n        }\r\n        Networks.set(nameOrChainId, networkFunc)\r\n    }\r\n}\r\nfunction parseUnits(_value, decimals) {\r\n    const value = String(_value)\r\n    if (!value.match(/^[0-9.]+$/)) {\r\n        throw new Error(`invalid gwei value: ${_value}`)\r\n    }\r\n    const comps = value.split(\".\")\r\n    if (comps.length === 1) {\r\n        comps.push(\"\")\r\n    }\r\n    if (comps.length !== 2) {\r\n        throw new Error(`invalid gwei value: ${_value}`)\r\n    }\r\n    while (comps[1].length < decimals) {\r\n        comps[1] += \"0\"\r\n    }\r\n    if (comps[1].length > 9) {\r\n        let frac = BigInt(comps[1].substring(0, 9))\r\n        if (!comps[1].substring(9).match(/^0+$/)) {\r\n            frac++\r\n        }\r\n        comps[1] = frac.toString()\r\n    }\r\n    return BigInt(comps[0] + comps[1])\r\n}\r\nfunction getGasStationPlugin(url) {\r\n    return new FetchUrlFeeDataNetworkPlugin(\r\n        url,\r\n        async (fetchFeeData, provider, request) => {\r\n            request.setHeader(\"User-Agent\", \"ethers\")\r\n            let response\r\n            try {\r\n                const [_response, _feeData] = await Promise.all([\r\n                    request.send(),\r\n                    fetchFeeData(),\r\n                ])\r\n                response = _response\r\n                const payload = response.bodyJson.standard\r\n                const feeData = {\r\n                    gasPrice: _feeData.gasPrice,\r\n                    maxFeePerGas: parseUnits(payload.maxFee, 9),\r\n                    maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9),\r\n                }\r\n                return feeData\r\n            } catch (error) {\r\n                assert(\r\n                    false,\r\n                    `error encountered with polygon gas station (${JSON.stringify(\r\n                        request.url,\r\n                    )})`,\r\n                    \"SERVER_ERROR\",\r\n                    {\r\n                        request: request,\r\n                        response: response,\r\n                        error: error,\r\n                    },\r\n                )\r\n            }\r\n        },\r\n    )\r\n}\r\nlet injected = false\r\nfunction injectCommonNetworks() {\r\n    if (injected) {\r\n        return\r\n    }\r\n    injected = true\r\n    function registerEth(name, chainId, options) {\r\n        const func = function () {\r\n            const network = new Network(name, chainId)\r\n            if (options.ensNetwork != null) {\r\n                network.attachPlugin(new EnsPlugin(null, options.ensNetwork))\r\n            }\r\n            network.attachPlugin(new GasCostPlugin())\r\n            ;(options.plugins || []).forEach((plugin) => {\r\n                network.attachPlugin(plugin)\r\n            })\r\n            return network\r\n        }\r\n        Network.register(name, func)\r\n        Network.register(chainId, func)\r\n        if (options.altNames) {\r\n            options.altNames.forEach((name) => {\r\n                Network.register(name, func)\r\n            })\r\n        }\r\n    }\r\n    registerEth(\"mainnet\", 1, {\r\n        ensNetwork: 1,\r\n        altNames: [\"homestead\"],\r\n    })\r\n    registerEth(\"ropsten\", 3, {\r\n        ensNetwork: 3,\r\n    })\r\n    registerEth(\"rinkeby\", 4, {\r\n        ensNetwork: 4,\r\n    })\r\n    registerEth(\"goerli\", 5, {\r\n        ensNetwork: 5,\r\n    })\r\n    registerEth(\"kovan\", 42, {\r\n        ensNetwork: 42,\r\n    })\r\n    registerEth(\"sepolia\", 11155111, {\r\n        ensNetwork: 11155111,\r\n    })\r\n    registerEth(\"classic\", 61, {})\r\n    registerEth(\"classicKotti\", 6, {})\r\n    registerEth(\"arbitrum\", 42161, {\r\n        ensNetwork: 1,\r\n    })\r\n    registerEth(\"arbitrum-goerli\", 421613, {})\r\n    registerEth(\"base\", 8453, {\r\n        ensNetwork: 1,\r\n    })\r\n    registerEth(\"base-goerli\", 84531, {})\r\n    registerEth(\"base-sepolia\", 84532, {})\r\n    registerEth(\"bnb\", 56, {\r\n        ensNetwork: 1,\r\n    })\r\n    registerEth(\"bnbt\", 97, {})\r\n    registerEth(\"linea\", 59144, {\r\n        ensNetwork: 1,\r\n    })\r\n    registerEth(\"linea-goerli\", 59140, {})\r\n    registerEth(\"matic\", 137, {\r\n        ensNetwork: 1,\r\n        plugins: [\r\n            getGasStationPlugin(\"https://gasstation.polygon.technology/v2\"),\r\n        ],\r\n    })\r\n    registerEth(\"matic-mumbai\", 80001, {\r\n        altNames: [\"maticMumbai\", \"maticmum\"],\r\n        plugins: [\r\n            getGasStationPlugin(\r\n                \"https://gasstation-testnet.polygon.technology/v2\",\r\n            ),\r\n        ],\r\n    })\r\n    registerEth(\"optimism\", 10, {\r\n        ensNetwork: 1,\r\n        plugins: [],\r\n    })\r\n    registerEth(\"optimism-goerli\", 420, {})\r\n    registerEth(\"xdai\", 100, {\r\n        ensNetwork: 1,\r\n    })\r\n}\r\nfunction copy$2(obj) {\r\n    return JSON.parse(JSON.stringify(obj))\r\n}\r\nclass PollingBlockSubscriber {\r\n    #provider\r\n    #poller\r\n    #interval\r\n    #blockNumber\r\n    constructor(provider) {\r\n        this.#provider = provider\r\n        this.#poller = null\r\n        this.#interval = 4e3\r\n        this.#blockNumber = -2\r\n    }\r\n    get pollingInterval() {\r\n        return this.#interval\r\n    }\r\n    set pollingInterval(value) {\r\n        this.#interval = value\r\n    }\r\n    async #poll() {\r\n        try {\r\n            const blockNumber = await this.#provider.getBlockNumber()\r\n            if (this.#blockNumber === -2) {\r\n                this.#blockNumber = blockNumber\r\n                return\r\n            }\r\n            if (blockNumber !== this.#blockNumber) {\r\n                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\r\n                    if (this.#poller == null) {\r\n                        return\r\n                    }\r\n                    await this.#provider.emit(\"block\", b)\r\n                }\r\n                this.#blockNumber = blockNumber\r\n            }\r\n        } catch (error) {}\r\n        if (this.#poller == null) {\r\n            return\r\n        }\r\n        this.#poller = this.#provider._setTimeout(\r\n            this.#poll.bind(this),\r\n            this.#interval,\r\n        )\r\n    }\r\n    start() {\r\n        if (this.#poller) {\r\n            return\r\n        }\r\n        this.#poller = this.#provider._setTimeout(\r\n            this.#poll.bind(this),\r\n            this.#interval,\r\n        )\r\n        this.#poll()\r\n    }\r\n    stop() {\r\n        if (!this.#poller) {\r\n            return\r\n        }\r\n        this.#provider._clearTimeout(this.#poller)\r\n        this.#poller = null\r\n    }\r\n    pause(dropWhilePaused) {\r\n        this.stop()\r\n        if (dropWhilePaused) {\r\n            this.#blockNumber = -2\r\n        }\r\n    }\r\n    resume() {\r\n        this.start()\r\n    }\r\n}\r\nclass OnBlockSubscriber {\r\n    #provider\r\n    #poll\r\n    #running\r\n    constructor(provider) {\r\n        this.#provider = provider\r\n        this.#running = false\r\n        this.#poll = (blockNumber) => {\r\n            this._poll(blockNumber, this.#provider)\r\n        }\r\n    }\r\n    async _poll(blockNumber, provider) {\r\n        throw new Error(\"sub-classes must override this\")\r\n    }\r\n    start() {\r\n        if (this.#running) {\r\n            return\r\n        }\r\n        this.#running = true\r\n        this.#poll(-2)\r\n        this.#provider.on(\"block\", this.#poll)\r\n    }\r\n    stop() {\r\n        if (!this.#running) {\r\n            return\r\n        }\r\n        this.#running = false\r\n        this.#provider.off(\"block\", this.#poll)\r\n    }\r\n    pause(dropWhilePaused) {\r\n        this.stop()\r\n    }\r\n    resume() {\r\n        this.start()\r\n    }\r\n}\r\nclass PollingBlockTagSubscriber extends OnBlockSubscriber {\r\n    #tag\r\n    #lastBlock\r\n    constructor(provider, tag) {\r\n        super(provider)\r\n        this.#tag = tag\r\n        this.#lastBlock = -2\r\n    }\r\n    pause(dropWhilePaused) {\r\n        if (dropWhilePaused) {\r\n            this.#lastBlock = -2\r\n        }\r\n        super.pause(dropWhilePaused)\r\n    }\r\n    async _poll(blockNumber, provider) {\r\n        const block = await provider.getBlock(this.#tag)\r\n        if (block == null) {\r\n            return\r\n        }\r\n        if (this.#lastBlock === -2) {\r\n            this.#lastBlock = block.number\r\n        } else if (block.number > this.#lastBlock) {\r\n            provider.emit(this.#tag, block.number)\r\n            this.#lastBlock = block.number\r\n        }\r\n    }\r\n}\r\nclass PollingOrphanSubscriber extends OnBlockSubscriber {\r\n    #filter\r\n    constructor(provider, filter) {\r\n        super(provider)\r\n        this.#filter = copy$2(filter)\r\n    }\r\n    async _poll(blockNumber, provider) {\r\n        throw new Error(\"@TODO\")\r\n    }\r\n}\r\nclass PollingTransactionSubscriber extends OnBlockSubscriber {\r\n    #hash\r\n    constructor(provider, hash) {\r\n        super(provider)\r\n        this.#hash = hash\r\n    }\r\n    async _poll(blockNumber, provider) {\r\n        const tx = await provider.getTransactionReceipt(this.#hash)\r\n        if (tx) {\r\n            provider.emit(this.#hash, tx)\r\n        }\r\n    }\r\n}\r\nclass PollingEventSubscriber {\r\n    #provider\r\n    #filter\r\n    #poller\r\n    #running\r\n    #blockNumber\r\n    constructor(provider, filter) {\r\n        this.#provider = provider\r\n        this.#filter = copy$2(filter)\r\n        this.#poller = this.#poll.bind(this)\r\n        this.#running = false\r\n        this.#blockNumber = -2\r\n    }\r\n    async #poll(blockNumber) {\r\n        if (this.#blockNumber === -2) {\r\n            return\r\n        }\r\n        const filter = copy$2(this.#filter)\r\n        filter.fromBlock = this.#blockNumber + 1\r\n        filter.toBlock = blockNumber\r\n        const logs = await this.#provider.getLogs(filter)\r\n        if (logs.length === 0) {\r\n            if (this.#blockNumber < blockNumber - 60) {\r\n                this.#blockNumber = blockNumber - 60\r\n            }\r\n            return\r\n        }\r\n        for (const log of logs) {\r\n            this.#provider.emit(this.#filter, log)\r\n            this.#blockNumber = log.blockNumber\r\n        }\r\n    }\r\n    start() {\r\n        if (this.#running) {\r\n            return\r\n        }\r\n        this.#running = true\r\n        if (this.#blockNumber === -2) {\r\n            this.#provider.getBlockNumber().then((blockNumber) => {\r\n                this.#blockNumber = blockNumber\r\n            })\r\n        }\r\n        this.#provider.on(\"block\", this.#poller)\r\n    }\r\n    stop() {\r\n        if (!this.#running) {\r\n            return\r\n        }\r\n        this.#running = false\r\n        this.#provider.off(\"block\", this.#poller)\r\n    }\r\n    pause(dropWhilePaused) {\r\n        this.stop()\r\n        if (dropWhilePaused) {\r\n            this.#blockNumber = -2\r\n        }\r\n    }\r\n    resume() {\r\n        this.start()\r\n    }\r\n}\r\nconst BN_2$1 = BigInt(2)\r\nconst MAX_CCIP_REDIRECTS = 10\r\nfunction isPromise$1(value) {\r\n    return value && typeof value.then === \"function\"\r\n}\r\nfunction getTag(prefix, value) {\r\n    return (\r\n        prefix +\r\n        \":\" +\r\n        JSON.stringify(value, (k, v) => {\r\n            if (v == null) {\r\n                return \"null\"\r\n            }\r\n            if (typeof v === \"bigint\") {\r\n                return `bigint:${v.toString()}`\r\n            }\r\n            if (typeof v === \"string\") {\r\n                return v.toLowerCase()\r\n            }\r\n            if (typeof v === \"object\" && !Array.isArray(v)) {\r\n                const keys = Object.keys(v)\r\n                keys.sort()\r\n                return keys.reduce((accum, key) => {\r\n                    accum[key] = v[key]\r\n                    return accum\r\n                }, {})\r\n            }\r\n            return v\r\n        })\r\n    )\r\n}\r\nclass UnmanagedSubscriber {\r\n    name\r\n    constructor(name) {\r\n        defineProperties(this, {\r\n            name: name,\r\n        })\r\n    }\r\n    start() {}\r\n    stop() {}\r\n    pause(dropWhilePaused) {}\r\n    resume() {}\r\n}\r\nfunction copy$1(value) {\r\n    return JSON.parse(JSON.stringify(value))\r\n}\r\nfunction concisify(items) {\r\n    items = Array.from(new Set(items).values())\r\n    items.sort()\r\n    return items\r\n}\r\nasync function getSubscription(_event, provider) {\r\n    if (_event == null) {\r\n        throw new Error(\"invalid event\")\r\n    }\r\n    if (Array.isArray(_event)) {\r\n        _event = {\r\n            topics: _event,\r\n        }\r\n    }\r\n    if (typeof _event === \"string\") {\r\n        switch (_event) {\r\n            case \"block\":\r\n            case \"debug\":\r\n            case \"error\":\r\n            case \"finalized\":\r\n            case \"network\":\r\n            case \"pending\":\r\n            case \"safe\": {\r\n                return {\r\n                    type: _event,\r\n                    tag: _event,\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (isHexString(_event, 32)) {\r\n        const hash = _event.toLowerCase()\r\n        return {\r\n            type: \"transaction\",\r\n            tag: getTag(\"tx\", {\r\n                hash: hash,\r\n            }),\r\n            hash: hash,\r\n        }\r\n    }\r\n    if (_event.orphan) {\r\n        const event = _event\r\n        return {\r\n            type: \"orphan\",\r\n            tag: getTag(\"orphan\", event),\r\n            filter: copy$1(event),\r\n        }\r\n    }\r\n    if (_event.address || _event.topics) {\r\n        const event = _event\r\n        const filter = {\r\n            topics: (event.topics || []).map((t) => {\r\n                if (t == null) {\r\n                    return null\r\n                }\r\n                if (Array.isArray(t)) {\r\n                    return concisify(t.map((t) => t.toLowerCase()))\r\n                }\r\n                return t.toLowerCase()\r\n            }),\r\n        }\r\n        if (event.address) {\r\n            const addresses = []\r\n            const promises = []\r\n            const addAddress = (addr) => {\r\n                if (isHexString(addr)) {\r\n                    addresses.push(addr)\r\n                } else {\r\n                    promises.push(\r\n                        (async () => {\r\n                            addresses.push(await resolveAddress(addr, provider))\r\n                        })(),\r\n                    )\r\n                }\r\n            }\r\n            if (Array.isArray(event.address)) {\r\n                event.address.forEach(addAddress)\r\n            } else {\r\n                addAddress(event.address)\r\n            }\r\n            if (promises.length) {\r\n                await Promise.all(promises)\r\n            }\r\n            filter.address = concisify(addresses.map((a) => a.toLowerCase()))\r\n        }\r\n        return {\r\n            filter: filter,\r\n            tag: getTag(\"event\", filter),\r\n            type: \"event\",\r\n        }\r\n    }\r\n    assertArgument(false, \"unknown ProviderEvent\", \"event\", _event)\r\n}\r\nfunction getTime$1() {\r\n    return new Date().getTime()\r\n}\r\nconst defaultOptions$1 = {\r\n    cacheTimeout: 250,\r\n    pollingInterval: 4e3,\r\n}\r\nclass AbstractProvider {\r\n    #subs\r\n    #plugins\r\n    #pausedState\r\n    #destroyed\r\n    #networkPromise\r\n    #anyNetwork\r\n    #performCache\r\n    #lastBlockNumber\r\n    #nextTimer\r\n    #timers\r\n    #disableCcipRead\r\n    #options\r\n    constructor(_network, options) {\r\n        this.#options = Object.assign({}, defaultOptions$1, options || {})\r\n        if (_network === \"any\") {\r\n            this.#anyNetwork = true\r\n            this.#networkPromise = null\r\n        } else if (_network) {\r\n            const network = Network.from(_network)\r\n            this.#anyNetwork = false\r\n            this.#networkPromise = Promise.resolve(network)\r\n            setTimeout(() => {\r\n                this.emit(\"network\", network, null)\r\n            }, 0)\r\n        } else {\r\n            this.#anyNetwork = false\r\n            this.#networkPromise = null\r\n        }\r\n        this.#lastBlockNumber = -1\r\n        this.#performCache = new Map()\r\n        this.#subs = new Map()\r\n        this.#plugins = new Map()\r\n        this.#pausedState = null\r\n        this.#destroyed = false\r\n        this.#nextTimer = 1\r\n        this.#timers = new Map()\r\n        this.#disableCcipRead = false\r\n    }\r\n    get pollingInterval() {\r\n        return this.#options.pollingInterval\r\n    }\r\n    get provider() {\r\n        return this\r\n    }\r\n    get plugins() {\r\n        return Array.from(this.#plugins.values())\r\n    }\r\n    attachPlugin(plugin) {\r\n        if (this.#plugins.get(plugin.name)) {\r\n            throw new Error(`cannot replace existing plugin: ${plugin.name} `)\r\n        }\r\n        this.#plugins.set(plugin.name, plugin.connect(this))\r\n        return this\r\n    }\r\n    getPlugin(name) {\r\n        return this.#plugins.get(name) || null\r\n    }\r\n    get disableCcipRead() {\r\n        return this.#disableCcipRead\r\n    }\r\n    set disableCcipRead(value) {\r\n        this.#disableCcipRead = !!value\r\n    }\r\n    async #perform(req) {\r\n        const timeout = this.#options.cacheTimeout\r\n        if (timeout < 0) {\r\n            return await this._perform(req)\r\n        }\r\n        const tag = getTag(req.method, req)\r\n        let perform = this.#performCache.get(tag)\r\n        if (!perform) {\r\n            perform = this._perform(req)\r\n            this.#performCache.set(tag, perform)\r\n            setTimeout(() => {\r\n                if (this.#performCache.get(tag) === perform) {\r\n                    this.#performCache.delete(tag)\r\n                }\r\n            }, timeout)\r\n        }\r\n        return await perform\r\n    }\r\n    async ccipReadFetch(tx, calldata, urls) {\r\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {\r\n            return null\r\n        }\r\n        const sender = tx.to.toLowerCase()\r\n        const data = calldata.toLowerCase()\r\n        const errorMessages = []\r\n        for (let i = 0; i < urls.length; i++) {\r\n            const url = urls[i]\r\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data)\r\n            const request = new FetchRequest(href)\r\n            if (url.indexOf(\"{data}\") === -1) {\r\n                request.body = {\r\n                    data: data,\r\n                    sender: sender,\r\n                }\r\n            }\r\n            this.emit(\"debug\", {\r\n                action: \"sendCcipReadFetchRequest\",\r\n                request: request,\r\n                index: i,\r\n                urls: urls,\r\n            })\r\n            let errorMessage = \"unknown error\"\r\n            const resp = await request.send()\r\n            try {\r\n                const result = resp.bodyJson\r\n                if (result.data) {\r\n                    this.emit(\"debug\", {\r\n                        action: \"receiveCcipReadFetchResult\",\r\n                        request: request,\r\n                        result: result,\r\n                    })\r\n                    return result.data\r\n                }\r\n                if (result.message) {\r\n                    errorMessage = result.message\r\n                }\r\n                this.emit(\"debug\", {\r\n                    action: \"receiveCcipReadFetchError\",\r\n                    request: request,\r\n                    result: result,\r\n                })\r\n            } catch (error) {}\r\n            assert(\r\n                resp.statusCode < 400 || resp.statusCode >= 500,\r\n                `response not found during CCIP fetch: ${errorMessage}`,\r\n                \"OFFCHAIN_FAULT\",\r\n                {\r\n                    reason: \"404_MISSING_RESOURCE\",\r\n                    transaction: tx,\r\n                    info: {\r\n                        url: url,\r\n                        errorMessage: errorMessage,\r\n                    },\r\n                },\r\n            )\r\n            errorMessages.push(errorMessage)\r\n        }\r\n        assert(\r\n            false,\r\n            `error encountered during CCIP fetch: ${errorMessages\r\n                .map((m) => JSON.stringify(m))\r\n                .join(\", \")}`,\r\n            \"OFFCHAIN_FAULT\",\r\n            {\r\n                reason: \"500_SERVER_ERROR\",\r\n                transaction: tx,\r\n                info: {\r\n                    urls: urls,\r\n                    errorMessages: errorMessages,\r\n                },\r\n            },\r\n        )\r\n    }\r\n    _wrapBlock(value, network) {\r\n        return new Block(formatBlock(value), this)\r\n    }\r\n    _wrapLog(value, network) {\r\n        return new Log(formatLog(value), this)\r\n    }\r\n    _wrapTransactionReceipt(value, network) {\r\n        return new TransactionReceipt(formatTransactionReceipt(value), this)\r\n    }\r\n    _wrapTransactionResponse(tx, network) {\r\n        return new TransactionResponse(formatTransactionResponse(tx), this)\r\n    }\r\n    _detectNetwork() {\r\n        assert(\r\n            false,\r\n            \"sub-classes must implement this\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"_detectNetwork\",\r\n            },\r\n        )\r\n    }\r\n    async _perform(req) {\r\n        assert(\r\n            false,\r\n            `unsupported method: ${req.method}`,\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: req.method,\r\n                info: req,\r\n            },\r\n        )\r\n    }\r\n    async getBlockNumber() {\r\n        const blockNumber = getNumber(\r\n            await this.#perform({\r\n                method: \"getBlockNumber\",\r\n            }),\r\n            \"%response\",\r\n        )\r\n        if (this.#lastBlockNumber >= 0) {\r\n            this.#lastBlockNumber = blockNumber\r\n        }\r\n        return blockNumber\r\n    }\r\n    _getAddress(address) {\r\n        return resolveAddress(address, this)\r\n    }\r\n    _getBlockTag(blockTag) {\r\n        if (blockTag == null) {\r\n            return \"latest\"\r\n        }\r\n        switch (blockTag) {\r\n            case \"earliest\":\r\n                return \"0x0\"\r\n            case \"finalized\":\r\n            case \"latest\":\r\n            case \"pending\":\r\n            case \"safe\":\r\n                return blockTag\r\n        }\r\n        if (isHexString(blockTag)) {\r\n            if (isHexString(blockTag, 32)) {\r\n                return blockTag\r\n            }\r\n            return toQuantity(blockTag)\r\n        }\r\n        if (typeof blockTag === \"bigint\") {\r\n            blockTag = getNumber(blockTag, \"blockTag\")\r\n        }\r\n        if (typeof blockTag === \"number\") {\r\n            if (blockTag >= 0) {\r\n                return toQuantity(blockTag)\r\n            }\r\n            if (this.#lastBlockNumber >= 0) {\r\n                return toQuantity(this.#lastBlockNumber + blockTag)\r\n            }\r\n            return this.getBlockNumber().then((b) => toQuantity(b + blockTag))\r\n        }\r\n        assertArgument(false, \"invalid blockTag\", \"blockTag\", blockTag)\r\n    }\r\n    _getFilter(filter) {\r\n        const topics = (filter.topics || []).map((t) => {\r\n            if (t == null) {\r\n                return null\r\n            }\r\n            if (Array.isArray(t)) {\r\n                return concisify(t.map((t) => t.toLowerCase()))\r\n            }\r\n            return t.toLowerCase()\r\n        })\r\n        const blockHash = \"blockHash\" in filter ? filter.blockHash : undefined\r\n        const resolve = (_address, fromBlock, toBlock) => {\r\n            let address = undefined\r\n            switch (_address.length) {\r\n                case 0:\r\n                    break\r\n                case 1:\r\n                    address = _address[0]\r\n                    break\r\n                default:\r\n                    _address.sort()\r\n                    address = _address\r\n            }\r\n            if (blockHash) {\r\n                if (fromBlock != null || toBlock != null) {\r\n                    throw new Error(\"invalid filter\")\r\n                }\r\n            }\r\n            const filter = {}\r\n            if (address) {\r\n                filter.address = address\r\n            }\r\n            if (topics.length) {\r\n                filter.topics = topics\r\n            }\r\n            if (fromBlock) {\r\n                filter.fromBlock = fromBlock\r\n            }\r\n            if (toBlock) {\r\n                filter.toBlock = toBlock\r\n            }\r\n            if (blockHash) {\r\n                filter.blockHash = blockHash\r\n            }\r\n            return filter\r\n        }\r\n        let address = []\r\n        if (filter.address) {\r\n            if (Array.isArray(filter.address)) {\r\n                for (const addr of filter.address) {\r\n                    address.push(this._getAddress(addr))\r\n                }\r\n            } else {\r\n                address.push(this._getAddress(filter.address))\r\n            }\r\n        }\r\n        let fromBlock = undefined\r\n        if (\"fromBlock\" in filter) {\r\n            fromBlock = this._getBlockTag(filter.fromBlock)\r\n        }\r\n        let toBlock = undefined\r\n        if (\"toBlock\" in filter) {\r\n            toBlock = this._getBlockTag(filter.toBlock)\r\n        }\r\n        if (\r\n            address.filter((a) => typeof a !== \"string\").length ||\r\n            (fromBlock != null && typeof fromBlock !== \"string\") ||\r\n            (toBlock != null && typeof toBlock !== \"string\")\r\n        ) {\r\n            return Promise.all([Promise.all(address), fromBlock, toBlock]).then(\r\n                (result) => {\r\n                    return resolve(result[0], result[1], result[2])\r\n                },\r\n            )\r\n        }\r\n        return resolve(address, fromBlock, toBlock)\r\n    }\r\n    _getTransactionRequest(_request) {\r\n        const request = copyRequest(_request)\r\n        const promises = []\r\n        ;[\"to\", \"from\"].forEach((key) => {\r\n            if (request[key] == null) {\r\n                return\r\n            }\r\n            const addr = resolveAddress(request[key], this)\r\n            if (isPromise$1(addr)) {\r\n                promises.push(\r\n                    (async function () {\r\n                        request[key] = await addr\r\n                    })(),\r\n                )\r\n            } else {\r\n                request[key] = addr\r\n            }\r\n        })\r\n        if (request.blockTag != null) {\r\n            const blockTag = this._getBlockTag(request.blockTag)\r\n            if (isPromise$1(blockTag)) {\r\n                promises.push(\r\n                    (async function () {\r\n                        request.blockTag = await blockTag\r\n                    })(),\r\n                )\r\n            } else {\r\n                request.blockTag = blockTag\r\n            }\r\n        }\r\n        if (promises.length) {\r\n            return (async function () {\r\n                await Promise.all(promises)\r\n                return request\r\n            })()\r\n        }\r\n        return request\r\n    }\r\n    async getNetwork() {\r\n        if (this.#networkPromise == null) {\r\n            const detectNetwork = (async () => {\r\n                try {\r\n                    const network = await this._detectNetwork()\r\n                    this.emit(\"network\", network, null)\r\n                    return network\r\n                } catch (error) {\r\n                    if (this.#networkPromise === detectNetwork) {\r\n                        this.#networkPromise = null\r\n                    }\r\n                    throw error\r\n                }\r\n            })()\r\n            this.#networkPromise = detectNetwork\r\n            return (await detectNetwork).clone()\r\n        }\r\n        const networkPromise = this.#networkPromise\r\n        const [expected, actual] = await Promise.all([\r\n            networkPromise,\r\n            this._detectNetwork(),\r\n        ])\r\n        if (expected.chainId !== actual.chainId) {\r\n            if (this.#anyNetwork) {\r\n                this.emit(\"network\", actual, expected)\r\n                if (this.#networkPromise === networkPromise) {\r\n                    this.#networkPromise = Promise.resolve(actual)\r\n                }\r\n            } else {\r\n                assert(\r\n                    false,\r\n                    `network changed: ${expected.chainId} => ${actual.chainId} `,\r\n                    \"NETWORK_ERROR\",\r\n                    {\r\n                        event: \"changed\",\r\n                    },\r\n                )\r\n            }\r\n        }\r\n        return expected.clone()\r\n    }\r\n    async getFeeData() {\r\n        const network = await this.getNetwork()\r\n        const getFeeDataFunc = async () => {\r\n            const { _block, gasPrice, priorityFee } = await resolveProperties({\r\n                _block: this.#getBlock(\"latest\", false),\r\n                gasPrice: (async () => {\r\n                    try {\r\n                        const value = await this.#perform({\r\n                            method: \"getGasPrice\",\r\n                        })\r\n                        return getBigInt(value, \"%response\")\r\n                    } catch (error) {}\r\n                    return null\r\n                })(),\r\n                priorityFee: (async () => {\r\n                    try {\r\n                        const value = await this.#perform({\r\n                            method: \"getPriorityFee\",\r\n                        })\r\n                        return getBigInt(value, \"%response\")\r\n                    } catch (error) {}\r\n                    return null\r\n                })(),\r\n            })\r\n            let maxFeePerGas = null\r\n            let maxPriorityFeePerGas = null\r\n            const block = this._wrapBlock(_block, network)\r\n            if (block && block.baseFeePerGas) {\r\n                maxPriorityFeePerGas =\r\n                    priorityFee != null ? priorityFee : BigInt(\"1000000000\")\r\n                maxFeePerGas =\r\n                    block.baseFeePerGas * BN_2$1 + maxPriorityFeePerGas\r\n            }\r\n            return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas)\r\n        }\r\n        const plugin = network.getPlugin(\r\n            \"org.ethers.plugins.network.FetchUrlFeeDataPlugin\",\r\n        )\r\n        if (plugin) {\r\n            const req = new FetchRequest(plugin.url)\r\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req)\r\n            return new FeeData(\r\n                feeData.gasPrice,\r\n                feeData.maxFeePerGas,\r\n                feeData.maxPriorityFeePerGas,\r\n            )\r\n        }\r\n        return await getFeeDataFunc()\r\n    }\r\n    async estimateGas(_tx) {\r\n        let tx = this._getTransactionRequest(_tx)\r\n        if (isPromise$1(tx)) {\r\n            tx = await tx\r\n        }\r\n        return getBigInt(\r\n            await this.#perform({\r\n                method: \"estimateGas\",\r\n                transaction: tx,\r\n            }),\r\n            \"%response\",\r\n        )\r\n    }\r\n    async #call(tx, blockTag, attempt) {\r\n        assert(\r\n            attempt < MAX_CCIP_REDIRECTS,\r\n            \"CCIP read exceeded maximum redirections\",\r\n            \"OFFCHAIN_FAULT\",\r\n            {\r\n                reason: \"TOO_MANY_REDIRECTS\",\r\n                transaction: Object.assign({}, tx, {\r\n                    blockTag: blockTag,\r\n                    enableCcipRead: true,\r\n                }),\r\n            },\r\n        )\r\n        const transaction = copyRequest(tx)\r\n        try {\r\n            return hexlify(\r\n                await this._perform({\r\n                    method: \"call\",\r\n                    transaction: transaction,\r\n                    blockTag: blockTag,\r\n                }),\r\n            )\r\n        } catch (error) {\r\n            if (\r\n                !this.disableCcipRead &&\r\n                isCallException(error) &&\r\n                error.data &&\r\n                attempt >= 0 &&\r\n                blockTag === \"latest\" &&\r\n                transaction.to != null &&\r\n                dataSlice(error.data, 0, 4) === \"0x556f1830\"\r\n            ) {\r\n                const data = error.data\r\n                const txSender = await resolveAddress(transaction.to, this)\r\n                let ccipArgs\r\n                try {\r\n                    ccipArgs = parseOffchainLookup(dataSlice(error.data, 4))\r\n                } catch (error) {\r\n                    assert(false, error.message, \"OFFCHAIN_FAULT\", {\r\n                        reason: \"BAD_DATA\",\r\n                        transaction: transaction,\r\n                        info: {\r\n                            data: data,\r\n                        },\r\n                    })\r\n                }\r\n                assert(\r\n                    ccipArgs.sender.toLowerCase() === txSender.toLowerCase(),\r\n                    \"CCIP Read sender mismatch\",\r\n                    \"CALL_EXCEPTION\",\r\n                    {\r\n                        action: \"call\",\r\n                        data: data,\r\n                        reason: \"OffchainLookup\",\r\n                        transaction: transaction,\r\n                        invocation: null,\r\n                        revert: {\r\n                            signature:\r\n                                \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\r\n                            name: \"OffchainLookup\",\r\n                            args: ccipArgs.errorArgs,\r\n                        },\r\n                    },\r\n                )\r\n                const ccipResult = await this.ccipReadFetch(\r\n                    transaction,\r\n                    ccipArgs.calldata,\r\n                    ccipArgs.urls,\r\n                )\r\n                assert(\r\n                    ccipResult != null,\r\n                    \"CCIP Read failed to fetch data\",\r\n                    \"OFFCHAIN_FAULT\",\r\n                    {\r\n                        reason: \"FETCH_FAILED\",\r\n                        transaction: transaction,\r\n                        info: {\r\n                            data: error.data,\r\n                            errorArgs: ccipArgs.errorArgs,\r\n                        },\r\n                    },\r\n                )\r\n                const tx = {\r\n                    to: txSender,\r\n                    data: concat([\r\n                        ccipArgs.selector,\r\n                        encodeBytes([ccipResult, ccipArgs.extraData]),\r\n                    ]),\r\n                }\r\n                this.emit(\"debug\", {\r\n                    action: \"sendCcipReadCall\",\r\n                    transaction: tx,\r\n                })\r\n                try {\r\n                    const result = await this.#call(tx, blockTag, attempt + 1)\r\n                    this.emit(\"debug\", {\r\n                        action: \"receiveCcipReadCallResult\",\r\n                        transaction: Object.assign({}, tx),\r\n                        result: result,\r\n                    })\r\n                    return result\r\n                } catch (error) {\r\n                    this.emit(\"debug\", {\r\n                        action: \"receiveCcipReadCallError\",\r\n                        transaction: Object.assign({}, tx),\r\n                        error: error,\r\n                    })\r\n                    throw error\r\n                }\r\n            }\r\n            throw error\r\n        }\r\n    }\r\n    async #checkNetwork(promise) {\r\n        const { value } = await resolveProperties({\r\n            network: this.getNetwork(),\r\n            value: promise,\r\n        })\r\n        return value\r\n    }\r\n    async call(_tx) {\r\n        const { tx, blockTag } = await resolveProperties({\r\n            tx: this._getTransactionRequest(_tx),\r\n            blockTag: this._getBlockTag(_tx.blockTag),\r\n        })\r\n        return await this.#checkNetwork(\r\n            this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1),\r\n        )\r\n    }\r\n    async #getAccountValue(request, _address, _blockTag) {\r\n        let address = this._getAddress(_address)\r\n        let blockTag = this._getBlockTag(_blockTag)\r\n        if (typeof address !== \"string\" || typeof blockTag !== \"string\") {\r\n            ;[address, blockTag] = await Promise.all([address, blockTag])\r\n        }\r\n        return await this.#checkNetwork(\r\n            this.#perform(\r\n                Object.assign(request, {\r\n                    address: address,\r\n                    blockTag: blockTag,\r\n                }),\r\n            ),\r\n        )\r\n    }\r\n    async getBalance(address, blockTag) {\r\n        return getBigInt(\r\n            await this.#getAccountValue(\r\n                {\r\n                    method: \"getBalance\",\r\n                },\r\n                address,\r\n                blockTag,\r\n            ),\r\n            \"%response\",\r\n        )\r\n    }\r\n    async getTransactionCount(address, blockTag) {\r\n        return getNumber(\r\n            await this.#getAccountValue(\r\n                {\r\n                    method: \"getTransactionCount\",\r\n                },\r\n                address,\r\n                blockTag,\r\n            ),\r\n            \"%response\",\r\n        )\r\n    }\r\n    async getCode(address, blockTag) {\r\n        return hexlify(\r\n            await this.#getAccountValue(\r\n                {\r\n                    method: \"getCode\",\r\n                },\r\n                address,\r\n                blockTag,\r\n            ),\r\n        )\r\n    }\r\n    async getStorage(address, _position, blockTag) {\r\n        const position = getBigInt(_position, \"position\")\r\n        return hexlify(\r\n            await this.#getAccountValue(\r\n                {\r\n                    method: \"getStorage\",\r\n                    position: position,\r\n                },\r\n                address,\r\n                blockTag,\r\n            ),\r\n        )\r\n    }\r\n    async broadcastTransaction(signedTx) {\r\n        const { blockNumber, hash, network } = await resolveProperties({\r\n            blockNumber: this.getBlockNumber(),\r\n            hash: this._perform({\r\n                method: \"broadcastTransaction\",\r\n                signedTransaction: signedTx,\r\n            }),\r\n            network: this.getNetwork(),\r\n        })\r\n        const tx = Transaction.from(signedTx)\r\n        if (tx.hash !== hash) {\r\n            throw new Error(\"@TODO: the returned hash did not match\")\r\n        }\r\n        return this._wrapTransactionResponse(\r\n            tx,\r\n            network,\r\n        ).replaceableTransaction(blockNumber)\r\n    }\r\n    async #getBlock(block, includeTransactions) {\r\n        if (isHexString(block, 32)) {\r\n            return await this.#perform({\r\n                method: \"getBlock\",\r\n                blockHash: block,\r\n                includeTransactions: includeTransactions,\r\n            })\r\n        }\r\n        let blockTag = this._getBlockTag(block)\r\n        if (typeof blockTag !== \"string\") {\r\n            blockTag = await blockTag\r\n        }\r\n        return await this.#perform({\r\n            method: \"getBlock\",\r\n            blockTag: blockTag,\r\n            includeTransactions: includeTransactions,\r\n        })\r\n    }\r\n    async getBlock(block, prefetchTxs) {\r\n        const { network, params } = await resolveProperties({\r\n            network: this.getNetwork(),\r\n            params: this.#getBlock(block, !!prefetchTxs),\r\n        })\r\n        if (params == null) {\r\n            return null\r\n        }\r\n        return this._wrapBlock(params, network)\r\n    }\r\n    async getTransaction(hash) {\r\n        const { network, params } = await resolveProperties({\r\n            network: this.getNetwork(),\r\n            params: this.#perform({\r\n                method: \"getTransaction\",\r\n                hash: hash,\r\n            }),\r\n        })\r\n        if (params == null) {\r\n            return null\r\n        }\r\n        return this._wrapTransactionResponse(params, network)\r\n    }\r\n    async getTransactionReceipt(hash) {\r\n        const { network, params } = await resolveProperties({\r\n            network: this.getNetwork(),\r\n            params: this.#perform({\r\n                method: \"getTransactionReceipt\",\r\n                hash: hash,\r\n            }),\r\n        })\r\n        if (params == null) {\r\n            return null\r\n        }\r\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\r\n            const tx = await this.#perform({\r\n                method: \"getTransaction\",\r\n                hash: hash,\r\n            })\r\n            if (tx == null) {\r\n                throw new Error(\r\n                    \"report this; could not find tx or effectiveGasPrice\",\r\n                )\r\n            }\r\n            params.effectiveGasPrice = tx.gasPrice\r\n        }\r\n        return this._wrapTransactionReceipt(params, network)\r\n    }\r\n    async getTransactionResult(hash) {\r\n        const { result } = await resolveProperties({\r\n            network: this.getNetwork(),\r\n            result: this.#perform({\r\n                method: \"getTransactionResult\",\r\n                hash: hash,\r\n            }),\r\n        })\r\n        if (result == null) {\r\n            return null\r\n        }\r\n        return hexlify(result)\r\n    }\r\n    async getLogs(_filter) {\r\n        let filter = this._getFilter(_filter)\r\n        if (isPromise$1(filter)) {\r\n            filter = await filter\r\n        }\r\n        const { network, params } = await resolveProperties({\r\n            network: this.getNetwork(),\r\n            params: this.#perform({\r\n                method: \"getLogs\",\r\n                filter: filter,\r\n            }),\r\n        })\r\n        return params.map((p) => this._wrapLog(p, network))\r\n    }\r\n    _getProvider(chainId) {\r\n        assert(\r\n            false,\r\n            \"provider cannot connect to target network\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"_getProvider()\",\r\n            },\r\n        )\r\n    }\r\n    async getResolver(name) {\r\n        return await EnsResolver.fromName(this, name)\r\n    }\r\n    async getAvatar(name) {\r\n        const resolver = await this.getResolver(name)\r\n        if (resolver) {\r\n            return await resolver.getAvatar()\r\n        }\r\n        return null\r\n    }\r\n    async resolveName(name) {\r\n        const resolver = await this.getResolver(name)\r\n        if (resolver) {\r\n            return await resolver.getAddress()\r\n        }\r\n        return null\r\n    }\r\n    async lookupAddress(address) {\r\n        address = getAddress(address)\r\n        const node = namehash(\r\n            address.substring(2).toLowerCase() + \".addr.reverse\",\r\n        )\r\n        try {\r\n            const ensAddr = await EnsResolver.getEnsAddress(this)\r\n            const ensContract = new Contract(\r\n                ensAddr,\r\n                [\"function resolver(bytes32) view returns (address)\"],\r\n                this,\r\n            )\r\n            const resolver = await ensContract.resolver(node)\r\n            if (resolver == null || resolver === ZeroAddress) {\r\n                return null\r\n            }\r\n            const resolverContract = new Contract(\r\n                resolver,\r\n                [\"function name(bytes32) view returns (string)\"],\r\n                this,\r\n            )\r\n            const name = await resolverContract.name(node)\r\n            const check = await this.resolveName(name)\r\n            if (check !== address) {\r\n                return null\r\n            }\r\n            return name\r\n        } catch (error) {\r\n            if (isError(error, \"BAD_DATA\") && error.value === \"0x\") {\r\n                return null\r\n            }\r\n            if (isError(error, \"CALL_EXCEPTION\")) {\r\n                return null\r\n            }\r\n            throw error\r\n        }\r\n        return null\r\n    }\r\n    async waitForTransaction(hash, _confirms, timeout) {\r\n        const confirms = _confirms != null ? _confirms : 1\r\n        if (confirms === 0) {\r\n            return this.getTransactionReceipt(hash)\r\n        }\r\n        return new Promise(async (resolve, reject) => {\r\n            let timer = null\r\n            const listener = async (blockNumber) => {\r\n                try {\r\n                    const receipt = await this.getTransactionReceipt(hash)\r\n                    if (receipt != null) {\r\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\r\n                            resolve(receipt)\r\n                            if (timer) {\r\n                                clearTimeout(timer)\r\n                                timer = null\r\n                            }\r\n                            return\r\n                        }\r\n                    }\r\n                } catch (error) {\r\n                    console.log(\"EEE\", error)\r\n                }\r\n                this.once(\"block\", listener)\r\n            }\r\n            if (timeout != null) {\r\n                timer = setTimeout(() => {\r\n                    if (timer == null) {\r\n                        return\r\n                    }\r\n                    timer = null\r\n                    this.off(\"block\", listener)\r\n                    reject(\r\n                        makeError(\"timeout\", \"TIMEOUT\", {\r\n                            reason: \"timeout\",\r\n                        }),\r\n                    )\r\n                }, timeout)\r\n            }\r\n            listener(await this.getBlockNumber())\r\n        })\r\n    }\r\n    async waitForBlock(blockTag) {\r\n        assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\r\n            operation: \"waitForBlock\",\r\n        })\r\n    }\r\n    _clearTimeout(timerId) {\r\n        const timer = this.#timers.get(timerId)\r\n        if (!timer) {\r\n            return\r\n        }\r\n        if (timer.timer) {\r\n            clearTimeout(timer.timer)\r\n        }\r\n        this.#timers.delete(timerId)\r\n    }\r\n    _setTimeout(_func, timeout) {\r\n        if (timeout == null) {\r\n            timeout = 0\r\n        }\r\n        const timerId = this.#nextTimer++\r\n        const func = () => {\r\n            this.#timers.delete(timerId)\r\n            _func()\r\n        }\r\n        if (this.paused) {\r\n            this.#timers.set(timerId, {\r\n                timer: null,\r\n                func: func,\r\n                time: timeout,\r\n            })\r\n        } else {\r\n            const timer = setTimeout(func, timeout)\r\n            this.#timers.set(timerId, {\r\n                timer: timer,\r\n                func: func,\r\n                time: getTime$1(),\r\n            })\r\n        }\r\n        return timerId\r\n    }\r\n    _forEachSubscriber(func) {\r\n        for (const sub of this.#subs.values()) {\r\n            func(sub.subscriber)\r\n        }\r\n    }\r\n    _getSubscriber(sub) {\r\n        switch (sub.type) {\r\n            case \"debug\":\r\n            case \"error\":\r\n            case \"network\":\r\n                return new UnmanagedSubscriber(sub.type)\r\n            case \"block\": {\r\n                const subscriber = new PollingBlockSubscriber(this)\r\n                subscriber.pollingInterval = this.pollingInterval\r\n                return subscriber\r\n            }\r\n            case \"safe\":\r\n            case \"finalized\":\r\n                return new PollingBlockTagSubscriber(this, sub.type)\r\n            case \"event\":\r\n                return new PollingEventSubscriber(this, sub.filter)\r\n            case \"transaction\":\r\n                return new PollingTransactionSubscriber(this, sub.hash)\r\n            case \"orphan\":\r\n                return new PollingOrphanSubscriber(this, sub.filter)\r\n        }\r\n        throw new Error(`unsupported event: ${sub.type}`)\r\n    }\r\n    _recoverSubscriber(oldSub, newSub) {\r\n        for (const sub of this.#subs.values()) {\r\n            if (sub.subscriber === oldSub) {\r\n                if (sub.started) {\r\n                    sub.subscriber.stop()\r\n                }\r\n                sub.subscriber = newSub\r\n                if (sub.started) {\r\n                    newSub.start()\r\n                }\r\n                if (this.#pausedState != null) {\r\n                    newSub.pause(this.#pausedState)\r\n                }\r\n                break\r\n            }\r\n        }\r\n    }\r\n    async #hasSub(event, emitArgs) {\r\n        let sub = await getSubscription(event, this)\r\n        if (\r\n            sub.type === \"event\" &&\r\n            emitArgs &&\r\n            emitArgs.length > 0 &&\r\n            emitArgs[0].removed === true\r\n        ) {\r\n            sub = await getSubscription(\r\n                {\r\n                    orphan: \"drop-log\",\r\n                    log: emitArgs[0],\r\n                },\r\n                this,\r\n            )\r\n        }\r\n        return this.#subs.get(sub.tag) || null\r\n    }\r\n    async #getSub(event) {\r\n        const subscription = await getSubscription(event, this)\r\n        const tag = subscription.tag\r\n        let sub = this.#subs.get(tag)\r\n        if (!sub) {\r\n            const subscriber = this._getSubscriber(subscription)\r\n            const addressableMap = new WeakMap()\r\n            const nameMap = new Map()\r\n            sub = {\r\n                subscriber: subscriber,\r\n                tag: tag,\r\n                addressableMap: addressableMap,\r\n                nameMap: nameMap,\r\n                started: false,\r\n                listeners: [],\r\n            }\r\n            this.#subs.set(tag, sub)\r\n        }\r\n        return sub\r\n    }\r\n    async on(event, listener) {\r\n        const sub = await this.#getSub(event)\r\n        sub.listeners.push({\r\n            listener: listener,\r\n            once: false,\r\n        })\r\n        if (!sub.started) {\r\n            sub.subscriber.start()\r\n            sub.started = true\r\n            if (this.#pausedState != null) {\r\n                sub.subscriber.pause(this.#pausedState)\r\n            }\r\n        }\r\n        return this\r\n    }\r\n    async once(event, listener) {\r\n        const sub = await this.#getSub(event)\r\n        sub.listeners.push({\r\n            listener: listener,\r\n            once: true,\r\n        })\r\n        if (!sub.started) {\r\n            sub.subscriber.start()\r\n            sub.started = true\r\n            if (this.#pausedState != null) {\r\n                sub.subscriber.pause(this.#pausedState)\r\n            }\r\n        }\r\n        return this\r\n    }\r\n    async emit(event, ...args) {\r\n        const sub = await this.#hasSub(event, args)\r\n        if (!sub || sub.listeners.length === 0) {\r\n            return false\r\n        }\r\n        const count = sub.listeners.length\r\n        sub.listeners = sub.listeners.filter(({ listener, once }) => {\r\n            const payload = new EventPayload(\r\n                this,\r\n                once ? null : listener,\r\n                event,\r\n            )\r\n            try {\r\n                listener.call(this, ...args, payload)\r\n            } catch (error) {}\r\n            return !once\r\n        })\r\n        if (sub.listeners.length === 0) {\r\n            if (sub.started) {\r\n                sub.subscriber.stop()\r\n            }\r\n            this.#subs.delete(sub.tag)\r\n        }\r\n        return count > 0\r\n    }\r\n    async listenerCount(event) {\r\n        if (event) {\r\n            const sub = await this.#hasSub(event)\r\n            if (!sub) {\r\n                return 0\r\n            }\r\n            return sub.listeners.length\r\n        }\r\n        let total = 0\r\n        for (const { listeners } of this.#subs.values()) {\r\n            total += listeners.length\r\n        }\r\n        return total\r\n    }\r\n    async listeners(event) {\r\n        if (event) {\r\n            const sub = await this.#hasSub(event)\r\n            if (!sub) {\r\n                return []\r\n            }\r\n            return sub.listeners.map(({ listener }) => listener)\r\n        }\r\n        let result = []\r\n        for (const { listeners } of this.#subs.values()) {\r\n            result = result.concat(listeners.map(({ listener }) => listener))\r\n        }\r\n        return result\r\n    }\r\n    async off(event, listener) {\r\n        const sub = await this.#hasSub(event)\r\n        if (!sub) {\r\n            return this\r\n        }\r\n        if (listener) {\r\n            const index = sub.listeners\r\n                .map(({ listener }) => listener)\r\n                .indexOf(listener)\r\n            if (index >= 0) {\r\n                sub.listeners.splice(index, 1)\r\n            }\r\n        }\r\n        if (!listener || sub.listeners.length === 0) {\r\n            if (sub.started) {\r\n                sub.subscriber.stop()\r\n            }\r\n            this.#subs.delete(sub.tag)\r\n        }\r\n        return this\r\n    }\r\n    async removeAllListeners(event) {\r\n        if (event) {\r\n            const { tag, started, subscriber } = await this.#getSub(event)\r\n            if (started) {\r\n                subscriber.stop()\r\n            }\r\n            this.#subs.delete(tag)\r\n        } else {\r\n            for (const [tag, { started, subscriber }] of this.#subs) {\r\n                if (started) {\r\n                    subscriber.stop()\r\n                }\r\n                this.#subs.delete(tag)\r\n            }\r\n        }\r\n        return this\r\n    }\r\n    async addListener(event, listener) {\r\n        return await this.on(event, listener)\r\n    }\r\n    async removeListener(event, listener) {\r\n        return this.off(event, listener)\r\n    }\r\n    get destroyed() {\r\n        return this.#destroyed\r\n    }\r\n    destroy() {\r\n        this.removeAllListeners()\r\n        for (const timerId of this.#timers.keys()) {\r\n            this._clearTimeout(timerId)\r\n        }\r\n        this.#destroyed = true\r\n    }\r\n    get paused() {\r\n        return this.#pausedState != null\r\n    }\r\n    set paused(pause) {\r\n        if (!!pause === this.paused) {\r\n            return\r\n        }\r\n        if (this.paused) {\r\n            this.resume()\r\n        } else {\r\n            this.pause(false)\r\n        }\r\n    }\r\n    pause(dropWhilePaused) {\r\n        this.#lastBlockNumber = -1\r\n        if (this.#pausedState != null) {\r\n            if (this.#pausedState == !!dropWhilePaused) {\r\n                return\r\n            }\r\n            assert(\r\n                false,\r\n                \"cannot change pause type; resume first\",\r\n                \"UNSUPPORTED_OPERATION\",\r\n                {\r\n                    operation: \"pause\",\r\n                },\r\n            )\r\n        }\r\n        this._forEachSubscriber((s) => s.pause(dropWhilePaused))\r\n        this.#pausedState = !!dropWhilePaused\r\n        for (const timer of this.#timers.values()) {\r\n            if (timer.timer) {\r\n                clearTimeout(timer.timer)\r\n            }\r\n            timer.time = getTime$1() - timer.time\r\n        }\r\n    }\r\n    resume() {\r\n        if (this.#pausedState == null) {\r\n            return\r\n        }\r\n        this._forEachSubscriber((s) => s.resume())\r\n        this.#pausedState = null\r\n        for (const timer of this.#timers.values()) {\r\n            let timeout = timer.time\r\n            if (timeout < 0) {\r\n                timeout = 0\r\n            }\r\n            timer.time = getTime$1()\r\n            setTimeout(timer.func, timeout)\r\n        }\r\n    }\r\n}\r\nfunction _parseString(result, start) {\r\n    try {\r\n        const bytes = _parseBytes(result, start)\r\n        if (bytes) {\r\n            return toUtf8String(bytes)\r\n        }\r\n    } catch (error) {}\r\n    return null\r\n}\r\nfunction _parseBytes(result, start) {\r\n    if (result === \"0x\") {\r\n        return null\r\n    }\r\n    try {\r\n        const offset = getNumber(dataSlice(result, start, start + 32))\r\n        const length = getNumber(dataSlice(result, offset, offset + 32))\r\n        return dataSlice(result, offset + 32, offset + 32 + length)\r\n    } catch (error) {}\r\n    return null\r\n}\r\nfunction numPad(value) {\r\n    const result = toBeArray(value)\r\n    if (result.length > 32) {\r\n        throw new Error(\"internal; should not happen\")\r\n    }\r\n    const padded = new Uint8Array(32)\r\n    padded.set(result, 32 - result.length)\r\n    return padded\r\n}\r\nfunction bytesPad(value) {\r\n    if (value.length % 32 === 0) {\r\n        return value\r\n    }\r\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32)\r\n    result.set(value)\r\n    return result\r\n}\r\nconst empty = new Uint8Array([])\r\nfunction encodeBytes(datas) {\r\n    const result = []\r\n    let byteCount = 0\r\n    for (let i = 0; i < datas.length; i++) {\r\n        result.push(empty)\r\n        byteCount += 32\r\n    }\r\n    for (let i = 0; i < datas.length; i++) {\r\n        const data = getBytes(datas[i])\r\n        result[i] = numPad(byteCount)\r\n        result.push(numPad(data.length))\r\n        result.push(bytesPad(data))\r\n        byteCount += 32 + Math.ceil(data.length / 32) * 32\r\n    }\r\n    return concat(result)\r\n}\r\nconst zeros =\r\n    \"0x0000000000000000000000000000000000000000000000000000000000000000\"\r\nfunction parseOffchainLookup(data) {\r\n    const result = {\r\n        sender: \"\",\r\n        urls: [],\r\n        calldata: \"\",\r\n        selector: \"\",\r\n        extraData: \"\",\r\n        errorArgs: [],\r\n    }\r\n    assert(\r\n        dataLength(data) >= 5 * 32,\r\n        \"insufficient OffchainLookup data\",\r\n        \"OFFCHAIN_FAULT\",\r\n        {\r\n            reason: \"insufficient OffchainLookup data\",\r\n        },\r\n    )\r\n    const sender = dataSlice(data, 0, 32)\r\n    assert(\r\n        dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12),\r\n        \"corrupt OffchainLookup sender\",\r\n        \"OFFCHAIN_FAULT\",\r\n        {\r\n            reason: \"corrupt OffchainLookup sender\",\r\n        },\r\n    )\r\n    result.sender = dataSlice(sender, 12)\r\n    try {\r\n        const urls = []\r\n        const urlsOffset = getNumber(dataSlice(data, 32, 64))\r\n        const urlsLength = getNumber(\r\n            dataSlice(data, urlsOffset, urlsOffset + 32),\r\n        )\r\n        const urlsData = dataSlice(data, urlsOffset + 32)\r\n        for (let u = 0; u < urlsLength; u++) {\r\n            const url = _parseString(urlsData, u * 32)\r\n            if (url == null) {\r\n                throw new Error(\"abort\")\r\n            }\r\n            urls.push(url)\r\n        }\r\n        result.urls = urls\r\n    } catch (error) {\r\n        assert(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\r\n            reason: \"corrupt OffchainLookup urls\",\r\n        })\r\n    }\r\n    try {\r\n        const calldata = _parseBytes(data, 64)\r\n        if (calldata == null) {\r\n            throw new Error(\"abort\")\r\n        }\r\n        result.calldata = calldata\r\n    } catch (error) {\r\n        assert(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\r\n            reason: \"corrupt OffchainLookup calldata\",\r\n        })\r\n    }\r\n    assert(\r\n        dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28),\r\n        \"corrupt OffchainLookup callbaackSelector\",\r\n        \"OFFCHAIN_FAULT\",\r\n        {\r\n            reason: \"corrupt OffchainLookup callbaackSelector\",\r\n        },\r\n    )\r\n    result.selector = dataSlice(data, 96, 100)\r\n    try {\r\n        const extraData = _parseBytes(data, 128)\r\n        if (extraData == null) {\r\n            throw new Error(\"abort\")\r\n        }\r\n        result.extraData = extraData\r\n    } catch (error) {\r\n        assert(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\r\n            reason: \"corrupt OffchainLookup extraData\",\r\n        })\r\n    }\r\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\"\r\n        .split(/,/)\r\n        .map((k) => result[k])\r\n    return result\r\n}\r\nfunction checkProvider(signer, operation) {\r\n    if (signer.provider) {\r\n        return signer.provider\r\n    }\r\n    assert(false, \"missing provider\", \"UNSUPPORTED_OPERATION\", {\r\n        operation: operation,\r\n    })\r\n}\r\nasync function populate(signer, tx) {\r\n    let pop = copyRequest(tx)\r\n    if (pop.to != null) {\r\n        pop.to = resolveAddress(pop.to, signer)\r\n    }\r\n    if (pop.from != null) {\r\n        const from = pop.from\r\n        pop.from = Promise.all([\r\n            signer.getAddress(),\r\n            resolveAddress(from, signer),\r\n        ]).then(([address, from]) => {\r\n            assertArgument(\r\n                address.toLowerCase() === from.toLowerCase(),\r\n                \"transaction from mismatch\",\r\n                \"tx.from\",\r\n                from,\r\n            )\r\n            return address\r\n        })\r\n    } else {\r\n        pop.from = signer.getAddress()\r\n    }\r\n    return await resolveProperties(pop)\r\n}\r\nclass AbstractSigner {\r\n    provider\r\n    constructor(provider) {\r\n        defineProperties(this, {\r\n            provider: provider || null,\r\n        })\r\n    }\r\n    async getNonce(blockTag) {\r\n        return checkProvider(this, \"getTransactionCount\").getTransactionCount(\r\n            await this.getAddress(),\r\n            blockTag,\r\n        )\r\n    }\r\n    async populateCall(tx) {\r\n        const pop = await populate(this, tx)\r\n        return pop\r\n    }\r\n    async populateTransaction(tx) {\r\n        const provider = checkProvider(this, \"populateTransaction\")\r\n        const pop = await populate(this, tx)\r\n        if (pop.nonce == null) {\r\n            pop.nonce = await this.getNonce(\"pending\")\r\n        }\r\n        if (pop.gasLimit == null) {\r\n            pop.gasLimit = await this.estimateGas(pop)\r\n        }\r\n        const network = await this.provider.getNetwork()\r\n        if (pop.chainId != null) {\r\n            const chainId = getBigInt(pop.chainId)\r\n            assertArgument(\r\n                chainId === network.chainId,\r\n                \"transaction chainId mismatch\",\r\n                \"tx.chainId\",\r\n                tx.chainId,\r\n            )\r\n        } else {\r\n            pop.chainId = network.chainId\r\n        }\r\n        const hasEip1559 =\r\n            pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null\r\n        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {\r\n            assertArgument(\r\n                false,\r\n                \"eip-1559 transaction do not support gasPrice\",\r\n                \"tx\",\r\n                tx,\r\n            )\r\n        } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {\r\n            assertArgument(\r\n                false,\r\n                \"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\",\r\n                \"tx\",\r\n                tx,\r\n            )\r\n        }\r\n        if (\r\n            (pop.type === 2 || pop.type == null) &&\r\n            pop.maxFeePerGas != null &&\r\n            pop.maxPriorityFeePerGas != null\r\n        ) {\r\n            pop.type = 2\r\n        } else if (pop.type === 0 || pop.type === 1) {\r\n            const feeData = await provider.getFeeData()\r\n            assert(\r\n                feeData.gasPrice != null,\r\n                \"network does not support gasPrice\",\r\n                \"UNSUPPORTED_OPERATION\",\r\n                {\r\n                    operation: \"getGasPrice\",\r\n                },\r\n            )\r\n            if (pop.gasPrice == null) {\r\n                pop.gasPrice = feeData.gasPrice\r\n            }\r\n        } else {\r\n            const feeData = await provider.getFeeData()\r\n            if (pop.type == null) {\r\n                if (\r\n                    feeData.maxFeePerGas != null &&\r\n                    feeData.maxPriorityFeePerGas != null\r\n                ) {\r\n                    pop.type = 2\r\n                    if (pop.gasPrice != null) {\r\n                        const gasPrice = pop.gasPrice\r\n                        delete pop.gasPrice\r\n                        pop.maxFeePerGas = gasPrice\r\n                        pop.maxPriorityFeePerGas = gasPrice\r\n                    } else {\r\n                        if (pop.maxFeePerGas == null) {\r\n                            pop.maxFeePerGas = feeData.maxFeePerGas\r\n                        }\r\n                        if (pop.maxPriorityFeePerGas == null) {\r\n                            pop.maxPriorityFeePerGas =\r\n                                feeData.maxPriorityFeePerGas\r\n                        }\r\n                    }\r\n                } else if (feeData.gasPrice != null) {\r\n                    assert(\r\n                        !hasEip1559,\r\n                        \"network does not support EIP-1559\",\r\n                        \"UNSUPPORTED_OPERATION\",\r\n                        {\r\n                            operation: \"populateTransaction\",\r\n                        },\r\n                    )\r\n                    if (pop.gasPrice == null) {\r\n                        pop.gasPrice = feeData.gasPrice\r\n                    }\r\n                    pop.type = 0\r\n                } else {\r\n                    assert(\r\n                        false,\r\n                        \"failed to get consistent fee data\",\r\n                        \"UNSUPPORTED_OPERATION\",\r\n                        {\r\n                            operation: \"signer.getFeeData\",\r\n                        },\r\n                    )\r\n                }\r\n            } else if (pop.type === 2) {\r\n                if (pop.maxFeePerGas == null) {\r\n                    pop.maxFeePerGas = feeData.maxFeePerGas\r\n                }\r\n                if (pop.maxPriorityFeePerGas == null) {\r\n                    pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas\r\n                }\r\n            }\r\n        }\r\n        return await resolveProperties(pop)\r\n    }\r\n    async estimateGas(tx) {\r\n        return checkProvider(this, \"estimateGas\").estimateGas(\r\n            await this.populateCall(tx),\r\n        )\r\n    }\r\n    async call(tx) {\r\n        return checkProvider(this, \"call\").call(await this.populateCall(tx))\r\n    }\r\n    async resolveName(name) {\r\n        const provider = checkProvider(this, \"resolveName\")\r\n        return await provider.resolveName(name)\r\n    }\r\n    async sendTransaction(tx) {\r\n        const provider = checkProvider(this, \"sendTransaction\")\r\n        const pop = await this.populateTransaction(tx)\r\n        delete pop.from\r\n        const txObj = Transaction.from(pop)\r\n        return await provider.broadcastTransaction(\r\n            await this.signTransaction(txObj),\r\n        )\r\n    }\r\n}\r\nclass VoidSigner extends AbstractSigner {\r\n    address\r\n    constructor(address, provider) {\r\n        super(provider)\r\n        defineProperties(this, {\r\n            address: address,\r\n        })\r\n    }\r\n    async getAddress() {\r\n        return this.address\r\n    }\r\n    connect(provider) {\r\n        return new VoidSigner(this.address, provider)\r\n    }\r\n    #throwUnsupported(suffix, operation) {\r\n        assert(\r\n            false,\r\n            `VoidSigner cannot sign ${suffix}`,\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: operation,\r\n            },\r\n        )\r\n    }\r\n    async signTransaction(tx) {\r\n        this.#throwUnsupported(\"transactions\", \"signTransaction\")\r\n    }\r\n    async signMessage(message) {\r\n        this.#throwUnsupported(\"messages\", \"signMessage\")\r\n    }\r\n    async signTypedData(domain, types, value) {\r\n        this.#throwUnsupported(\"typed-data\", \"signTypedData\")\r\n    }\r\n}\r\nconst shown = new Set()\r\nfunction showThrottleMessage(service) {\r\n    if (shown.has(service)) {\r\n        return\r\n    }\r\n    shown.add(service)\r\n    console.log(\"========= NOTICE =========\")\r\n    console.log(\r\n        `Request-Rate Exceeded for ${service} (this message will not be repeated)`,\r\n    )\r\n    console.log(\"\")\r\n    console.log(\r\n        \"The default API keys for each service are provided as a highly-throttled,\",\r\n    )\r\n    console.log(\r\n        \"community resource for low-traffic projects and early prototyping.\",\r\n    )\r\n    console.log(\"\")\r\n    console.log(\r\n        \"While your application will continue to function, we highly recommended\",\r\n    )\r\n    console.log(\r\n        \"signing up for your own API keys to improve performance, increase your\",\r\n    )\r\n    console.log(\r\n        \"request rate/limit and enable other perks, such as metrics and advanced APIs.\",\r\n    )\r\n    console.log(\"\")\r\n    console.log(\"For more details: https://docs.ethers.org/api-keys/\")\r\n    console.log(\"==========================\")\r\n}\r\nfunction copy(obj) {\r\n    return JSON.parse(JSON.stringify(obj))\r\n}\r\nclass FilterIdSubscriber {\r\n    #provider\r\n    #filterIdPromise\r\n    #poller\r\n    #running\r\n    #network\r\n    #hault\r\n    constructor(provider) {\r\n        this.#provider = provider\r\n        this.#filterIdPromise = null\r\n        this.#poller = this.#poll.bind(this)\r\n        this.#running = false\r\n        this.#network = null\r\n        this.#hault = false\r\n    }\r\n    _subscribe(provider) {\r\n        throw new Error(\"subclasses must override this\")\r\n    }\r\n    _emitResults(provider, result) {\r\n        throw new Error(\"subclasses must override this\")\r\n    }\r\n    _recover(provider) {\r\n        throw new Error(\"subclasses must override this\")\r\n    }\r\n    async #poll(blockNumber) {\r\n        try {\r\n            if (this.#filterIdPromise == null) {\r\n                this.#filterIdPromise = this._subscribe(this.#provider)\r\n            }\r\n            let filterId = null\r\n            try {\r\n                filterId = await this.#filterIdPromise\r\n            } catch (error) {\r\n                if (\r\n                    !isError(error, \"UNSUPPORTED_OPERATION\") ||\r\n                    error.operation !== \"eth_newFilter\"\r\n                ) {\r\n                    throw error\r\n                }\r\n            }\r\n            if (filterId == null) {\r\n                this.#filterIdPromise = null\r\n                this.#provider._recoverSubscriber(\r\n                    this,\r\n                    this._recover(this.#provider),\r\n                )\r\n                return\r\n            }\r\n            const network = await this.#provider.getNetwork()\r\n            if (!this.#network) {\r\n                this.#network = network\r\n            }\r\n            if (this.#network.chainId !== network.chainId) {\r\n                throw new Error(\"chaid changed\")\r\n            }\r\n            if (this.#hault) {\r\n                return\r\n            }\r\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [\r\n                filterId,\r\n            ])\r\n            await this._emitResults(this.#provider, result)\r\n        } catch (error) {\r\n            console.log(\"@TODO\", error)\r\n        }\r\n        this.#provider.once(\"block\", this.#poller)\r\n    }\r\n    #teardown() {\r\n        const filterIdPromise = this.#filterIdPromise\r\n        if (filterIdPromise) {\r\n            this.#filterIdPromise = null\r\n            filterIdPromise.then((filterId) => {\r\n                this.#provider.send(\"eth_uninstallFilter\", [filterId])\r\n            })\r\n        }\r\n    }\r\n    start() {\r\n        if (this.#running) {\r\n            return\r\n        }\r\n        this.#running = true\r\n        this.#poll(-2)\r\n    }\r\n    stop() {\r\n        if (!this.#running) {\r\n            return\r\n        }\r\n        this.#running = false\r\n        this.#hault = true\r\n        this.#teardown()\r\n        this.#provider.off(\"block\", this.#poller)\r\n    }\r\n    pause(dropWhilePaused) {\r\n        if (dropWhilePaused) {\r\n            this.#teardown()\r\n        }\r\n        this.#provider.off(\"block\", this.#poller)\r\n    }\r\n    resume() {\r\n        this.start()\r\n    }\r\n}\r\nclass FilterIdEventSubscriber extends FilterIdSubscriber {\r\n    #event\r\n    constructor(provider, filter) {\r\n        super(provider)\r\n        this.#event = copy(filter)\r\n    }\r\n    _recover(provider) {\r\n        return new PollingEventSubscriber(provider, this.#event)\r\n    }\r\n    async _subscribe(provider) {\r\n        const filterId = await provider.send(\"eth_newFilter\", [this.#event])\r\n        return filterId\r\n    }\r\n    async _emitResults(provider, results) {\r\n        for (const result of results) {\r\n            provider.emit(\r\n                this.#event,\r\n                provider._wrapLog(result, provider._network),\r\n            )\r\n        }\r\n    }\r\n}\r\nclass FilterIdPendingSubscriber extends FilterIdSubscriber {\r\n    async _subscribe(provider) {\r\n        return await provider.send(\"eth_newPendingTransactionFilter\", [])\r\n    }\r\n    async _emitResults(provider, results) {\r\n        for (const result of results) {\r\n            provider.emit(\"pending\", result)\r\n        }\r\n    }\r\n}\r\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g)\r\nfunction deepCopy(value) {\r\n    if (value == null || Primitive.indexOf(typeof value) >= 0) {\r\n        return value\r\n    }\r\n    if (typeof value.getAddress === \"function\") {\r\n        return value\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return value.map(deepCopy)\r\n    }\r\n    if (typeof value === \"object\") {\r\n        return Object.keys(value).reduce((accum, key) => {\r\n            accum[key] = value[key]\r\n            return accum\r\n        }, {})\r\n    }\r\n    throw new Error(`should not happen: ${value} (${typeof value})`)\r\n}\r\nfunction stall$3(duration) {\r\n    return new Promise((resolve) => {\r\n        setTimeout(resolve, duration)\r\n    })\r\n}\r\nfunction getLowerCase(value) {\r\n    if (value) {\r\n        return value.toLowerCase()\r\n    }\r\n    return value\r\n}\r\nfunction isPollable(value) {\r\n    return value && typeof value.pollingInterval === \"number\"\r\n}\r\nconst defaultOptions = {\r\n    polling: false,\r\n    staticNetwork: null,\r\n    batchStallTime: 10,\r\n    batchMaxSize: 1 << 20,\r\n    batchMaxCount: 100,\r\n    cacheTimeout: 250,\r\n    pollingInterval: 4e3,\r\n}\r\nclass JsonRpcSigner extends AbstractSigner {\r\n    address\r\n    constructor(provider, address) {\r\n        super(provider)\r\n        address = getAddress(address)\r\n        defineProperties(this, {\r\n            address: address,\r\n        })\r\n    }\r\n    connect(provider) {\r\n        assert(\r\n            false,\r\n            \"cannot reconnect JsonRpcSigner\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"signer.connect\",\r\n            },\r\n        )\r\n    }\r\n    async getAddress() {\r\n        return this.address\r\n    }\r\n    async populateTransaction(tx) {\r\n        return await this.populateCall(tx)\r\n    }\r\n    async sendUncheckedTransaction(_tx) {\r\n        const tx = deepCopy(_tx)\r\n        const promises = []\r\n        if (tx.from) {\r\n            const _from = tx.from\r\n            promises.push(\r\n                (async () => {\r\n                    const from = await resolveAddress(_from, this.provider)\r\n                    assertArgument(\r\n                        from != null &&\r\n                            from.toLowerCase() === this.address.toLowerCase(),\r\n                        \"from address mismatch\",\r\n                        \"transaction\",\r\n                        _tx,\r\n                    )\r\n                    tx.from = from\r\n                })(),\r\n            )\r\n        } else {\r\n            tx.from = this.address\r\n        }\r\n        if (tx.gasLimit == null) {\r\n            promises.push(\r\n                (async () => {\r\n                    tx.gasLimit = await this.provider.estimateGas({\r\n                        ...tx,\r\n                        from: this.address,\r\n                    })\r\n                })(),\r\n            )\r\n        }\r\n        if (tx.to != null) {\r\n            const _to = tx.to\r\n            promises.push(\r\n                (async () => {\r\n                    tx.to = await resolveAddress(_to, this.provider)\r\n                })(),\r\n            )\r\n        }\r\n        if (promises.length) {\r\n            await Promise.all(promises)\r\n        }\r\n        const hexTx = this.provider.getRpcTransaction(tx)\r\n        return this.provider.send(\"eth_sendTransaction\", [hexTx])\r\n    }\r\n    async sendTransaction(tx) {\r\n        const blockNumber = await this.provider.getBlockNumber()\r\n        const hash = await this.sendUncheckedTransaction(tx)\r\n        return await new Promise((resolve, reject) => {\r\n            const timeouts = [1e3, 100]\r\n            let invalids = 0\r\n            const checkTx = async () => {\r\n                try {\r\n                    const tx = await this.provider.getTransaction(hash)\r\n                    if (tx != null) {\r\n                        resolve(tx.replaceableTransaction(blockNumber))\r\n                        return\r\n                    }\r\n                } catch (error) {\r\n                    if (\r\n                        isError(error, \"CANCELLED\") ||\r\n                        isError(error, \"BAD_DATA\") ||\r\n                        isError(error, \"NETWORK_ERROR\")\r\n                    ) {\r\n                        if (error.info == null) {\r\n                            error.info = {}\r\n                        }\r\n                        error.info.sendTransactionHash = hash\r\n                        reject(error)\r\n                        return\r\n                    }\r\n                    if (isError(error, \"INVALID_ARGUMENT\")) {\r\n                        invalids++\r\n                        if (error.info == null) {\r\n                            error.info = {}\r\n                        }\r\n                        error.info.sendTransactionHash = hash\r\n                        if (invalids > 10) {\r\n                            reject(error)\r\n                            return\r\n                        }\r\n                    }\r\n                    this.provider.emit(\r\n                        \"error\",\r\n                        makeError(\r\n                            \"failed to fetch transation after sending (will try again)\",\r\n                            \"UNKNOWN_ERROR\",\r\n                            {\r\n                                error: error,\r\n                            },\r\n                        ),\r\n                    )\r\n                }\r\n                this.provider._setTimeout(() => {\r\n                    checkTx()\r\n                }, timeouts.pop() || 4e3)\r\n            }\r\n            checkTx()\r\n        })\r\n    }\r\n    async signTransaction(_tx) {\r\n        const tx = deepCopy(_tx)\r\n        if (tx.from) {\r\n            const from = await resolveAddress(tx.from, this.provider)\r\n            assertArgument(\r\n                from != null &&\r\n                    from.toLowerCase() === this.address.toLowerCase(),\r\n                \"from address mismatch\",\r\n                \"transaction\",\r\n                _tx,\r\n            )\r\n            tx.from = from\r\n        } else {\r\n            tx.from = this.address\r\n        }\r\n        const hexTx = this.provider.getRpcTransaction(tx)\r\n        return await this.provider.send(\"eth_signTransaction\", [hexTx])\r\n    }\r\n    async signMessage(_message) {\r\n        const message =\r\n            typeof _message === \"string\" ? toUtf8Bytes(_message) : _message\r\n        return await this.provider.send(\"personal_sign\", [\r\n            hexlify(message),\r\n            this.address.toLowerCase(),\r\n        ])\r\n    }\r\n    async signTypedData(domain, types, _value) {\r\n        const value = deepCopy(_value)\r\n        const populated = await TypedDataEncoder.resolveNames(\r\n            domain,\r\n            types,\r\n            value,\r\n            async (value) => {\r\n                const address = await resolveAddress(value)\r\n                assertArgument(\r\n                    address != null,\r\n                    \"TypedData does not support null address\",\r\n                    \"value\",\r\n                    value,\r\n                )\r\n                return address\r\n            },\r\n        )\r\n        return await this.provider.send(\"eth_signTypedData_v4\", [\r\n            this.address.toLowerCase(),\r\n            JSON.stringify(\r\n                TypedDataEncoder.getPayload(\r\n                    populated.domain,\r\n                    types,\r\n                    populated.value,\r\n                ),\r\n            ),\r\n        ])\r\n    }\r\n    async unlock(password) {\r\n        return this.provider.send(\"personal_unlockAccount\", [\r\n            this.address.toLowerCase(),\r\n            password,\r\n            null,\r\n        ])\r\n    }\r\n    async _legacySignMessage(_message) {\r\n        const message =\r\n            typeof _message === \"string\" ? toUtf8Bytes(_message) : _message\r\n        return await this.provider.send(\"eth_sign\", [\r\n            this.address.toLowerCase(),\r\n            hexlify(message),\r\n        ])\r\n    }\r\n}\r\nclass JsonRpcApiProvider extends AbstractProvider {\r\n    #options\r\n    #nextId\r\n    #payloads\r\n    #drainTimer\r\n    #notReady\r\n    #network\r\n    #pendingDetectNetwork\r\n    #scheduleDrain() {\r\n        if (this.#drainTimer) {\r\n            return\r\n        }\r\n        const stallTime =\r\n            this._getOption(\"batchMaxCount\") === 1\r\n                ? 0\r\n                : this._getOption(\"batchStallTime\")\r\n        this.#drainTimer = setTimeout(() => {\r\n            this.#drainTimer = null\r\n            const payloads = this.#payloads\r\n            this.#payloads = []\r\n            while (payloads.length) {\r\n                const batch = [payloads.shift()]\r\n                while (payloads.length) {\r\n                    if (batch.length === this.#options.batchMaxCount) {\r\n                        break\r\n                    }\r\n                    batch.push(payloads.shift())\r\n                    const bytes = JSON.stringify(batch.map((p) => p.payload))\r\n                    if (bytes.length > this.#options.batchMaxSize) {\r\n                        payloads.unshift(batch.pop())\r\n                        break\r\n                    }\r\n                }\r\n                ;(async () => {\r\n                    const payload =\r\n                        batch.length === 1\r\n                            ? batch[0].payload\r\n                            : batch.map((p) => p.payload)\r\n                    this.emit(\"debug\", {\r\n                        action: \"sendRpcPayload\",\r\n                        payload: payload,\r\n                    })\r\n                    try {\r\n                        const result = await this._send(payload)\r\n                        this.emit(\"debug\", {\r\n                            action: \"receiveRpcResult\",\r\n                            result: result,\r\n                        })\r\n                        for (const { resolve, reject, payload } of batch) {\r\n                            if (this.destroyed) {\r\n                                reject(\r\n                                    makeError(\r\n                                        \"provider destroyed; cancelled request\",\r\n                                        \"UNSUPPORTED_OPERATION\",\r\n                                        {\r\n                                            operation: payload.method,\r\n                                        },\r\n                                    ),\r\n                                )\r\n                                continue\r\n                            }\r\n                            const resp = result.filter(\r\n                                (r) => r.id === payload.id,\r\n                            )[0]\r\n                            if (resp == null) {\r\n                                const error = makeError(\r\n                                    \"missing response for request\",\r\n                                    \"BAD_DATA\",\r\n                                    {\r\n                                        value: result,\r\n                                        info: {\r\n                                            payload: payload,\r\n                                        },\r\n                                    },\r\n                                )\r\n                                this.emit(\"error\", error)\r\n                                reject(error)\r\n                                continue\r\n                            }\r\n                            if (\"error\" in resp) {\r\n                                reject(this.getRpcError(payload, resp))\r\n                                continue\r\n                            }\r\n                            resolve(resp.result)\r\n                        }\r\n                    } catch (error) {\r\n                        this.emit(\"debug\", {\r\n                            action: \"receiveRpcError\",\r\n                            error: error,\r\n                        })\r\n                        for (const { reject } of batch) {\r\n                            reject(error)\r\n                        }\r\n                    }\r\n                })()\r\n            }\r\n        }, stallTime)\r\n    }\r\n    constructor(network, options) {\r\n        super(network, options)\r\n        this.#nextId = 1\r\n        this.#options = Object.assign({}, defaultOptions, options || {})\r\n        this.#payloads = []\r\n        this.#drainTimer = null\r\n        this.#network = null\r\n        this.#pendingDetectNetwork = null\r\n        {\r\n            let resolve = null\r\n            const promise = new Promise((_resolve) => {\r\n                resolve = _resolve\r\n            })\r\n            this.#notReady = {\r\n                promise: promise,\r\n                resolve: resolve,\r\n            }\r\n        }\r\n        const staticNetwork = this._getOption(\"staticNetwork\")\r\n        if (typeof staticNetwork === \"boolean\") {\r\n            assertArgument(\r\n                !staticNetwork || network !== \"any\",\r\n                \"staticNetwork cannot be used on special network 'any'\",\r\n                \"options\",\r\n                options,\r\n            )\r\n            if (staticNetwork && network != null) {\r\n                this.#network = Network.from(network)\r\n            }\r\n        } else if (staticNetwork) {\r\n            assertArgument(\r\n                network == null || staticNetwork.matches(network),\r\n                \"staticNetwork MUST match network object\",\r\n                \"options\",\r\n                options,\r\n            )\r\n            this.#network = staticNetwork\r\n        }\r\n    }\r\n    _getOption(key) {\r\n        return this.#options[key]\r\n    }\r\n    get _network() {\r\n        assert(this.#network, \"network is not available yet\", \"NETWORK_ERROR\")\r\n        return this.#network\r\n    }\r\n    async _perform(req) {\r\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\r\n            let tx = req.transaction\r\n            if (tx && tx.type != null && getBigInt(tx.type)) {\r\n                if (\r\n                    tx.maxFeePerGas == null &&\r\n                    tx.maxPriorityFeePerGas == null\r\n                ) {\r\n                    const feeData = await this.getFeeData()\r\n                    if (\r\n                        feeData.maxFeePerGas == null &&\r\n                        feeData.maxPriorityFeePerGas == null\r\n                    ) {\r\n                        req = Object.assign({}, req, {\r\n                            transaction: Object.assign({}, tx, {\r\n                                type: undefined,\r\n                            }),\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const request = this.getRpcRequest(req)\r\n        if (request != null) {\r\n            return await this.send(request.method, request.args)\r\n        }\r\n        return super._perform(req)\r\n    }\r\n    async _detectNetwork() {\r\n        const network = this._getOption(\"staticNetwork\")\r\n        if (network) {\r\n            if (network === true) {\r\n                if (this.#network) {\r\n                    return this.#network\r\n                }\r\n            } else {\r\n                return network\r\n            }\r\n        }\r\n        if (this.#pendingDetectNetwork) {\r\n            return await this.#pendingDetectNetwork\r\n        }\r\n        if (this.ready) {\r\n            this.#pendingDetectNetwork = (async () => {\r\n                try {\r\n                    const result = Network.from(\r\n                        getBigInt(await this.send(\"eth_chainId\", [])),\r\n                    )\r\n                    this.#pendingDetectNetwork = null\r\n                    return result\r\n                } catch (error) {\r\n                    this.#pendingDetectNetwork = null\r\n                    throw error\r\n                }\r\n            })()\r\n            return await this.#pendingDetectNetwork\r\n        }\r\n        this.#pendingDetectNetwork = (async () => {\r\n            const payload = {\r\n                id: this.#nextId++,\r\n                method: \"eth_chainId\",\r\n                params: [],\r\n                jsonrpc: \"2.0\",\r\n            }\r\n            this.emit(\"debug\", {\r\n                action: \"sendRpcPayload\",\r\n                payload: payload,\r\n            })\r\n            let result\r\n            try {\r\n                result = (await this._send(payload))[0]\r\n                this.#pendingDetectNetwork = null\r\n            } catch (error) {\r\n                this.#pendingDetectNetwork = null\r\n                this.emit(\"debug\", {\r\n                    action: \"receiveRpcError\",\r\n                    error: error,\r\n                })\r\n                throw error\r\n            }\r\n            this.emit(\"debug\", {\r\n                action: \"receiveRpcResult\",\r\n                result: result,\r\n            })\r\n            if (\"result\" in result) {\r\n                return Network.from(getBigInt(result.result))\r\n            }\r\n            throw this.getRpcError(payload, result)\r\n        })()\r\n        return await this.#pendingDetectNetwork\r\n    }\r\n    _start() {\r\n        if (this.#notReady == null || this.#notReady.resolve == null) {\r\n            return\r\n        }\r\n        this.#notReady.resolve()\r\n        this.#notReady = null\r\n        ;(async () => {\r\n            while (this.#network == null && !this.destroyed) {\r\n                try {\r\n                    this.#network = await this._detectNetwork()\r\n                } catch (error) {\r\n                    if (this.destroyed) {\r\n                        break\r\n                    }\r\n                    console.log(\r\n                        \"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\",\r\n                    )\r\n                    this.emit(\r\n                        \"error\",\r\n                        makeError(\r\n                            \"failed to bootstrap network detection\",\r\n                            \"NETWORK_ERROR\",\r\n                            {\r\n                                event: \"initial-network-discovery\",\r\n                                info: {\r\n                                    error: error,\r\n                                },\r\n                            },\r\n                        ),\r\n                    )\r\n                    await stall$3(1e3)\r\n                }\r\n            }\r\n            this.#scheduleDrain()\r\n        })()\r\n    }\r\n    async _waitUntilReady() {\r\n        if (this.#notReady == null) {\r\n            return\r\n        }\r\n        return await this.#notReady.promise\r\n    }\r\n    _getSubscriber(sub) {\r\n        if (sub.type === \"pending\") {\r\n            return new FilterIdPendingSubscriber(this)\r\n        }\r\n        if (sub.type === \"event\") {\r\n            if (this._getOption(\"polling\")) {\r\n                return new PollingEventSubscriber(this, sub.filter)\r\n            }\r\n            return new FilterIdEventSubscriber(this, sub.filter)\r\n        }\r\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\r\n            return new UnmanagedSubscriber(\"orphan\")\r\n        }\r\n        return super._getSubscriber(sub)\r\n    }\r\n    get ready() {\r\n        return this.#notReady == null\r\n    }\r\n    getRpcTransaction(tx) {\r\n        const result = {}\r\n        ;[\r\n            \"chainId\",\r\n            \"gasLimit\",\r\n            \"gasPrice\",\r\n            \"type\",\r\n            \"maxFeePerGas\",\r\n            \"maxPriorityFeePerGas\",\r\n            \"nonce\",\r\n            \"value\",\r\n        ].forEach((key) => {\r\n            if (tx[key] == null) {\r\n                return\r\n            }\r\n            let dstKey = key\r\n            if (key === \"gasLimit\") {\r\n                dstKey = \"gas\"\r\n            }\r\n            result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`))\r\n        })\r\n        ;[\"from\", \"to\", \"data\"].forEach((key) => {\r\n            if (tx[key] == null) {\r\n                return\r\n            }\r\n            result[key] = hexlify(tx[key])\r\n        })\r\n        if (tx.accessList) {\r\n            result[\"accessList\"] = accessListify(tx.accessList)\r\n        }\r\n        return result\r\n    }\r\n    getRpcRequest(req) {\r\n        switch (req.method) {\r\n            case \"chainId\":\r\n                return {\r\n                    method: \"eth_chainId\",\r\n                    args: [],\r\n                }\r\n            case \"getBlockNumber\":\r\n                return {\r\n                    method: \"eth_blockNumber\",\r\n                    args: [],\r\n                }\r\n            case \"getGasPrice\":\r\n                return {\r\n                    method: \"eth_gasPrice\",\r\n                    args: [],\r\n                }\r\n            case \"getPriorityFee\":\r\n                return {\r\n                    method: \"eth_maxPriorityFeePerGas\",\r\n                    args: [],\r\n                }\r\n            case \"getBalance\":\r\n                return {\r\n                    method: \"eth_getBalance\",\r\n                    args: [getLowerCase(req.address), req.blockTag],\r\n                }\r\n            case \"getTransactionCount\":\r\n                return {\r\n                    method: \"eth_getTransactionCount\",\r\n                    args: [getLowerCase(req.address), req.blockTag],\r\n                }\r\n            case \"getCode\":\r\n                return {\r\n                    method: \"eth_getCode\",\r\n                    args: [getLowerCase(req.address), req.blockTag],\r\n                }\r\n            case \"getStorage\":\r\n                return {\r\n                    method: \"eth_getStorageAt\",\r\n                    args: [\r\n                        getLowerCase(req.address),\r\n                        \"0x\" + req.position.toString(16),\r\n                        req.blockTag,\r\n                    ],\r\n                }\r\n            case \"broadcastTransaction\":\r\n                return {\r\n                    method: \"eth_sendRawTransaction\",\r\n                    args: [req.signedTransaction],\r\n                }\r\n            case \"getBlock\":\r\n                if (\"blockTag\" in req) {\r\n                    return {\r\n                        method: \"eth_getBlockByNumber\",\r\n                        args: [req.blockTag, !!req.includeTransactions],\r\n                    }\r\n                } else if (\"blockHash\" in req) {\r\n                    return {\r\n                        method: \"eth_getBlockByHash\",\r\n                        args: [req.blockHash, !!req.includeTransactions],\r\n                    }\r\n                }\r\n                break\r\n            case \"getTransaction\":\r\n                return {\r\n                    method: \"eth_getTransactionByHash\",\r\n                    args: [req.hash],\r\n                }\r\n            case \"getTransactionReceipt\":\r\n                return {\r\n                    method: \"eth_getTransactionReceipt\",\r\n                    args: [req.hash],\r\n                }\r\n            case \"call\":\r\n                return {\r\n                    method: \"eth_call\",\r\n                    args: [\r\n                        this.getRpcTransaction(req.transaction),\r\n                        req.blockTag,\r\n                    ],\r\n                }\r\n            case \"estimateGas\": {\r\n                return {\r\n                    method: \"eth_estimateGas\",\r\n                    args: [this.getRpcTransaction(req.transaction)],\r\n                }\r\n            }\r\n            case \"getLogs\":\r\n                if (req.filter && req.filter.address != null) {\r\n                    if (Array.isArray(req.filter.address)) {\r\n                        req.filter.address =\r\n                            req.filter.address.map(getLowerCase)\r\n                    } else {\r\n                        req.filter.address = getLowerCase(req.filter.address)\r\n                    }\r\n                }\r\n                return {\r\n                    method: \"eth_getLogs\",\r\n                    args: [req.filter],\r\n                }\r\n        }\r\n        return null\r\n    }\r\n    getRpcError(payload, _error) {\r\n        const { method } = payload\r\n        const { error } = _error\r\n        if (method === \"eth_estimateGas\" && error.message) {\r\n            const msg = error.message\r\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\r\n                return makeError(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\r\n                    transaction: payload.params[0],\r\n                    info: {\r\n                        payload: payload,\r\n                        error: error,\r\n                    },\r\n                })\r\n            }\r\n        }\r\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\r\n            const result = spelunkData(error)\r\n            const e = AbiCoder.getBuiltinCallException(\r\n                method === \"eth_call\" ? \"call\" : \"estimateGas\",\r\n                payload.params[0],\r\n                result ? result.data : null,\r\n            )\r\n            e.info = {\r\n                error: error,\r\n                payload: payload,\r\n            }\r\n            return e\r\n        }\r\n        const message = JSON.stringify(spelunkMessage(error))\r\n        if (\r\n            typeof error.message === \"string\" &&\r\n            error.message.match(/user denied|ethers-user-denied/i)\r\n        ) {\r\n            const actionMap = {\r\n                eth_sign: \"signMessage\",\r\n                personal_sign: \"signMessage\",\r\n                eth_signTypedData_v4: \"signTypedData\",\r\n                eth_signTransaction: \"signTransaction\",\r\n                eth_sendTransaction: \"sendTransaction\",\r\n                eth_requestAccounts: \"requestAccess\",\r\n                wallet_requestAccounts: \"requestAccess\",\r\n            }\r\n            return makeError(`user rejected action`, \"ACTION_REJECTED\", {\r\n                action: actionMap[method] || \"unknown\",\r\n                reason: \"rejected\",\r\n                info: {\r\n                    payload: payload,\r\n                    error: error,\r\n                },\r\n            })\r\n        }\r\n        if (\r\n            method === \"eth_sendRawTransaction\" ||\r\n            method === \"eth_sendTransaction\"\r\n        ) {\r\n            const transaction = payload.params[0]\r\n            if (\r\n                message.match(/insufficient funds|base fee exceeds gas limit/i)\r\n            ) {\r\n                return makeError(\r\n                    \"insufficient funds for intrinsic transaction cost\",\r\n                    \"INSUFFICIENT_FUNDS\",\r\n                    {\r\n                        transaction: transaction,\r\n                        info: {\r\n                            error: error,\r\n                        },\r\n                    },\r\n                )\r\n            }\r\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\r\n                return makeError(\r\n                    \"nonce has already been used\",\r\n                    \"NONCE_EXPIRED\",\r\n                    {\r\n                        transaction: transaction,\r\n                        info: {\r\n                            error: error,\r\n                        },\r\n                    },\r\n                )\r\n            }\r\n            if (\r\n                message.match(/replacement transaction/i) &&\r\n                message.match(/underpriced/i)\r\n            ) {\r\n                return makeError(\r\n                    \"replacement fee too low\",\r\n                    \"REPLACEMENT_UNDERPRICED\",\r\n                    {\r\n                        transaction: transaction,\r\n                        info: {\r\n                            error: error,\r\n                        },\r\n                    },\r\n                )\r\n            }\r\n            if (message.match(/only replay-protected/i)) {\r\n                return makeError(\r\n                    \"legacy pre-eip-155 transactions not supported\",\r\n                    \"UNSUPPORTED_OPERATION\",\r\n                    {\r\n                        operation: method,\r\n                        info: {\r\n                            transaction: transaction,\r\n                            info: {\r\n                                error: error,\r\n                            },\r\n                        },\r\n                    },\r\n                )\r\n            }\r\n        }\r\n        let unsupported = !!message.match(/the method .* does not exist/i)\r\n        if (!unsupported) {\r\n            if (\r\n                error &&\r\n                error.details &&\r\n                error.details.startsWith(\"Unauthorized method:\")\r\n            ) {\r\n                unsupported = true\r\n            }\r\n        }\r\n        if (unsupported) {\r\n            return makeError(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\r\n                operation: payload.method,\r\n                info: {\r\n                    error: error,\r\n                    payload: payload,\r\n                },\r\n            })\r\n        }\r\n        return makeError(\"could not coalesce error\", \"UNKNOWN_ERROR\", {\r\n            error: error,\r\n            payload: payload,\r\n        })\r\n    }\r\n    send(method, params) {\r\n        if (this.destroyed) {\r\n            return Promise.reject(\r\n                makeError(\r\n                    \"provider destroyed; cancelled request\",\r\n                    \"UNSUPPORTED_OPERATION\",\r\n                    {\r\n                        operation: method,\r\n                    },\r\n                ),\r\n            )\r\n        }\r\n        const id = this.#nextId++\r\n        const promise = new Promise((resolve, reject) => {\r\n            this.#payloads.push({\r\n                resolve: resolve,\r\n                reject: reject,\r\n                payload: {\r\n                    method: method,\r\n                    params: params,\r\n                    id: id,\r\n                    jsonrpc: \"2.0\",\r\n                },\r\n            })\r\n        })\r\n        this.#scheduleDrain()\r\n        return promise\r\n    }\r\n    async getSigner(address) {\r\n        if (address == null) {\r\n            address = 0\r\n        }\r\n        const accountsPromise = this.send(\"eth_accounts\", [])\r\n        if (typeof address === \"number\") {\r\n            const accounts = await accountsPromise\r\n            if (address >= accounts.length) {\r\n                throw new Error(\"no such account\")\r\n            }\r\n            return new JsonRpcSigner(this, accounts[address])\r\n        }\r\n        const { accounts } = await resolveProperties({\r\n            network: this.getNetwork(),\r\n            accounts: accountsPromise,\r\n        })\r\n        address = getAddress(address)\r\n        for (const account of accounts) {\r\n            if (getAddress(account) === address) {\r\n                return new JsonRpcSigner(this, address)\r\n            }\r\n        }\r\n        throw new Error(\"invalid account\")\r\n    }\r\n    async listAccounts() {\r\n        const accounts = await this.send(\"eth_accounts\", [])\r\n        return accounts.map((a) => new JsonRpcSigner(this, a))\r\n    }\r\n    destroy() {\r\n        if (this.#drainTimer) {\r\n            clearTimeout(this.#drainTimer)\r\n            this.#drainTimer = null\r\n        }\r\n        for (const { payload, reject } of this.#payloads) {\r\n            reject(\r\n                makeError(\r\n                    \"provider destroyed; cancelled request\",\r\n                    \"UNSUPPORTED_OPERATION\",\r\n                    {\r\n                        operation: payload.method,\r\n                    },\r\n                ),\r\n            )\r\n        }\r\n        this.#payloads = []\r\n        super.destroy()\r\n    }\r\n}\r\nclass JsonRpcApiPollingProvider extends JsonRpcApiProvider {\r\n    #pollingInterval\r\n    constructor(network, options) {\r\n        super(network, options)\r\n        this.#pollingInterval = 4e3\r\n    }\r\n    _getSubscriber(sub) {\r\n        const subscriber = super._getSubscriber(sub)\r\n        if (isPollable(subscriber)) {\r\n            subscriber.pollingInterval = this.#pollingInterval\r\n        }\r\n        return subscriber\r\n    }\r\n    get pollingInterval() {\r\n        return this.#pollingInterval\r\n    }\r\n    set pollingInterval(value) {\r\n        if (!Number.isInteger(value) || value < 0) {\r\n            throw new Error(\"invalid interval\")\r\n        }\r\n        this.#pollingInterval = value\r\n        this._forEachSubscriber((sub) => {\r\n            if (isPollable(sub)) {\r\n                sub.pollingInterval = this.#pollingInterval\r\n            }\r\n        })\r\n    }\r\n}\r\nclass JsonRpcProvider extends JsonRpcApiPollingProvider {\r\n    #connect\r\n    constructor(url, network, options) {\r\n        if (url == null) {\r\n            url = \"http://localhost:8545\"\r\n        }\r\n        super(network, options)\r\n        if (typeof url === \"string\") {\r\n            this.#connect = new FetchRequest(url)\r\n        } else {\r\n            this.#connect = url.clone()\r\n        }\r\n    }\r\n    _getConnection() {\r\n        return this.#connect.clone()\r\n    }\r\n    async send(method, params) {\r\n        await this._start()\r\n        return await super.send(method, params)\r\n    }\r\n    async _send(payload) {\r\n        const request = this._getConnection()\r\n        request.body = JSON.stringify(payload)\r\n        request.setHeader(\"content-type\", \"application/json\")\r\n        const response = await request.send()\r\n        response.assertOk()\r\n        let resp = response.bodyJson\r\n        if (!Array.isArray(resp)) {\r\n            resp = [resp]\r\n        }\r\n        return resp\r\n    }\r\n}\r\nfunction spelunkData(value) {\r\n    if (value == null) {\r\n        return null\r\n    }\r\n    if (\r\n        typeof value.message === \"string\" &&\r\n        value.message.match(/revert/i) &&\r\n        isHexString(value.data)\r\n    ) {\r\n        return {\r\n            message: value.message,\r\n            data: value.data,\r\n        }\r\n    }\r\n    if (typeof value === \"object\") {\r\n        for (const key in value) {\r\n            const result = spelunkData(value[key])\r\n            if (result) {\r\n                return result\r\n            }\r\n        }\r\n        return null\r\n    }\r\n    if (typeof value === \"string\") {\r\n        try {\r\n            return spelunkData(JSON.parse(value))\r\n        } catch (error) {}\r\n    }\r\n    return null\r\n}\r\nfunction _spelunkMessage(value, result) {\r\n    if (value == null) {\r\n        return\r\n    }\r\n    if (typeof value.message === \"string\") {\r\n        result.push(value.message)\r\n    }\r\n    if (typeof value === \"object\") {\r\n        for (const key in value) {\r\n            _spelunkMessage(value[key], result)\r\n        }\r\n    }\r\n    if (typeof value === \"string\") {\r\n        try {\r\n            return _spelunkMessage(JSON.parse(value), result)\r\n        } catch (error) {}\r\n    }\r\n}\r\nfunction spelunkMessage(value) {\r\n    const result = []\r\n    _spelunkMessage(value, result)\r\n    return result\r\n}\r\nconst defaultApiKey$1 =\r\n    \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\"\r\nfunction getHost$4(name) {\r\n    switch (name) {\r\n        case \"mainnet\":\r\n            return \"rpc.ankr.com/eth\"\r\n        case \"goerli\":\r\n            return \"rpc.ankr.com/eth_goerli\"\r\n        case \"matic\":\r\n            return \"rpc.ankr.com/polygon\"\r\n        case \"arbitrum\":\r\n            return \"rpc.ankr.com/arbitrum\"\r\n    }\r\n    assertArgument(false, \"unsupported network\", \"network\", name)\r\n}\r\nclass AnkrProvider extends JsonRpcProvider {\r\n    apiKey\r\n    constructor(_network, apiKey) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\"\r\n        }\r\n        const network = Network.from(_network)\r\n        if (apiKey == null) {\r\n            apiKey = defaultApiKey$1\r\n        }\r\n        const options = {\r\n            polling: true,\r\n            staticNetwork: network,\r\n        }\r\n        const request = AnkrProvider.getRequest(network, apiKey)\r\n        super(request, network, options)\r\n        defineProperties(this, {\r\n            apiKey: apiKey,\r\n        })\r\n    }\r\n    _getProvider(chainId) {\r\n        try {\r\n            return new AnkrProvider(chainId, this.apiKey)\r\n        } catch (error) {}\r\n        return super._getProvider(chainId)\r\n    }\r\n    static getRequest(network, apiKey) {\r\n        if (apiKey == null) {\r\n            apiKey = defaultApiKey$1\r\n        }\r\n        const request = new FetchRequest(\r\n            `https:/\\/${getHost$4(network.name)}/${apiKey}`,\r\n        )\r\n        request.allowGzip = true\r\n        if (apiKey === defaultApiKey$1) {\r\n            request.retryFunc = async (request, response, attempt) => {\r\n                showThrottleMessage(\"AnkrProvider\")\r\n                return true\r\n            }\r\n        }\r\n        return request\r\n    }\r\n    getRpcError(payload, error) {\r\n        if (payload.method === \"eth_sendRawTransaction\") {\r\n            if (\r\n                error &&\r\n                error.error &&\r\n                error.error.message ===\r\n                    \"INTERNAL_ERROR: could not replace existing tx\"\r\n            ) {\r\n                error.error.message = \"replacement transaction underpriced\"\r\n            }\r\n        }\r\n        return super.getRpcError(payload, error)\r\n    }\r\n    isCommunityResource() {\r\n        return this.apiKey === defaultApiKey$1\r\n    }\r\n}\r\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\"\r\nfunction getHost$3(name) {\r\n    switch (name) {\r\n        case \"mainnet\":\r\n            return \"eth-mainnet.alchemyapi.io\"\r\n        case \"goerli\":\r\n            return \"eth-goerli.g.alchemy.com\"\r\n        case \"sepolia\":\r\n            return \"eth-sepolia.g.alchemy.com\"\r\n        case \"arbitrum\":\r\n            return \"arb-mainnet.g.alchemy.com\"\r\n        case \"arbitrum-goerli\":\r\n            return \"arb-goerli.g.alchemy.com\"\r\n        case \"base\":\r\n            return \"base-mainnet.g.alchemy.com\"\r\n        case \"base-goerli\":\r\n            return \"base-goerli.g.alchemy.com\"\r\n        case \"matic\":\r\n            return \"polygon-mainnet.g.alchemy.com\"\r\n        case \"matic-mumbai\":\r\n            return \"polygon-mumbai.g.alchemy.com\"\r\n        case \"optimism\":\r\n            return \"opt-mainnet.g.alchemy.com\"\r\n        case \"optimism-goerli\":\r\n            return \"opt-goerli.g.alchemy.com\"\r\n    }\r\n    assertArgument(false, \"unsupported network\", \"network\", name)\r\n}\r\nclass AlchemyProvider extends JsonRpcProvider {\r\n    apiKey\r\n    constructor(_network, apiKey) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\"\r\n        }\r\n        const network = Network.from(_network)\r\n        if (apiKey == null) {\r\n            apiKey = defaultApiKey\r\n        }\r\n        const request = AlchemyProvider.getRequest(network, apiKey)\r\n        super(request, network, {\r\n            staticNetwork: network,\r\n        })\r\n        defineProperties(this, {\r\n            apiKey: apiKey,\r\n        })\r\n    }\r\n    _getProvider(chainId) {\r\n        try {\r\n            return new AlchemyProvider(chainId, this.apiKey)\r\n        } catch (error) {}\r\n        return super._getProvider(chainId)\r\n    }\r\n    async _perform(req) {\r\n        if (req.method === \"getTransactionResult\") {\r\n            const { trace, tx } = await resolveProperties({\r\n                trace: this.send(\"trace_transaction\", [req.hash]),\r\n                tx: this.getTransaction(req.hash),\r\n            })\r\n            if (trace == null || tx == null) {\r\n                return null\r\n            }\r\n            let data\r\n            let error = false\r\n            try {\r\n                data = trace[0].result.output\r\n                error = trace[0].error === \"Reverted\"\r\n            } catch (error) {}\r\n            if (data) {\r\n                assert(\r\n                    !error,\r\n                    \"an error occurred during transaction executions\",\r\n                    \"CALL_EXCEPTION\",\r\n                    {\r\n                        action: \"getTransactionResult\",\r\n                        data: data,\r\n                        reason: null,\r\n                        transaction: tx,\r\n                        invocation: null,\r\n                        revert: null,\r\n                    },\r\n                )\r\n                return data\r\n            }\r\n            assert(false, \"could not parse trace result\", \"BAD_DATA\", {\r\n                value: trace,\r\n            })\r\n        }\r\n        return await super._perform(req)\r\n    }\r\n    isCommunityResource() {\r\n        return this.apiKey === defaultApiKey\r\n    }\r\n    static getRequest(network, apiKey) {\r\n        if (apiKey == null) {\r\n            apiKey = defaultApiKey\r\n        }\r\n        const request = new FetchRequest(\r\n            `https:/\\/${getHost$3(network.name)}/v2/${apiKey}`,\r\n        )\r\n        request.allowGzip = true\r\n        if (apiKey === defaultApiKey) {\r\n            request.retryFunc = async (request, response, attempt) => {\r\n                showThrottleMessage(\"alchemy\")\r\n                return true\r\n            }\r\n        }\r\n        return request\r\n    }\r\n}\r\nclass CloudflareProvider extends JsonRpcProvider {\r\n    constructor(_network) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\"\r\n        }\r\n        const network = Network.from(_network)\r\n        assertArgument(\r\n            network.name === \"mainnet\",\r\n            \"unsupported network\",\r\n            \"network\",\r\n            _network,\r\n        )\r\n        super(\"https://cloudflare-eth.com/\", network, {\r\n            staticNetwork: network,\r\n        })\r\n    }\r\n}\r\nconst THROTTLE = 2e3\r\nfunction isPromise(value) {\r\n    return value && typeof value.then === \"function\"\r\n}\r\nconst EtherscanPluginId = \"org.ethers.plugins.provider.Etherscan\"\r\nclass EtherscanPlugin extends NetworkPlugin {\r\n    baseUrl\r\n    constructor(baseUrl) {\r\n        super(EtherscanPluginId)\r\n        defineProperties(this, {\r\n            baseUrl: baseUrl,\r\n        })\r\n    }\r\n    clone() {\r\n        return new EtherscanPlugin(this.baseUrl)\r\n    }\r\n}\r\nconst skipKeys = [\"enableCcipRead\"]\r\nlet nextId = 1\r\nclass EtherscanProvider extends AbstractProvider {\r\n    network\r\n    apiKey\r\n    #plugin\r\n    constructor(_network, _apiKey) {\r\n        const apiKey = _apiKey != null ? _apiKey : null\r\n        super()\r\n        const network = Network.from(_network)\r\n        this.#plugin = network.getPlugin(EtherscanPluginId)\r\n        defineProperties(this, {\r\n            apiKey: apiKey,\r\n            network: network,\r\n        })\r\n        this.getBaseUrl()\r\n    }\r\n    getBaseUrl() {\r\n        if (this.#plugin) {\r\n            return this.#plugin.baseUrl\r\n        }\r\n        switch (this.network.name) {\r\n            case \"mainnet\":\r\n                return \"https://api.etherscan.io\"\r\n            case \"goerli\":\r\n                return \"https://api-goerli.etherscan.io\"\r\n            case \"sepolia\":\r\n                return \"https://api-sepolia.etherscan.io\"\r\n            case \"arbitrum\":\r\n                return \"https://api.arbiscan.io\"\r\n            case \"arbitrum-goerli\":\r\n                return \"https://api-goerli.arbiscan.io\"\r\n            case \"matic\":\r\n                return \"https://api.polygonscan.com\"\r\n            case \"matic-mumbai\":\r\n                return \"https://api-testnet.polygonscan.com\"\r\n            case \"optimism\":\r\n                return \"https://api-optimistic.etherscan.io\"\r\n            case \"optimism-goerli\":\r\n                return \"https://api-goerli-optimistic.etherscan.io\"\r\n            case \"bnb\":\r\n                return \"http://api.bscscan.com\"\r\n            case \"bnbt\":\r\n                return \"http://api-testnet.bscscan.com\"\r\n        }\r\n        assertArgument(false, \"unsupported network\", \"network\", this.network)\r\n    }\r\n    getUrl(module, params) {\r\n        const query = Object.keys(params).reduce((accum, key) => {\r\n            const value = params[key]\r\n            if (value != null) {\r\n                accum += `&${key}=${value}`\r\n            }\r\n            return accum\r\n        }, \"\")\r\n        const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : \"\"\r\n        return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`\r\n    }\r\n    getPostUrl() {\r\n        return `${this.getBaseUrl()}/api`\r\n    }\r\n    getPostData(module, params) {\r\n        params.module = module\r\n        params.apikey = this.apiKey\r\n        return params\r\n    }\r\n    async detectNetwork() {\r\n        return this.network\r\n    }\r\n    async fetch(module, params, post) {\r\n        const id = nextId++\r\n        const url = post ? this.getPostUrl() : this.getUrl(module, params)\r\n        const payload = post ? this.getPostData(module, params) : null\r\n        this.emit(\"debug\", {\r\n            action: \"sendRequest\",\r\n            id: id,\r\n            url: url,\r\n            payload: payload,\r\n        })\r\n        const request = new FetchRequest(url)\r\n        request.setThrottleParams({\r\n            slotInterval: 1e3,\r\n        })\r\n        request.retryFunc = (req, resp, attempt) => {\r\n            if (this.isCommunityResource()) {\r\n                showThrottleMessage(\"Etherscan\")\r\n            }\r\n            return Promise.resolve(true)\r\n        }\r\n        request.processFunc = async (request, response) => {\r\n            const result = response.hasBody()\r\n                ? JSON.parse(toUtf8String(response.body))\r\n                : {}\r\n            const throttle =\r\n                (typeof result.result === \"string\" ? result.result : \"\")\r\n                    .toLowerCase()\r\n                    .indexOf(\"rate limit\") >= 0\r\n            if (module === \"proxy\") {\r\n                if (\r\n                    result &&\r\n                    result.status == 0 &&\r\n                    result.message == \"NOTOK\" &&\r\n                    throttle\r\n                ) {\r\n                    this.emit(\"debug\", {\r\n                        action: \"receiveError\",\r\n                        id: id,\r\n                        reason: \"proxy-NOTOK\",\r\n                        error: result,\r\n                    })\r\n                    response.throwThrottleError(result.result, THROTTLE)\r\n                }\r\n            } else {\r\n                if (throttle) {\r\n                    this.emit(\"debug\", {\r\n                        action: \"receiveError\",\r\n                        id: id,\r\n                        reason: \"null result\",\r\n                        error: result.result,\r\n                    })\r\n                    response.throwThrottleError(result.result, THROTTLE)\r\n                }\r\n            }\r\n            return response\r\n        }\r\n        if (payload) {\r\n            request.setHeader(\r\n                \"content-type\",\r\n                \"application/x-www-form-urlencoded; charset=UTF-8\",\r\n            )\r\n            request.body = Object.keys(payload)\r\n                .map((k) => `${k}=${payload[k]}`)\r\n                .join(\"&\")\r\n        }\r\n        const response = await request.send()\r\n        try {\r\n            response.assertOk()\r\n        } catch (error) {\r\n            this.emit(\"debug\", {\r\n                action: \"receiveError\",\r\n                id: id,\r\n                error: error,\r\n                reason: \"assertOk\",\r\n            })\r\n            assert(false, \"response error\", \"SERVER_ERROR\", {\r\n                request: request,\r\n                response: response,\r\n            })\r\n        }\r\n        if (!response.hasBody()) {\r\n            this.emit(\"debug\", {\r\n                action: \"receiveError\",\r\n                id: id,\r\n                error: \"missing body\",\r\n                reason: \"null body\",\r\n            })\r\n            assert(false, \"missing response\", \"SERVER_ERROR\", {\r\n                request: request,\r\n                response: response,\r\n            })\r\n        }\r\n        const result = JSON.parse(toUtf8String(response.body))\r\n        if (module === \"proxy\") {\r\n            if (result.jsonrpc != \"2.0\") {\r\n                this.emit(\"debug\", {\r\n                    action: \"receiveError\",\r\n                    id: id,\r\n                    result: result,\r\n                    reason: \"invalid JSON-RPC\",\r\n                })\r\n                assert(\r\n                    false,\r\n                    \"invalid JSON-RPC response (missing jsonrpc='2.0')\",\r\n                    \"SERVER_ERROR\",\r\n                    {\r\n                        request: request,\r\n                        response: response,\r\n                        info: {\r\n                            result: result,\r\n                        },\r\n                    },\r\n                )\r\n            }\r\n            if (result.error) {\r\n                this.emit(\"debug\", {\r\n                    action: \"receiveError\",\r\n                    id: id,\r\n                    result: result,\r\n                    reason: \"JSON-RPC error\",\r\n                })\r\n                assert(false, \"error response\", \"SERVER_ERROR\", {\r\n                    request: request,\r\n                    response: response,\r\n                    info: {\r\n                        result: result,\r\n                    },\r\n                })\r\n            }\r\n            this.emit(\"debug\", {\r\n                action: \"receiveRequest\",\r\n                id: id,\r\n                result: result,\r\n            })\r\n            return result.result\r\n        } else {\r\n            if (\r\n                result.status == 0 &&\r\n                (result.message === \"No records found\" ||\r\n                    result.message === \"No transactions found\")\r\n            ) {\r\n                this.emit(\"debug\", {\r\n                    action: \"receiveRequest\",\r\n                    id: id,\r\n                    result: result,\r\n                })\r\n                return result.result\r\n            }\r\n            if (\r\n                result.status != 1 ||\r\n                (typeof result.message === \"string\" &&\r\n                    !result.message.match(/^OK/))\r\n            ) {\r\n                this.emit(\"debug\", {\r\n                    action: \"receiveError\",\r\n                    id: id,\r\n                    result: result,\r\n                })\r\n                assert(false, \"error response\", \"SERVER_ERROR\", {\r\n                    request: request,\r\n                    response: response,\r\n                    info: {\r\n                        result: result,\r\n                    },\r\n                })\r\n            }\r\n            this.emit(\"debug\", {\r\n                action: \"receiveRequest\",\r\n                id: id,\r\n                result: result,\r\n            })\r\n            return result.result\r\n        }\r\n    }\r\n    _getTransactionPostData(transaction) {\r\n        const result = {}\r\n        for (let key in transaction) {\r\n            if (skipKeys.indexOf(key) >= 0) {\r\n                continue\r\n            }\r\n            if (transaction[key] == null) {\r\n                continue\r\n            }\r\n            let value = transaction[key]\r\n            if (key === \"type\" && value === 0) {\r\n                continue\r\n            }\r\n            if (key === \"blockTag\" && value === \"latest\") {\r\n                continue\r\n            }\r\n            if (\r\n                {\r\n                    type: true,\r\n                    gasLimit: true,\r\n                    gasPrice: true,\r\n                    maxFeePerGs: true,\r\n                    maxPriorityFeePerGas: true,\r\n                    nonce: true,\r\n                    value: true,\r\n                }[key]\r\n            ) {\r\n                value = toQuantity(value)\r\n            } else if (key === \"accessList\") {\r\n                value =\r\n                    \"[\" +\r\n                    accessListify(value)\r\n                        .map((set) => {\r\n                            return `{address:\"${\r\n                                set.address\r\n                            }\",storageKeys:[\"${set.storageKeys.join('\",\"')}\"]}`\r\n                        })\r\n                        .join(\",\") +\r\n                    \"]\"\r\n            } else {\r\n                value = hexlify(value)\r\n            }\r\n            result[key] = value\r\n        }\r\n        return result\r\n    }\r\n    _checkError(req, error, transaction) {\r\n        let message = \"\"\r\n        if (isError(error, \"SERVER_ERROR\")) {\r\n            try {\r\n                message = error.info.result.error.message\r\n            } catch (e) {}\r\n            if (!message) {\r\n                try {\r\n                    message = error.info.message\r\n                } catch (e) {}\r\n            }\r\n        }\r\n        if (req.method === \"estimateGas\") {\r\n            if (\r\n                !message.match(/revert/i) &&\r\n                message.match(/insufficient funds/i)\r\n            ) {\r\n                assert(false, \"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\r\n                    transaction: req.transaction,\r\n                })\r\n            }\r\n        }\r\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\r\n            if (message.match(/execution reverted/i)) {\r\n                let data = \"\"\r\n                try {\r\n                    data = error.info.result.error.data\r\n                } catch (error) {}\r\n                const e = AbiCoder.getBuiltinCallException(\r\n                    req.method,\r\n                    req.transaction,\r\n                    data,\r\n                )\r\n                e.info = {\r\n                    request: req,\r\n                    error: error,\r\n                }\r\n                throw e\r\n            }\r\n        }\r\n        if (message) {\r\n            if (req.method === \"broadcastTransaction\") {\r\n                const transaction = Transaction.from(req.signedTransaction)\r\n                if (\r\n                    message.match(/replacement/i) &&\r\n                    message.match(/underpriced/i)\r\n                ) {\r\n                    assert(\r\n                        false,\r\n                        \"replacement fee too low\",\r\n                        \"REPLACEMENT_UNDERPRICED\",\r\n                        {\r\n                            transaction: transaction,\r\n                        },\r\n                    )\r\n                }\r\n                if (message.match(/insufficient funds/)) {\r\n                    assert(\r\n                        false,\r\n                        \"insufficient funds for intrinsic transaction cost\",\r\n                        \"INSUFFICIENT_FUNDS\",\r\n                        {\r\n                            transaction: transaction,\r\n                        },\r\n                    )\r\n                }\r\n                if (\r\n                    message.match(\r\n                        /same hash was already imported|transaction nonce is too low|nonce too low/,\r\n                    )\r\n                ) {\r\n                    assert(\r\n                        false,\r\n                        \"nonce has already been used\",\r\n                        \"NONCE_EXPIRED\",\r\n                        {\r\n                            transaction: transaction,\r\n                        },\r\n                    )\r\n                }\r\n            }\r\n        }\r\n        throw error\r\n    }\r\n    async _detectNetwork() {\r\n        return this.network\r\n    }\r\n    async _perform(req) {\r\n        switch (req.method) {\r\n            case \"chainId\":\r\n                return this.network.chainId\r\n            case \"getBlockNumber\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_blockNumber\",\r\n                })\r\n            case \"getGasPrice\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_gasPrice\",\r\n                })\r\n            case \"getPriorityFee\":\r\n                if (this.network.name === \"mainnet\") {\r\n                    return \"1000000000\"\r\n                } else if (this.network.name === \"optimism\") {\r\n                    return \"1000000\"\r\n                } else {\r\n                    throw new Error(\r\n                        \"fallback onto the AbstractProvider default\",\r\n                    )\r\n                }\r\n            case \"getBalance\":\r\n                return this.fetch(\"account\", {\r\n                    action: \"balance\",\r\n                    address: req.address,\r\n                    tag: req.blockTag,\r\n                })\r\n            case \"getTransactionCount\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getTransactionCount\",\r\n                    address: req.address,\r\n                    tag: req.blockTag,\r\n                })\r\n            case \"getCode\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getCode\",\r\n                    address: req.address,\r\n                    tag: req.blockTag,\r\n                })\r\n            case \"getStorage\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getStorageAt\",\r\n                    address: req.address,\r\n                    position: req.position,\r\n                    tag: req.blockTag,\r\n                })\r\n            case \"broadcastTransaction\":\r\n                return this.fetch(\r\n                    \"proxy\",\r\n                    {\r\n                        action: \"eth_sendRawTransaction\",\r\n                        hex: req.signedTransaction,\r\n                    },\r\n                    true,\r\n                ).catch((error) => {\r\n                    return this._checkError(req, error, req.signedTransaction)\r\n                })\r\n            case \"getBlock\":\r\n                if (\"blockTag\" in req) {\r\n                    return this.fetch(\"proxy\", {\r\n                        action: \"eth_getBlockByNumber\",\r\n                        tag: req.blockTag,\r\n                        boolean: req.includeTransactions ? \"true\" : \"false\",\r\n                    })\r\n                }\r\n                assert(\r\n                    false,\r\n                    \"getBlock by blockHash not supported by Etherscan\",\r\n                    \"UNSUPPORTED_OPERATION\",\r\n                    {\r\n                        operation: \"getBlock(blockHash)\",\r\n                    },\r\n                )\r\n            case \"getTransaction\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getTransactionByHash\",\r\n                    txhash: req.hash,\r\n                })\r\n            case \"getTransactionReceipt\":\r\n                return this.fetch(\"proxy\", {\r\n                    action: \"eth_getTransactionReceipt\",\r\n                    txhash: req.hash,\r\n                })\r\n            case \"call\": {\r\n                if (req.blockTag !== \"latest\") {\r\n                    throw new Error(\r\n                        \"EtherscanProvider does not support blockTag for call\",\r\n                    )\r\n                }\r\n                const postData = this._getTransactionPostData(req.transaction)\r\n                postData.module = \"proxy\"\r\n                postData.action = \"eth_call\"\r\n                try {\r\n                    return await this.fetch(\"proxy\", postData, true)\r\n                } catch (error) {\r\n                    return this._checkError(req, error, req.transaction)\r\n                }\r\n            }\r\n            case \"estimateGas\": {\r\n                const postData = this._getTransactionPostData(req.transaction)\r\n                postData.module = \"proxy\"\r\n                postData.action = \"eth_estimateGas\"\r\n                try {\r\n                    return await this.fetch(\"proxy\", postData, true)\r\n                } catch (error) {\r\n                    return this._checkError(req, error, req.transaction)\r\n                }\r\n            }\r\n        }\r\n        return super._perform(req)\r\n    }\r\n    async getNetwork() {\r\n        return this.network\r\n    }\r\n    async getEtherPrice() {\r\n        if (this.network.name !== \"mainnet\") {\r\n            return 0\r\n        }\r\n        return parseFloat(\r\n            (\r\n                await this.fetch(\"stats\", {\r\n                    action: \"ethprice\",\r\n                })\r\n            ).ethusd,\r\n        )\r\n    }\r\n    async getContract(_address) {\r\n        let address = this._getAddress(_address)\r\n        if (isPromise(address)) {\r\n            address = await address\r\n        }\r\n        try {\r\n            const resp = await this.fetch(\"contract\", {\r\n                action: \"getabi\",\r\n                address: address,\r\n            })\r\n            const abi = JSON.parse(resp)\r\n            return new Contract(address, abi, this)\r\n        } catch (error) {\r\n            return null\r\n        }\r\n    }\r\n    isCommunityResource() {\r\n        return this.apiKey == null\r\n    }\r\n}\r\nfunction getGlobal() {\r\n    if (typeof self !== \"undefined\") {\r\n        return self\r\n    }\r\n    if (typeof window !== \"undefined\") {\r\n        return window\r\n    }\r\n    if (typeof global !== \"undefined\") {\r\n        return global\r\n    }\r\n    throw new Error(\"unable to locate global object\")\r\n}\r\nconst _WebSocket = getGlobal().WebSocket\r\nclass SocketSubscriber {\r\n    #provider\r\n    #filter\r\n    get filter() {\r\n        return JSON.parse(this.#filter)\r\n    }\r\n    #filterId\r\n    #paused\r\n    #emitPromise\r\n    constructor(provider, filter) {\r\n        this.#provider = provider\r\n        this.#filter = JSON.stringify(filter)\r\n        this.#filterId = null\r\n        this.#paused = null\r\n        this.#emitPromise = null\r\n    }\r\n    start() {\r\n        this.#filterId = this.#provider\r\n            .send(\"eth_subscribe\", this.filter)\r\n            .then((filterId) => {\r\n                this.#provider._register(filterId, this)\r\n                return filterId\r\n            })\r\n    }\r\n    stop() {\r\n        this.#filterId.then((filterId) => {\r\n            this.#provider.send(\"eth_unsubscribe\", [filterId])\r\n        })\r\n        this.#filterId = null\r\n    }\r\n    pause(dropWhilePaused) {\r\n        assert(\r\n            dropWhilePaused,\r\n            \"preserve logs while paused not supported by SocketSubscriber yet\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"pause(false)\",\r\n            },\r\n        )\r\n        this.#paused = !!dropWhilePaused\r\n    }\r\n    resume() {\r\n        this.#paused = null\r\n    }\r\n    _handleMessage(message) {\r\n        if (this.#filterId == null) {\r\n            return\r\n        }\r\n        if (this.#paused === null) {\r\n            let emitPromise = this.#emitPromise\r\n            if (emitPromise == null) {\r\n                emitPromise = this._emit(this.#provider, message)\r\n            } else {\r\n                emitPromise = emitPromise.then(async () => {\r\n                    await this._emit(this.#provider, message)\r\n                })\r\n            }\r\n            this.#emitPromise = emitPromise.then(() => {\r\n                if (this.#emitPromise === emitPromise) {\r\n                    this.#emitPromise = null\r\n                }\r\n            })\r\n        }\r\n    }\r\n    async _emit(provider, message) {\r\n        throw new Error(\"sub-classes must implemente this; _emit\")\r\n    }\r\n}\r\nclass SocketBlockSubscriber extends SocketSubscriber {\r\n    constructor(provider) {\r\n        super(provider, [\"newHeads\"])\r\n    }\r\n    async _emit(provider, message) {\r\n        provider.emit(\"block\", parseInt(message.number))\r\n    }\r\n}\r\nclass SocketPendingSubscriber extends SocketSubscriber {\r\n    constructor(provider) {\r\n        super(provider, [\"newPendingTransactions\"])\r\n    }\r\n    async _emit(provider, message) {\r\n        provider.emit(\"pending\", message)\r\n    }\r\n}\r\nclass SocketEventSubscriber extends SocketSubscriber {\r\n    #logFilter\r\n    get logFilter() {\r\n        return JSON.parse(this.#logFilter)\r\n    }\r\n    constructor(provider, filter) {\r\n        super(provider, [\"logs\", filter])\r\n        this.#logFilter = JSON.stringify(filter)\r\n    }\r\n    async _emit(provider, message) {\r\n        provider.emit(\r\n            this.logFilter,\r\n            provider._wrapLog(message, provider._network),\r\n        )\r\n    }\r\n}\r\nclass SocketProvider extends JsonRpcApiProvider {\r\n    #callbacks\r\n    #subs\r\n    #pending\r\n    constructor(network, _options) {\r\n        const options = Object.assign({}, _options != null ? _options : {})\r\n        assertArgument(\r\n            options.batchMaxCount == null || options.batchMaxCount === 1,\r\n            \"sockets-based providers do not support batches\",\r\n            \"options.batchMaxCount\",\r\n            _options,\r\n        )\r\n        options.batchMaxCount = 1\r\n        if (options.staticNetwork == null) {\r\n            options.staticNetwork = true\r\n        }\r\n        super(network, options)\r\n        this.#callbacks = new Map()\r\n        this.#subs = new Map()\r\n        this.#pending = new Map()\r\n    }\r\n    _getSubscriber(sub) {\r\n        switch (sub.type) {\r\n            case \"close\":\r\n                return new UnmanagedSubscriber(\"close\")\r\n            case \"block\":\r\n                return new SocketBlockSubscriber(this)\r\n            case \"pending\":\r\n                return new SocketPendingSubscriber(this)\r\n            case \"event\":\r\n                return new SocketEventSubscriber(this, sub.filter)\r\n            case \"orphan\":\r\n                if (sub.filter.orphan === \"drop-log\") {\r\n                    return new UnmanagedSubscriber(\"drop-log\")\r\n                }\r\n        }\r\n        return super._getSubscriber(sub)\r\n    }\r\n    _register(filterId, subscriber) {\r\n        this.#subs.set(filterId, subscriber)\r\n        const pending = this.#pending.get(filterId)\r\n        if (pending) {\r\n            for (const message of pending) {\r\n                subscriber._handleMessage(message)\r\n            }\r\n            this.#pending.delete(filterId)\r\n        }\r\n    }\r\n    async _send(payload) {\r\n        assertArgument(\r\n            !Array.isArray(payload),\r\n            \"WebSocket does not support batch send\",\r\n            \"payload\",\r\n            payload,\r\n        )\r\n        const promise = new Promise((resolve, reject) => {\r\n            this.#callbacks.set(payload.id, {\r\n                payload: payload,\r\n                resolve: resolve,\r\n                reject: reject,\r\n            })\r\n        })\r\n        await this._waitUntilReady()\r\n        await this._write(JSON.stringify(payload))\r\n        return [await promise]\r\n    }\r\n    async _processMessage(message) {\r\n        const result = JSON.parse(message)\r\n        if (result && typeof result === \"object\" && \"id\" in result) {\r\n            const callback = this.#callbacks.get(result.id)\r\n            if (callback == null) {\r\n                this.emit(\r\n                    \"error\",\r\n                    makeError(\r\n                        \"received result for unknown id\",\r\n                        \"UNKNOWN_ERROR\",\r\n                        {\r\n                            reasonCode: \"UNKNOWN_ID\",\r\n                            result: result,\r\n                        },\r\n                    ),\r\n                )\r\n                return\r\n            }\r\n            this.#callbacks.delete(result.id)\r\n            callback.resolve(result)\r\n        } else if (result && result.method === \"eth_subscription\") {\r\n            const filterId = result.params.subscription\r\n            const subscriber = this.#subs.get(filterId)\r\n            if (subscriber) {\r\n                subscriber._handleMessage(result.params.result)\r\n            } else {\r\n                let pending = this.#pending.get(filterId)\r\n                if (pending == null) {\r\n                    pending = []\r\n                    this.#pending.set(filterId, pending)\r\n                }\r\n                pending.push(result.params.result)\r\n            }\r\n        } else {\r\n            this.emit(\r\n                \"error\",\r\n                makeError(\"received unexpected message\", \"UNKNOWN_ERROR\", {\r\n                    reasonCode: \"UNEXPECTED_MESSAGE\",\r\n                    result: result,\r\n                }),\r\n            )\r\n            return\r\n        }\r\n    }\r\n    async _write(message) {\r\n        throw new Error(\"sub-classes must override this\")\r\n    }\r\n}\r\nclass WebSocketProvider extends SocketProvider {\r\n    #connect\r\n    #websocket\r\n    get websocket() {\r\n        if (this.#websocket == null) {\r\n            throw new Error(\"websocket closed\")\r\n        }\r\n        return this.#websocket\r\n    }\r\n    constructor(url, network, options) {\r\n        super(network, options)\r\n        if (typeof url === \"string\") {\r\n            this.#connect = () => {\r\n                return new _WebSocket(url)\r\n            }\r\n            this.#websocket = this.#connect()\r\n        } else if (typeof url === \"function\") {\r\n            this.#connect = url\r\n            this.#websocket = url()\r\n        } else {\r\n            this.#connect = null\r\n            this.#websocket = url\r\n        }\r\n        this.websocket.onopen = async () => {\r\n            try {\r\n                await this._start()\r\n                this.resume()\r\n            } catch (error) {\r\n                console.log(\"failed to start WebsocketProvider\", error)\r\n            }\r\n        }\r\n        this.websocket.onmessage = (message) => {\r\n            this._processMessage(message.data)\r\n        }\r\n    }\r\n    async _write(message) {\r\n        this.websocket.send(message)\r\n    }\r\n    async destroy() {\r\n        if (this.#websocket != null) {\r\n            this.#websocket.close()\r\n            this.#websocket = null\r\n        }\r\n        super.destroy()\r\n    }\r\n}\r\nconst defaultProjectId = \"84842078b09946638c03157f83405213\"\r\nfunction getHost$2(name) {\r\n    switch (name) {\r\n        case \"mainnet\":\r\n            return \"mainnet.infura.io\"\r\n        case \"goerli\":\r\n            return \"goerli.infura.io\"\r\n        case \"sepolia\":\r\n            return \"sepolia.infura.io\"\r\n        case \"arbitrum\":\r\n            return \"arbitrum-mainnet.infura.io\"\r\n        case \"arbitrum-goerli\":\r\n            return \"arbitrum-goerli.infura.io\"\r\n        case \"linea\":\r\n            return \"linea-mainnet.infura.io\"\r\n        case \"linea-goerli\":\r\n            return \"linea-goerli.infura.io\"\r\n        case \"matic\":\r\n            return \"polygon-mainnet.infura.io\"\r\n        case \"matic-mumbai\":\r\n            return \"polygon-mumbai.infura.io\"\r\n        case \"optimism\":\r\n            return \"optimism-mainnet.infura.io\"\r\n        case \"optimism-goerli\":\r\n            return \"optimism-goerli.infura.io\"\r\n    }\r\n    assertArgument(false, \"unsupported network\", \"network\", name)\r\n}\r\nclass InfuraWebSocketProvider extends WebSocketProvider {\r\n    projectId\r\n    projectSecret\r\n    constructor(network, projectId) {\r\n        const provider = new InfuraProvider(network, projectId)\r\n        const req = provider._getConnection()\r\n        assert(\r\n            !req.credentials,\r\n            \"INFURA WebSocket project secrets unsupported\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"InfuraProvider.getWebSocketProvider()\",\r\n            },\r\n        )\r\n        const url = req.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\")\r\n        super(url, network)\r\n        defineProperties(this, {\r\n            projectId: provider.projectId,\r\n            projectSecret: provider.projectSecret,\r\n        })\r\n    }\r\n    isCommunityResource() {\r\n        return this.projectId === defaultProjectId\r\n    }\r\n}\r\nclass InfuraProvider extends JsonRpcProvider {\r\n    projectId\r\n    projectSecret\r\n    constructor(_network, projectId, projectSecret) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\"\r\n        }\r\n        const network = Network.from(_network)\r\n        if (projectId == null) {\r\n            projectId = defaultProjectId\r\n        }\r\n        if (projectSecret == null) {\r\n            projectSecret = null\r\n        }\r\n        const request = InfuraProvider.getRequest(\r\n            network,\r\n            projectId,\r\n            projectSecret,\r\n        )\r\n        super(request, network, {\r\n            staticNetwork: network,\r\n        })\r\n        defineProperties(this, {\r\n            projectId: projectId,\r\n            projectSecret: projectSecret,\r\n        })\r\n    }\r\n    _getProvider(chainId) {\r\n        try {\r\n            return new InfuraProvider(\r\n                chainId,\r\n                this.projectId,\r\n                this.projectSecret,\r\n            )\r\n        } catch (error) {}\r\n        return super._getProvider(chainId)\r\n    }\r\n    isCommunityResource() {\r\n        return this.projectId === defaultProjectId\r\n    }\r\n    static getWebSocketProvider(network, projectId) {\r\n        return new InfuraWebSocketProvider(network, projectId)\r\n    }\r\n    static getRequest(network, projectId, projectSecret) {\r\n        if (projectId == null) {\r\n            projectId = defaultProjectId\r\n        }\r\n        if (projectSecret == null) {\r\n            projectSecret = null\r\n        }\r\n        const request = new FetchRequest(\r\n            `https:/\\/${getHost$2(network.name)}/v3/${projectId}`,\r\n        )\r\n        request.allowGzip = true\r\n        if (projectSecret) {\r\n            request.setCredentials(\"\", projectSecret)\r\n        }\r\n        if (projectId === defaultProjectId) {\r\n            request.retryFunc = async (request, response, attempt) => {\r\n                showThrottleMessage(\"InfuraProvider\")\r\n                return true\r\n            }\r\n        }\r\n        return request\r\n    }\r\n}\r\nconst defaultToken = \"919b412a057b5e9c9b6dce193c5a60242d6efadb\"\r\nfunction getHost$1(name) {\r\n    switch (name) {\r\n        case \"mainnet\":\r\n            return \"ethers.quiknode.pro\"\r\n        case \"goerli\":\r\n            return \"ethers.ethereum-goerli.quiknode.pro\"\r\n        case \"arbitrum\":\r\n            return \"ethers.arbitrum-mainnet.quiknode.pro\"\r\n        case \"arbitrum-goerli\":\r\n            return \"ethers.arbitrum-goerli.quiknode.pro\"\r\n        case \"matic\":\r\n            return \"ethers.matic.quiknode.pro\"\r\n        case \"matic-mumbai\":\r\n            return \"ethers.matic-testnet.quiknode.pro\"\r\n        case \"optimism\":\r\n            return \"ethers.optimism.quiknode.pro\"\r\n        case \"optimism-goerli\":\r\n            return \"ethers.optimism-goerli.quiknode.pro\"\r\n    }\r\n    assertArgument(false, \"unsupported network\", \"network\", name)\r\n}\r\nclass QuickNodeProvider extends JsonRpcProvider {\r\n    token\r\n    constructor(_network, token) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\"\r\n        }\r\n        const network = Network.from(_network)\r\n        if (token == null) {\r\n            token = defaultToken\r\n        }\r\n        const request = QuickNodeProvider.getRequest(network, token)\r\n        super(request, network, {\r\n            staticNetwork: network,\r\n        })\r\n        defineProperties(this, {\r\n            token: token,\r\n        })\r\n    }\r\n    _getProvider(chainId) {\r\n        try {\r\n            return new QuickNodeProvider(chainId, this.token)\r\n        } catch (error) {}\r\n        return super._getProvider(chainId)\r\n    }\r\n    isCommunityResource() {\r\n        return this.token === defaultToken\r\n    }\r\n    static getRequest(network, token) {\r\n        if (token == null) {\r\n            token = defaultToken\r\n        }\r\n        const request = new FetchRequest(\r\n            `https:/\\/${getHost$1(network.name)}/${token}`,\r\n        )\r\n        request.allowGzip = true\r\n        if (token === defaultToken) {\r\n            request.retryFunc = async (request, response, attempt) => {\r\n                showThrottleMessage(\"QuickNodeProvider\")\r\n                return true\r\n            }\r\n        }\r\n        return request\r\n    }\r\n}\r\nconst BN_1 = BigInt(\"1\")\r\nconst BN_2 = BigInt(\"2\")\r\nfunction shuffle(array) {\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1))\r\n        const tmp = array[i]\r\n        array[i] = array[j]\r\n        array[j] = tmp\r\n    }\r\n}\r\nfunction stall$2(duration) {\r\n    return new Promise((resolve) => {\r\n        setTimeout(resolve, duration)\r\n    })\r\n}\r\nfunction getTime() {\r\n    return new Date().getTime()\r\n}\r\nfunction stringify(value) {\r\n    return JSON.stringify(value, (key, value) => {\r\n        if (typeof value === \"bigint\") {\r\n            return {\r\n                type: \"bigint\",\r\n                value: value.toString(),\r\n            }\r\n        }\r\n        return value\r\n    })\r\n}\r\nconst defaultConfig = {\r\n    stallTimeout: 400,\r\n    priority: 1,\r\n    weight: 1,\r\n}\r\nconst defaultState = {\r\n    blockNumber: -2,\r\n    requests: 0,\r\n    lateResponses: 0,\r\n    errorResponses: 0,\r\n    outOfSync: -1,\r\n    unsupportedEvents: 0,\r\n    rollingDuration: 0,\r\n    score: 0,\r\n    _network: null,\r\n    _updateNumber: null,\r\n    _totalTime: 0,\r\n    _lastFatalError: null,\r\n    _lastFatalErrorTimestamp: 0,\r\n}\r\nasync function waitForSync(config, blockNumber) {\r\n    while (config.blockNumber < 0 || config.blockNumber < blockNumber) {\r\n        if (!config._updateNumber) {\r\n            config._updateNumber = (async () => {\r\n                try {\r\n                    const blockNumber = await config.provider.getBlockNumber()\r\n                    if (blockNumber > config.blockNumber) {\r\n                        config.blockNumber = blockNumber\r\n                    }\r\n                } catch (error) {\r\n                    config.blockNumber = -2\r\n                    config._lastFatalError = error\r\n                    config._lastFatalErrorTimestamp = getTime()\r\n                }\r\n                config._updateNumber = null\r\n            })()\r\n        }\r\n        await config._updateNumber\r\n        config.outOfSync++\r\n        if (config._lastFatalError) {\r\n            break\r\n        }\r\n    }\r\n}\r\nfunction _normalize(value) {\r\n    if (value == null) {\r\n        return \"null\"\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return \"[\" + value.map(_normalize).join(\",\") + \"]\"\r\n    }\r\n    if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\r\n        return _normalize(value.toJSON())\r\n    }\r\n    switch (typeof value) {\r\n        case \"boolean\":\r\n        case \"symbol\":\r\n            return value.toString()\r\n        case \"bigint\":\r\n        case \"number\":\r\n            return BigInt(value).toString()\r\n        case \"string\":\r\n            return JSON.stringify(value)\r\n        case \"object\": {\r\n            const keys = Object.keys(value)\r\n            keys.sort()\r\n            return (\r\n                \"{\" +\r\n                keys\r\n                    .map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`)\r\n                    .join(\",\") +\r\n                \"}\"\r\n            )\r\n        }\r\n    }\r\n    console.log(\"Could not serialize\", value)\r\n    throw new Error(\"Hmm...\")\r\n}\r\nfunction normalizeResult(value) {\r\n    if (\"error\" in value) {\r\n        const error = value.error\r\n        return {\r\n            tag: _normalize(error),\r\n            value: error,\r\n        }\r\n    }\r\n    const result = value.result\r\n    return {\r\n        tag: _normalize(result),\r\n        value: result,\r\n    }\r\n}\r\nfunction checkQuorum(quorum, results) {\r\n    const tally = new Map()\r\n    for (const { value, tag, weight } of results) {\r\n        const t = tally.get(tag) || {\r\n            value: value,\r\n            weight: 0,\r\n        }\r\n        t.weight += weight\r\n        tally.set(tag, t)\r\n    }\r\n    let best = null\r\n    for (const r of tally.values()) {\r\n        if (r.weight >= quorum && (!best || r.weight > best.weight)) {\r\n            best = r\r\n        }\r\n    }\r\n    if (best) {\r\n        return best.value\r\n    }\r\n    return undefined\r\n}\r\nfunction getMedian(quorum, results) {\r\n    let resultWeight = 0\r\n    const errorMap = new Map()\r\n    let bestError = null\r\n    const values = []\r\n    for (const { value, tag, weight } of results) {\r\n        if (value instanceof Error) {\r\n            const e = errorMap.get(tag) || {\r\n                value: value,\r\n                weight: 0,\r\n            }\r\n            e.weight += weight\r\n            errorMap.set(tag, e)\r\n            if (bestError == null || e.weight > bestError.weight) {\r\n                bestError = e\r\n            }\r\n        } else {\r\n            values.push(BigInt(value))\r\n            resultWeight += weight\r\n        }\r\n    }\r\n    if (resultWeight < quorum) {\r\n        if (bestError && bestError.weight >= quorum) {\r\n            return bestError.value\r\n        }\r\n        return undefined\r\n    }\r\n    values.sort((a, b) => (a < b ? -1 : b > a ? 1 : 0))\r\n    const mid = Math.floor(values.length / 2)\r\n    if (values.length % 2) {\r\n        return values[mid]\r\n    }\r\n    return (values[mid - 1] + values[mid] + BN_1) / BN_2\r\n}\r\nfunction getAnyResult(quorum, results) {\r\n    const result = checkQuorum(quorum, results)\r\n    if (result !== undefined) {\r\n        return result\r\n    }\r\n    for (const r of results) {\r\n        if (r.value) {\r\n            return r.value\r\n        }\r\n    }\r\n    return undefined\r\n}\r\nfunction getFuzzyMode(quorum, results) {\r\n    if (quorum === 1) {\r\n        return getNumber(getMedian(quorum, results), \"%internal\")\r\n    }\r\n    const tally = new Map()\r\n    const add = (result, weight) => {\r\n        const t = tally.get(result) || {\r\n            result: result,\r\n            weight: 0,\r\n        }\r\n        t.weight += weight\r\n        tally.set(result, t)\r\n    }\r\n    for (const { weight, value } of results) {\r\n        const r = getNumber(value)\r\n        add(r - 1, weight)\r\n        add(r, weight)\r\n        add(r + 1, weight)\r\n    }\r\n    let bestWeight = 0\r\n    let bestResult = undefined\r\n    for (const { weight, result } of tally.values()) {\r\n        if (\r\n            weight >= quorum &&\r\n            (weight > bestWeight ||\r\n                (bestResult != null &&\r\n                    weight === bestWeight &&\r\n                    result > bestResult))\r\n        ) {\r\n            bestWeight = weight\r\n            bestResult = result\r\n        }\r\n    }\r\n    return bestResult\r\n}\r\nclass FallbackProvider extends AbstractProvider {\r\n    quorum\r\n    eventQuorum\r\n    eventWorkers\r\n    #configs\r\n    #height\r\n    #initialSyncPromise\r\n    constructor(providers, network, options) {\r\n        super(network, options)\r\n        this.#configs = providers.map((p) => {\r\n            if (p instanceof AbstractProvider) {\r\n                return Object.assign(\r\n                    {\r\n                        provider: p,\r\n                    },\r\n                    defaultConfig,\r\n                    defaultState,\r\n                )\r\n            } else {\r\n                return Object.assign({}, defaultConfig, p, defaultState)\r\n            }\r\n        })\r\n        this.#height = -2\r\n        this.#initialSyncPromise = null\r\n        if (options && options.quorum != null) {\r\n            this.quorum = options.quorum\r\n        } else {\r\n            this.quorum = Math.ceil(\r\n                this.#configs.reduce((accum, config) => {\r\n                    accum += config.weight\r\n                    return accum\r\n                }, 0) / 2,\r\n            )\r\n        }\r\n        this.eventQuorum = 1\r\n        this.eventWorkers = 1\r\n        assertArgument(\r\n            this.quorum <= this.#configs.reduce((a, c) => a + c.weight, 0),\r\n            \"quorum exceed provider wieght\",\r\n            \"quorum\",\r\n            this.quorum,\r\n        )\r\n    }\r\n    get providerConfigs() {\r\n        return this.#configs.map((c) => {\r\n            const result = Object.assign({}, c)\r\n            for (const key in result) {\r\n                if (key[0] === \"_\") {\r\n                    delete result[key]\r\n                }\r\n            }\r\n            return result\r\n        })\r\n    }\r\n    async _detectNetwork() {\r\n        return Network.from(\r\n            getBigInt(\r\n                await this._perform({\r\n                    method: \"chainId\",\r\n                }),\r\n            ),\r\n        )\r\n    }\r\n    async _translatePerform(provider, req) {\r\n        switch (req.method) {\r\n            case \"broadcastTransaction\":\r\n                return await provider.broadcastTransaction(\r\n                    req.signedTransaction,\r\n                )\r\n            case \"call\":\r\n                return await provider.call(\r\n                    Object.assign({}, req.transaction, {\r\n                        blockTag: req.blockTag,\r\n                    }),\r\n                )\r\n            case \"chainId\":\r\n                return (await provider.getNetwork()).chainId\r\n            case \"estimateGas\":\r\n                return await provider.estimateGas(req.transaction)\r\n            case \"getBalance\":\r\n                return await provider.getBalance(req.address, req.blockTag)\r\n            case \"getBlock\": {\r\n                const block = \"blockHash\" in req ? req.blockHash : req.blockTag\r\n                return await provider.getBlock(block, req.includeTransactions)\r\n            }\r\n            case \"getBlockNumber\":\r\n                return await provider.getBlockNumber()\r\n            case \"getCode\":\r\n                return await provider.getCode(req.address, req.blockTag)\r\n            case \"getGasPrice\":\r\n                return (await provider.getFeeData()).gasPrice\r\n            case \"getPriorityFee\":\r\n                return (await provider.getFeeData()).maxPriorityFeePerGas\r\n            case \"getLogs\":\r\n                return await provider.getLogs(req.filter)\r\n            case \"getStorage\":\r\n                return await provider.getStorage(\r\n                    req.address,\r\n                    req.position,\r\n                    req.blockTag,\r\n                )\r\n            case \"getTransaction\":\r\n                return await provider.getTransaction(req.hash)\r\n            case \"getTransactionCount\":\r\n                return await provider.getTransactionCount(\r\n                    req.address,\r\n                    req.blockTag,\r\n                )\r\n            case \"getTransactionReceipt\":\r\n                return await provider.getTransactionReceipt(req.hash)\r\n            case \"getTransactionResult\":\r\n                return await provider.getTransactionResult(req.hash)\r\n        }\r\n    }\r\n    #getNextConfig(running) {\r\n        const configs = Array.from(running).map((r) => r.config)\r\n        const allConfigs = this.#configs.slice()\r\n        shuffle(allConfigs)\r\n        allConfigs.sort((a, b) => a.priority - b.priority)\r\n        for (const config of allConfigs) {\r\n            if (config._lastFatalError) {\r\n                continue\r\n            }\r\n            if (configs.indexOf(config) === -1) {\r\n                return config\r\n            }\r\n        }\r\n        return null\r\n    }\r\n    #addRunner(running, req) {\r\n        const config = this.#getNextConfig(running)\r\n        if (config == null) {\r\n            return null\r\n        }\r\n        const runner = {\r\n            config: config,\r\n            result: null,\r\n            didBump: false,\r\n            perform: null,\r\n            staller: null,\r\n        }\r\n        const now = getTime()\r\n        runner.perform = (async () => {\r\n            try {\r\n                config.requests++\r\n                const result = await this._translatePerform(\r\n                    config.provider,\r\n                    req,\r\n                )\r\n                runner.result = {\r\n                    result: result,\r\n                }\r\n            } catch (error) {\r\n                config.errorResponses++\r\n                runner.result = {\r\n                    error: error,\r\n                }\r\n            }\r\n            const dt = getTime() - now\r\n            config._totalTime += dt\r\n            config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt\r\n            runner.perform = null\r\n        })()\r\n        runner.staller = (async () => {\r\n            await stall$2(config.stallTimeout)\r\n            runner.staller = null\r\n        })()\r\n        running.add(runner)\r\n        return runner\r\n    }\r\n    async #initialSync() {\r\n        let initialSync = this.#initialSyncPromise\r\n        if (!initialSync) {\r\n            const promises = []\r\n            this.#configs.forEach((config) => {\r\n                promises.push(\r\n                    (async () => {\r\n                        await waitForSync(config, 0)\r\n                        if (!config._lastFatalError) {\r\n                            config._network = await config.provider.getNetwork()\r\n                        }\r\n                    })(),\r\n                )\r\n            })\r\n            this.#initialSyncPromise = initialSync = (async () => {\r\n                await Promise.all(promises)\r\n                let chainId = null\r\n                for (const config of this.#configs) {\r\n                    if (config._lastFatalError) {\r\n                        continue\r\n                    }\r\n                    const network = config._network\r\n                    if (chainId == null) {\r\n                        chainId = network.chainId\r\n                    } else if (network.chainId !== chainId) {\r\n                        assert(\r\n                            false,\r\n                            \"cannot mix providers on different networks\",\r\n                            \"UNSUPPORTED_OPERATION\",\r\n                            {\r\n                                operation: \"new FallbackProvider\",\r\n                            },\r\n                        )\r\n                    }\r\n                }\r\n            })()\r\n        }\r\n        await initialSync\r\n    }\r\n    async #checkQuorum(running, req) {\r\n        const results = []\r\n        for (const runner of running) {\r\n            if (runner.result != null) {\r\n                const { tag, value } = normalizeResult(runner.result)\r\n                results.push({\r\n                    tag: tag,\r\n                    value: value,\r\n                    weight: runner.config.weight,\r\n                })\r\n            }\r\n        }\r\n        if (results.reduce((a, r) => a + r.weight, 0) < this.quorum) {\r\n            return undefined\r\n        }\r\n        switch (req.method) {\r\n            case \"getBlockNumber\": {\r\n                if (this.#height === -2) {\r\n                    this.#height = Math.ceil(\r\n                        getNumber(\r\n                            getMedian(\r\n                                this.quorum,\r\n                                this.#configs\r\n                                    .filter((c) => !c._lastFatalError)\r\n                                    .map((c) => ({\r\n                                        value: c.blockNumber,\r\n                                        tag: getNumber(\r\n                                            c.blockNumber,\r\n                                        ).toString(),\r\n                                        weight: c.weight,\r\n                                    })),\r\n                            ),\r\n                        ),\r\n                    )\r\n                }\r\n                const mode = getFuzzyMode(this.quorum, results)\r\n                if (mode === undefined) {\r\n                    return undefined\r\n                }\r\n                if (mode > this.#height) {\r\n                    this.#height = mode\r\n                }\r\n                return this.#height\r\n            }\r\n            case \"getGasPrice\":\r\n            case \"getPriorityFee\":\r\n            case \"estimateGas\":\r\n                return getMedian(this.quorum, results)\r\n            case \"getBlock\":\r\n                if (\"blockTag\" in req && req.blockTag === \"pending\") {\r\n                    return getAnyResult(this.quorum, results)\r\n                }\r\n                return checkQuorum(this.quorum, results)\r\n            case \"call\":\r\n            case \"chainId\":\r\n            case \"getBalance\":\r\n            case \"getTransactionCount\":\r\n            case \"getCode\":\r\n            case \"getStorage\":\r\n            case \"getTransaction\":\r\n            case \"getTransactionReceipt\":\r\n            case \"getLogs\":\r\n                return checkQuorum(this.quorum, results)\r\n            case \"broadcastTransaction\":\r\n                return getAnyResult(this.quorum, results)\r\n        }\r\n        assert(false, \"unsupported method\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: `_perform(${stringify(req.method)})`,\r\n        })\r\n    }\r\n    async #waitForQuorum(running, req) {\r\n        if (running.size === 0) {\r\n            throw new Error(\"no runners?!\")\r\n        }\r\n        const interesting = []\r\n        let newRunners = 0\r\n        for (const runner of running) {\r\n            if (runner.perform) {\r\n                interesting.push(runner.perform)\r\n            }\r\n            if (runner.staller) {\r\n                interesting.push(runner.staller)\r\n                continue\r\n            }\r\n            if (runner.didBump) {\r\n                continue\r\n            }\r\n            runner.didBump = true\r\n            newRunners++\r\n        }\r\n        const value = await this.#checkQuorum(running, req)\r\n        if (value !== undefined) {\r\n            if (value instanceof Error) {\r\n                throw value\r\n            }\r\n            return value\r\n        }\r\n        for (let i = 0; i < newRunners; i++) {\r\n            this.#addRunner(running, req)\r\n        }\r\n        assert(interesting.length > 0, \"quorum not met\", \"SERVER_ERROR\", {\r\n            request: \"%sub-requests\",\r\n            info: {\r\n                request: req,\r\n                results: Array.from(running).map((r) => stringify(r.result)),\r\n            },\r\n        })\r\n        await Promise.race(interesting)\r\n        return await this.#waitForQuorum(running, req)\r\n    }\r\n    async _perform(req) {\r\n        if (req.method === \"broadcastTransaction\") {\r\n            const results = this.#configs.map((c) => null)\r\n            const broadcasts = this.#configs.map(\r\n                async ({ provider, weight }, index) => {\r\n                    try {\r\n                        const result = await provider._perform(req)\r\n                        results[index] = Object.assign(\r\n                            normalizeResult({\r\n                                result: result,\r\n                            }),\r\n                            {\r\n                                weight: weight,\r\n                            },\r\n                        )\r\n                    } catch (error) {\r\n                        results[index] = Object.assign(\r\n                            normalizeResult({\r\n                                error: error,\r\n                            }),\r\n                            {\r\n                                weight: weight,\r\n                            },\r\n                        )\r\n                    }\r\n                },\r\n            )\r\n            while (true) {\r\n                const done = results.filter((r) => r != null)\r\n                for (const { value } of done) {\r\n                    if (!(value instanceof Error)) {\r\n                        return value\r\n                    }\r\n                }\r\n                const result = checkQuorum(\r\n                    this.quorum,\r\n                    results.filter((r) => r != null),\r\n                )\r\n                if (isError(result, \"INSUFFICIENT_FUNDS\")) {\r\n                    throw result\r\n                }\r\n                const waiting = broadcasts.filter((b, i) => results[i] == null)\r\n                if (waiting.length === 0) {\r\n                    break\r\n                }\r\n                await Promise.race(waiting)\r\n            }\r\n            const result = getAnyResult(this.quorum, results)\r\n            assert(\r\n                result !== undefined,\r\n                \"problem multi-broadcasting\",\r\n                \"SERVER_ERROR\",\r\n                {\r\n                    request: \"%sub-requests\",\r\n                    info: {\r\n                        request: req,\r\n                        results: results.map(stringify),\r\n                    },\r\n                },\r\n            )\r\n            if (result instanceof Error) {\r\n                throw result\r\n            }\r\n            return result\r\n        }\r\n        await this.#initialSync()\r\n        const running = new Set()\r\n        let inflightQuorum = 0\r\n        while (true) {\r\n            const runner = this.#addRunner(running, req)\r\n            if (runner == null) {\r\n                break\r\n            }\r\n            inflightQuorum += runner.config.weight\r\n            if (inflightQuorum >= this.quorum) {\r\n                break\r\n            }\r\n        }\r\n        const result = await this.#waitForQuorum(running, req)\r\n        for (const runner of running) {\r\n            if (runner.perform && runner.result == null) {\r\n                runner.config.lateResponses++\r\n            }\r\n        }\r\n        return result\r\n    }\r\n    async destroy() {\r\n        for (const { provider } of this.#configs) {\r\n            provider.destroy()\r\n        }\r\n        super.destroy()\r\n    }\r\n}\r\nfunction isWebSocketLike(value) {\r\n    return (\r\n        value &&\r\n        typeof value.send === \"function\" &&\r\n        typeof value.close === \"function\"\r\n    )\r\n}\r\nconst Testnets =\r\n    \"goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt\".split(\r\n        \" \",\r\n    )\r\nfunction getDefaultProvider(network, options) {\r\n    if (options == null) {\r\n        options = {}\r\n    }\r\n    const allowService = (name) => {\r\n        if (options[name] === \"-\") {\r\n            return false\r\n        }\r\n        if (typeof options.exclusive === \"string\") {\r\n            return name === options.exclusive\r\n        }\r\n        if (Array.isArray(options.exclusive)) {\r\n            return options.exclusive.indexOf(name) !== -1\r\n        }\r\n        return true\r\n    }\r\n    if (typeof network === \"string\" && network.match(/^https?:/)) {\r\n        return new JsonRpcProvider(network)\r\n    }\r\n    if (\r\n        (typeof network === \"string\" && network.match(/^wss?:/)) ||\r\n        isWebSocketLike(network)\r\n    ) {\r\n        return new WebSocketProvider(network)\r\n    }\r\n    let staticNetwork = null\r\n    try {\r\n        staticNetwork = Network.from(network)\r\n    } catch (error) {}\r\n    const providers = []\r\n    if (allowService(\"publicPolygon\") && staticNetwork) {\r\n        if (staticNetwork.name === \"matic\") {\r\n            providers.push(\r\n                new JsonRpcProvider(\"https://polygon-rpc.com/\", staticNetwork, {\r\n                    staticNetwork: staticNetwork,\r\n                }),\r\n            )\r\n        }\r\n    }\r\n    if (allowService(\"alchemy\")) {\r\n        try {\r\n            providers.push(new AlchemyProvider(network, options.alchemy))\r\n        } catch (error) {}\r\n    }\r\n    if (allowService(\"ankr\") && options.ankr != null) {\r\n        try {\r\n            providers.push(new AnkrProvider(network, options.ankr))\r\n        } catch (error) {}\r\n    }\r\n    if (allowService(\"cloudflare\")) {\r\n        try {\r\n            providers.push(new CloudflareProvider(network))\r\n        } catch (error) {}\r\n    }\r\n    if (allowService(\"etherscan\")) {\r\n        try {\r\n            providers.push(new EtherscanProvider(network, options.etherscan))\r\n        } catch (error) {}\r\n    }\r\n    if (allowService(\"infura\")) {\r\n        try {\r\n            let projectId = options.infura\r\n            let projectSecret = undefined\r\n            if (typeof projectId === \"object\") {\r\n                projectSecret = projectId.projectSecret\r\n                projectId = projectId.projectId\r\n            }\r\n            providers.push(\r\n                new InfuraProvider(network, projectId, projectSecret),\r\n            )\r\n        } catch (error) {}\r\n    }\r\n    if (allowService(\"quicknode\")) {\r\n        try {\r\n            let token = options.quicknode\r\n            providers.push(new QuickNodeProvider(network, token))\r\n        } catch (error) {}\r\n    }\r\n    assert(\r\n        providers.length,\r\n        \"unsupported default network\",\r\n        \"UNSUPPORTED_OPERATION\",\r\n        {\r\n            operation: \"getDefaultProvider\",\r\n        },\r\n    )\r\n    if (providers.length === 1) {\r\n        return providers[0]\r\n    }\r\n    let quorum = Math.floor(providers.length / 2)\r\n    if (quorum > 2) {\r\n        quorum = 2\r\n    }\r\n    if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {\r\n        quorum = 1\r\n    }\r\n    if (options && options.quorum) {\r\n        quorum = options.quorum\r\n    }\r\n    return new FallbackProvider(providers, undefined, {\r\n        quorum: quorum,\r\n    })\r\n}\r\nclass NonceManager extends AbstractSigner {\r\n    signer\r\n    #noncePromise\r\n    #delta\r\n    constructor(signer) {\r\n        super(signer.provider)\r\n        defineProperties(this, {\r\n            signer: signer,\r\n        })\r\n        this.#noncePromise = null\r\n        this.#delta = 0\r\n    }\r\n    async getAddress() {\r\n        return this.signer.getAddress()\r\n    }\r\n    connect(provider) {\r\n        return new NonceManager(this.signer.connect(provider))\r\n    }\r\n    async getNonce(blockTag) {\r\n        if (blockTag === \"pending\") {\r\n            if (this.#noncePromise == null) {\r\n                this.#noncePromise = super.getNonce(\"pending\")\r\n            }\r\n            const delta = this.#delta\r\n            return (await this.#noncePromise) + delta\r\n        }\r\n        return super.getNonce(blockTag)\r\n    }\r\n    increment() {\r\n        this.#delta++\r\n    }\r\n    reset() {\r\n        this.#delta = 0\r\n        this.#noncePromise = null\r\n    }\r\n    async sendTransaction(tx) {\r\n        const noncePromise = this.getNonce(\"pending\")\r\n        this.increment()\r\n        tx = await this.signer.populateTransaction(tx)\r\n        tx.nonce = await noncePromise\r\n        return await this.signer.sendTransaction(tx)\r\n    }\r\n    signTransaction(tx) {\r\n        return this.signer.signTransaction(tx)\r\n    }\r\n    signMessage(message) {\r\n        return this.signer.signMessage(message)\r\n    }\r\n    signTypedData(domain, types, value) {\r\n        return this.signer.signTypedData(domain, types, value)\r\n    }\r\n}\r\nclass BrowserProvider extends JsonRpcApiPollingProvider {\r\n    #request\r\n    constructor(ethereum, network) {\r\n        super(network, {\r\n            batchMaxCount: 1,\r\n        })\r\n        this.#request = async (method, params) => {\r\n            const payload = {\r\n                method: method,\r\n                params: params,\r\n            }\r\n            this.emit(\"debug\", {\r\n                action: \"sendEip1193Request\",\r\n                payload: payload,\r\n            })\r\n            try {\r\n                const result = await ethereum.request(payload)\r\n                this.emit(\"debug\", {\r\n                    action: \"receiveEip1193Result\",\r\n                    result: result,\r\n                })\r\n                return result\r\n            } catch (e) {\r\n                const error = new Error(e.message)\r\n                error.code = e.code\r\n                error.data = e.data\r\n                error.payload = payload\r\n                this.emit(\"debug\", {\r\n                    action: \"receiveEip1193Error\",\r\n                    error: error,\r\n                })\r\n                throw error\r\n            }\r\n        }\r\n    }\r\n    async send(method, params) {\r\n        await this._start()\r\n        return await super.send(method, params)\r\n    }\r\n    async _send(payload) {\r\n        assertArgument(\r\n            !Array.isArray(payload),\r\n            \"EIP-1193 does not support batch request\",\r\n            \"payload\",\r\n            payload,\r\n        )\r\n        try {\r\n            const result = await this.#request(\r\n                payload.method,\r\n                payload.params || [],\r\n            )\r\n            return [\r\n                {\r\n                    id: payload.id,\r\n                    result: result,\r\n                },\r\n            ]\r\n        } catch (e) {\r\n            return [\r\n                {\r\n                    id: payload.id,\r\n                    error: {\r\n                        code: e.code,\r\n                        data: e.data,\r\n                        message: e.message,\r\n                    },\r\n                },\r\n            ]\r\n        }\r\n    }\r\n    getRpcError(payload, error) {\r\n        error = JSON.parse(JSON.stringify(error))\r\n        switch (error.error.code || -1) {\r\n            case 4001:\r\n                error.error.message = `ethers-user-denied: ${error.error.message}`\r\n                break\r\n            case 4200:\r\n                error.error.message = `ethers-unsupported: ${error.error.message}`\r\n                break\r\n        }\r\n        return super.getRpcError(payload, error)\r\n    }\r\n    async hasSigner(address) {\r\n        if (address == null) {\r\n            address = 0\r\n        }\r\n        const accounts = await this.send(\"eth_accounts\", [])\r\n        if (typeof address === \"number\") {\r\n            return accounts.length > address\r\n        }\r\n        address = address.toLowerCase()\r\n        return accounts.filter((a) => a.toLowerCase() === address).length !== 0\r\n    }\r\n    async getSigner(address) {\r\n        if (address == null) {\r\n            address = 0\r\n        }\r\n        if (!(await this.hasSigner(address))) {\r\n            try {\r\n                await this.#request(\"eth_requestAccounts\", [])\r\n            } catch (error) {\r\n                const payload = error.payload\r\n                throw this.getRpcError(payload, {\r\n                    id: payload.id,\r\n                    error: error,\r\n                })\r\n            }\r\n        }\r\n        return await super.getSigner(address)\r\n    }\r\n}\r\nconst defaultApplicationId = \"62e1ad51b37b8e00394bda3b\"\r\nfunction getHost(name) {\r\n    switch (name) {\r\n        case \"mainnet\":\r\n            return \"eth-mainnet.gateway.pokt.network\"\r\n        case \"goerli\":\r\n            return \"eth-goerli.gateway.pokt.network\"\r\n        case \"matic\":\r\n            return \"poly-mainnet.gateway.pokt.network\"\r\n        case \"matic-mumbai\":\r\n            return \"polygon-mumbai-rpc.gateway.pokt.network\"\r\n    }\r\n    assertArgument(false, \"unsupported network\", \"network\", name)\r\n}\r\nclass PocketProvider extends JsonRpcProvider {\r\n    applicationId\r\n    applicationSecret\r\n    constructor(_network, applicationId, applicationSecret) {\r\n        if (_network == null) {\r\n            _network = \"mainnet\"\r\n        }\r\n        const network = Network.from(_network)\r\n        if (applicationId == null) {\r\n            applicationId = defaultApplicationId\r\n        }\r\n        if (applicationSecret == null) {\r\n            applicationSecret = null\r\n        }\r\n        const options = {\r\n            staticNetwork: network,\r\n        }\r\n        const request = PocketProvider.getRequest(\r\n            network,\r\n            applicationId,\r\n            applicationSecret,\r\n        )\r\n        super(request, network, options)\r\n        defineProperties(this, {\r\n            applicationId: applicationId,\r\n            applicationSecret: applicationSecret,\r\n        })\r\n    }\r\n    _getProvider(chainId) {\r\n        try {\r\n            return new PocketProvider(\r\n                chainId,\r\n                this.applicationId,\r\n                this.applicationSecret,\r\n            )\r\n        } catch (error) {}\r\n        return super._getProvider(chainId)\r\n    }\r\n    static getRequest(network, applicationId, applicationSecret) {\r\n        if (applicationId == null) {\r\n            applicationId = defaultApplicationId\r\n        }\r\n        const request = new FetchRequest(\r\n            `https:/\\/${getHost(network.name)}/v1/lb/${applicationId}`,\r\n        )\r\n        request.allowGzip = true\r\n        if (applicationSecret) {\r\n            request.setCredentials(\"\", applicationSecret)\r\n        }\r\n        if (applicationId === defaultApplicationId) {\r\n            request.retryFunc = async (request, response, attempt) => {\r\n                showThrottleMessage(\"PocketProvider\")\r\n                return true\r\n            }\r\n        }\r\n        return request\r\n    }\r\n    isCommunityResource() {\r\n        return this.applicationId === defaultApplicationId\r\n    }\r\n}\r\nconst IpcSocketProvider = undefined\r\nclass BaseWallet extends AbstractSigner {\r\n    address\r\n    #signingKey\r\n    constructor(privateKey, provider) {\r\n        super(provider)\r\n        assertArgument(\r\n            privateKey && typeof privateKey.sign === \"function\",\r\n            \"invalid private key\",\r\n            \"privateKey\",\r\n            \"[ REDACTED ]\",\r\n        )\r\n        this.#signingKey = privateKey\r\n        const address = computeAddress(this.signingKey.publicKey)\r\n        defineProperties(this, {\r\n            address: address,\r\n        })\r\n    }\r\n    get signingKey() {\r\n        return this.#signingKey\r\n    }\r\n    get privateKey() {\r\n        return this.signingKey.privateKey\r\n    }\r\n    async getAddress() {\r\n        return this.address\r\n    }\r\n    connect(provider) {\r\n        return new BaseWallet(this.#signingKey, provider)\r\n    }\r\n    async signTransaction(tx) {\r\n        const { to, from } = await resolveProperties({\r\n            to: tx.to ? resolveAddress(tx.to, this.provider) : undefined,\r\n            from: tx.from ? resolveAddress(tx.from, this.provider) : undefined,\r\n        })\r\n        if (to != null) {\r\n            tx.to = to\r\n        }\r\n        if (from != null) {\r\n            tx.from = from\r\n        }\r\n        if (tx.from != null) {\r\n            assertArgument(\r\n                getAddress(tx.from) === this.address,\r\n                \"transaction from address mismatch\",\r\n                \"tx.from\",\r\n                tx.from,\r\n            )\r\n            delete tx.from\r\n        }\r\n        const btx = Transaction.from(tx)\r\n        btx.signature = this.signingKey.sign(btx.unsignedHash)\r\n        return btx.serialized\r\n    }\r\n    async signMessage(message) {\r\n        return this.signMessageSync(message)\r\n    }\r\n    signMessageSync(message) {\r\n        return this.signingKey.sign(hashMessage(message)).serialized\r\n    }\r\n    async signTypedData(domain, types, value) {\r\n        const populated = await TypedDataEncoder.resolveNames(\r\n            domain,\r\n            types,\r\n            value,\r\n            async (name) => {\r\n                assert(\r\n                    this.provider != null,\r\n                    \"cannot resolve ENS names without a provider\",\r\n                    \"UNSUPPORTED_OPERATION\",\r\n                    {\r\n                        operation: \"resolveName\",\r\n                        info: {\r\n                            name: name,\r\n                        },\r\n                    },\r\n                )\r\n                const address = await this.provider.resolveName(name)\r\n                assert(\r\n                    address != null,\r\n                    \"unconfigured ENS name\",\r\n                    \"UNCONFIGURED_NAME\",\r\n                    {\r\n                        value: name,\r\n                    },\r\n                )\r\n                return address\r\n            },\r\n        )\r\n        return this.signingKey.sign(\r\n            TypedDataEncoder.hash(populated.domain, types, populated.value),\r\n        ).serialized\r\n    }\r\n}\r\nconst subsChrs = \" !#$%&'()*+,-./<=>?@[]^_`{|}~\"\r\nconst Word = /^[a-z]*$/i\r\nfunction unfold(words, sep) {\r\n    let initial = 97\r\n    return words.reduce((accum, word) => {\r\n        if (word === sep) {\r\n            initial++\r\n        } else if (word.match(Word)) {\r\n            accum.push(String.fromCharCode(initial) + word)\r\n        } else {\r\n            initial = 97\r\n            accum.push(word)\r\n        }\r\n        return accum\r\n    }, [])\r\n}\r\nfunction decode(data, subs) {\r\n    for (let i = subsChrs.length - 1; i >= 0; i--) {\r\n        data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2))\r\n    }\r\n    const clumps = []\r\n    const leftover = data.replace(\r\n        /(:|([0-9])|([A-Z][a-z]*))/g,\r\n        (all, item, semi, word) => {\r\n            if (semi) {\r\n                for (let i = parseInt(semi); i >= 0; i--) {\r\n                    clumps.push(\";\")\r\n                }\r\n            } else {\r\n                clumps.push(item.toLowerCase())\r\n            }\r\n            return \"\"\r\n        },\r\n    )\r\n    if (leftover) {\r\n        throw new Error(`leftovers: ${JSON.stringify(leftover)}`)\r\n    }\r\n    return unfold(unfold(clumps, \";\"), \":\")\r\n}\r\nfunction decodeOwl(data) {\r\n    assertArgument(data[0] === \"0\", \"unsupported auwl data\", \"data\", data)\r\n    return decode(\r\n        data.substring(1 + 2 * subsChrs.length),\r\n        data.substring(1, 1 + 2 * subsChrs.length),\r\n    )\r\n}\r\nclass Wordlist {\r\n    locale\r\n    constructor(locale) {\r\n        defineProperties(this, {\r\n            locale: locale,\r\n        })\r\n    }\r\n    split(phrase) {\r\n        return phrase.toLowerCase().split(/\\s+/g)\r\n    }\r\n    join(words) {\r\n        return words.join(\" \")\r\n    }\r\n}\r\nclass WordlistOwl extends Wordlist {\r\n    #data\r\n    #checksum\r\n    constructor(locale, data, checksum) {\r\n        super(locale)\r\n        this.#data = data\r\n        this.#checksum = checksum\r\n        this.#words = null\r\n    }\r\n    get _data() {\r\n        return this.#data\r\n    }\r\n    _decodeWords() {\r\n        return decodeOwl(this.#data)\r\n    }\r\n    #words\r\n    #loadWords() {\r\n        if (this.#words == null) {\r\n            const words = this._decodeWords()\r\n            const checksum = id(words.join(\"\\n\") + \"\\n\")\r\n            if (checksum !== this.#checksum) {\r\n                throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`)\r\n            }\r\n            this.#words = words\r\n        }\r\n        return this.#words\r\n    }\r\n    getWord(index) {\r\n        const words = this.#loadWords()\r\n        assertArgument(\r\n            index >= 0 && index < words.length,\r\n            `invalid word index: ${index}`,\r\n            \"index\",\r\n            index,\r\n        )\r\n        return words[index]\r\n    }\r\n    getWordIndex(word) {\r\n        return this.#loadWords().indexOf(word)\r\n    }\r\n}\r\nconst words =\r\n    \"0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO\"\r\nconst checksum =\r\n    \"0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60\"\r\nlet wordlist = null\r\nclass LangEn extends WordlistOwl {\r\n    constructor() {\r\n        super(\"en\", words, checksum)\r\n    }\r\n    static wordlist() {\r\n        if (wordlist == null) {\r\n            wordlist = new LangEn()\r\n        }\r\n        return wordlist\r\n    }\r\n}\r\nfunction getUpperMask(bits) {\r\n    return (((1 << bits) - 1) << (8 - bits)) & 255\r\n}\r\nfunction getLowerMask(bits) {\r\n    return ((1 << bits) - 1) & 255\r\n}\r\nfunction mnemonicToEntropy(mnemonic, wordlist) {\r\n    assertNormalize(\"NFKD\")\r\n    if (wordlist == null) {\r\n        wordlist = LangEn.wordlist()\r\n    }\r\n    const words = wordlist.split(mnemonic)\r\n    assertArgument(\r\n        words.length % 3 === 0 && words.length >= 12 && words.length <= 24,\r\n        \"invalid mnemonic length\",\r\n        \"mnemonic\",\r\n        \"[ REDACTED ]\",\r\n    )\r\n    const entropy = new Uint8Array(Math.ceil((11 * words.length) / 8))\r\n    let offset = 0\r\n    for (let i = 0; i < words.length; i++) {\r\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"))\r\n        assertArgument(\r\n            index >= 0,\r\n            `invalid mnemonic word at index ${i}`,\r\n            \"mnemonic\",\r\n            \"[ REDACTED ]\",\r\n        )\r\n        for (let bit = 0; bit < 11; bit++) {\r\n            if (index & (1 << (10 - bit))) {\r\n                entropy[offset >> 3] |= 1 << (7 - (offset % 8))\r\n            }\r\n            offset++\r\n        }\r\n    }\r\n    const entropyBits = (32 * words.length) / 3\r\n    const checksumBits = words.length / 3\r\n    const checksumMask = getUpperMask(checksumBits)\r\n    const checksum =\r\n        getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask\r\n    assertArgument(\r\n        checksum === (entropy[entropy.length - 1] & checksumMask),\r\n        \"invalid mnemonic checksum\",\r\n        \"mnemonic\",\r\n        \"[ REDACTED ]\",\r\n    )\r\n    return hexlify(entropy.slice(0, entropyBits / 8))\r\n}\r\nfunction entropyToMnemonic(entropy, wordlist) {\r\n    assertArgument(\r\n        entropy.length % 4 === 0 &&\r\n            entropy.length >= 16 &&\r\n            entropy.length <= 32,\r\n        \"invalid entropy size\",\r\n        \"entropy\",\r\n        \"[ REDACTED ]\",\r\n    )\r\n    if (wordlist == null) {\r\n        wordlist = LangEn.wordlist()\r\n    }\r\n    const indices = [0]\r\n    let remainingBits = 11\r\n    for (let i = 0; i < entropy.length; i++) {\r\n        if (remainingBits > 8) {\r\n            indices[indices.length - 1] <<= 8\r\n            indices[indices.length - 1] |= entropy[i]\r\n            remainingBits -= 8\r\n        } else {\r\n            indices[indices.length - 1] <<= remainingBits\r\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits)\r\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits))\r\n            remainingBits += 3\r\n        }\r\n    }\r\n    const checksumBits = entropy.length / 4\r\n    const checksum =\r\n        parseInt(sha256(entropy).substring(2, 4), 16) &\r\n        getUpperMask(checksumBits)\r\n    indices[indices.length - 1] <<= checksumBits\r\n    indices[indices.length - 1] |= checksum >> (8 - checksumBits)\r\n    return wordlist.join(indices.map((index) => wordlist.getWord(index)))\r\n}\r\nconst _guard$1 = {}\r\nclass Mnemonic {\r\n    phrase\r\n    password\r\n    wordlist\r\n    entropy\r\n    constructor(guard, entropy, phrase, password, wordlist) {\r\n        if (password == null) {\r\n            password = \"\"\r\n        }\r\n        if (wordlist == null) {\r\n            wordlist = LangEn.wordlist()\r\n        }\r\n        assertPrivate(guard, _guard$1, \"Mnemonic\")\r\n        defineProperties(this, {\r\n            phrase: phrase,\r\n            password: password,\r\n            wordlist: wordlist,\r\n            entropy: entropy,\r\n        })\r\n    }\r\n    computeSeed() {\r\n        const salt = toUtf8Bytes(\"mnemonic\" + this.password, \"NFKD\")\r\n        return pbkdf2(\r\n            toUtf8Bytes(this.phrase, \"NFKD\"),\r\n            salt,\r\n            2048,\r\n            64,\r\n            \"sha512\",\r\n        )\r\n    }\r\n    static fromPhrase(phrase, password, wordlist) {\r\n        const entropy = mnemonicToEntropy(phrase, wordlist)\r\n        phrase = entropyToMnemonic(getBytes(entropy), wordlist)\r\n        return new Mnemonic(_guard$1, entropy, phrase, password, wordlist)\r\n    }\r\n    static fromEntropy(_entropy, password, wordlist) {\r\n        const entropy = getBytes(_entropy, \"entropy\")\r\n        const phrase = entropyToMnemonic(entropy, wordlist)\r\n        return new Mnemonic(\r\n            _guard$1,\r\n            hexlify(entropy),\r\n            phrase,\r\n            password,\r\n            wordlist,\r\n        )\r\n    }\r\n    static entropyToPhrase(_entropy, wordlist) {\r\n        const entropy = getBytes(_entropy, \"entropy\")\r\n        return entropyToMnemonic(entropy, wordlist)\r\n    }\r\n    static phraseToEntropy(phrase, wordlist) {\r\n        return mnemonicToEntropy(phrase, wordlist)\r\n    }\r\n    static isValidMnemonic(phrase, wordlist) {\r\n        try {\r\n            mnemonicToEntropy(phrase, wordlist)\r\n            return true\r\n        } catch (error) {}\r\n        return false\r\n    }\r\n}\r\nvar __classPrivateFieldGet$2 =\r\n    (__$G && __$G.__classPrivateFieldGet) ||\r\n    function (receiver, state, kind, f) {\r\n        if (kind === \"a\" && !f)\r\n            throw new TypeError(\"Private accessor was defined without a getter\")\r\n        if (\r\n            typeof state === \"function\"\r\n                ? receiver !== state || !f\r\n                : !state.has(receiver)\r\n        )\r\n            throw new TypeError(\r\n                \"Cannot read private member from an object whose class did not declare it\",\r\n            )\r\n        return kind === \"m\"\r\n            ? f\r\n            : kind === \"a\"\r\n              ? f.call(receiver)\r\n              : f\r\n                ? f.value\r\n                : state.get(receiver)\r\n    }\r\nvar __classPrivateFieldSet$2 =\r\n    (__$G && __$G.__classPrivateFieldSet) ||\r\n    function (receiver, state, value, kind, f) {\r\n        if (kind === \"m\") throw new TypeError(\"Private method is not writable\")\r\n        if (kind === \"a\" && !f)\r\n            throw new TypeError(\"Private accessor was defined without a setter\")\r\n        if (\r\n            typeof state === \"function\"\r\n                ? receiver !== state || !f\r\n                : !state.has(receiver)\r\n        )\r\n            throw new TypeError(\r\n                \"Cannot write private member to an object whose class did not declare it\",\r\n            )\r\n        return (\r\n            kind === \"a\"\r\n                ? f.call(receiver, value)\r\n                : f\r\n                  ? (f.value = value)\r\n                  : state.set(receiver, value),\r\n            value\r\n        )\r\n    }\r\nvar _AES_key, _AES_Kd, _AES_Ke\r\nconst numberOfRounds = {\r\n    16: 10,\r\n    24: 12,\r\n    32: 14,\r\n}\r\nconst rcon = [\r\n    1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188,\r\n    99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145,\r\n]\r\nconst S = [\r\n    99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118,\r\n    202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114,\r\n    192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49,\r\n    21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9,\r\n    131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209,\r\n    0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170,\r\n    251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143,\r\n    146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236,\r\n    95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34,\r\n    42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6,\r\n    36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213,\r\n    78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166,\r\n    180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3,\r\n    246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217,\r\n    142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230,\r\n    66, 104, 65, 153, 45, 15, 176, 84, 187, 22,\r\n]\r\nconst Si = [\r\n    82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251,\r\n    124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203,\r\n    84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8,\r\n    46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114,\r\n    248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108,\r\n    112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144,\r\n    216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44,\r\n    30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65,\r\n    79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116,\r\n    34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26,\r\n    113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75,\r\n    198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51,\r\n    136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25,\r\n    181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174,\r\n    42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119,\r\n    214, 38, 225, 105, 20, 99, 85, 33, 12, 125,\r\n]\r\nconst T1 = [\r\n    3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157,\r\n    3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757,\r\n    3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813,\r\n    2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307,\r\n    1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063,\r\n    3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618,\r\n    1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420,\r\n    3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767,\r\n    134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841,\r\n    168101135, 798661301, 235341577, 605164086, 461406363, 3756188221,\r\n    3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174,\r\n    1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627,\r\n    2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582,\r\n    1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264,\r\n    3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945,\r\n    1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235,\r\n    3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509,\r\n    293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160,\r\n    2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528,\r\n    93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503,\r\n    2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118,\r\n    3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505,\r\n    899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354,\r\n    2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664,\r\n    427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963,\r\n    193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017,\r\n    3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070,\r\n    336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085,\r\n    3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207,\r\n    4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028,\r\n    2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743,\r\n    3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501,\r\n    4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599,\r\n    2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021,\r\n    1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956,\r\n    3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891,\r\n    1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535,\r\n    664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707,\r\n    2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602,\r\n    3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671,\r\n    1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982,\r\n    3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163,\r\n    2824099068, 1841019862, 739644986,\r\n]\r\nconst T2 = [\r\n    2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027,\r\n    2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147,\r\n    434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938,\r\n    1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592,\r\n    3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988,\r\n    2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398,\r\n    1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525,\r\n    886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517,\r\n    201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806,\r\n    252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786,\r\n    651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339,\r\n    1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112,\r\n    4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187,\r\n    1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264,\r\n    535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910,\r\n    1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800,\r\n    717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139,\r\n    2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160,\r\n    1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528,\r\n    2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548,\r\n    3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083,\r\n    1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855,\r\n    2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534,\r\n    1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144,\r\n    2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568,\r\n    2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702,\r\n    3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930,\r\n    504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170,\r\n    1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572,\r\n    2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013,\r\n    1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468,\r\n    634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306,\r\n    2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884,\r\n    1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411,\r\n    3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421,\r\n    2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121,\r\n    1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965,\r\n    3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937,\r\n    1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487,\r\n    550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476,\r\n    4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482,\r\n    3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008,\r\n    4238890068, 3597515707, 975967766,\r\n]\r\nconst T3 = [\r\n    1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307,\r\n    1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347,\r\n    4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298,\r\n    3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232,\r\n    2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228,\r\n    1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518,\r\n    911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325,\r\n    3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077,\r\n    67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926,\r\n    84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826,\r\n    3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539,\r\n    745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552,\r\n    1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067,\r\n    795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784,\r\n    4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910,\r\n    961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360,\r\n    4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739,\r\n    2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960,\r\n    1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568,\r\n    2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668,\r\n    3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003,\r\n    3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855,\r\n    2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534,\r\n    1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744,\r\n    2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008,\r\n    2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782,\r\n    1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090,\r\n    169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650,\r\n    3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972,\r\n    2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893,\r\n    3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908,\r\n    3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946,\r\n    2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164,\r\n    3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131,\r\n    3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261,\r\n    1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081,\r\n    895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045,\r\n    2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777,\r\n    3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927,\r\n    3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796,\r\n    2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242,\r\n    1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488,\r\n    1425844308, 3151392187, 372911126,\r\n]\r\nconst T4 = [\r\n    1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062,\r\n    1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422,\r\n    4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983,\r\n    3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547,\r\n    2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643,\r\n    1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788,\r\n    909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625,\r\n    3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962,\r\n    67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071,\r\n    84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791,\r\n    3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989,\r\n    741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667,\r\n    1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797,\r\n    791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704,\r\n    4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535,\r\n    960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995,\r\n    4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214,\r\n    2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760,\r\n    1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408,\r\n    2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563,\r\n    3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573,\r\n    3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230,\r\n    2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284,\r\n    1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344,\r\n    2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123,\r\n    2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087,\r\n    1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700,\r\n    168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855,\r\n    3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747,\r\n    2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873,\r\n    3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523,\r\n    3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511,\r\n    2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419,\r\n    3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126,\r\n    3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401,\r\n    1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866,\r\n    892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850,\r\n    2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042,\r\n    3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917,\r\n    3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891,\r\n    2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452,\r\n    1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443,\r\n    1414855848, 3149649517, 370555436,\r\n]\r\nconst T5 = [\r\n    1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753,\r\n    2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485,\r\n    1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703,\r\n    1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150,\r\n    59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843,\r\n    1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733,\r\n    3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074,\r\n    2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228,\r\n    1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562,\r\n    3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269,\r\n    807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154,\r\n    4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474,\r\n    875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634,\r\n    1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366,\r\n    2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327,\r\n    2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483,\r\n    2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436,\r\n    1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852,\r\n    1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058,\r\n    463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234,\r\n    3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465,\r\n    337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775,\r\n    1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960,\r\n    3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733,\r\n    3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860,\r\n    2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396,\r\n    2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238,\r\n    2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012,\r\n    1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814,\r\n    2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619,\r\n    270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369,\r\n    2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889,\r\n    1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144,\r\n    899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186,\r\n    1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980,\r\n    3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204,\r\n    25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971,\r\n    1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302,\r\n    3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761,\r\n    1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769,\r\n    3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627,\r\n    4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265,\r\n    3576870512, 1215061108, 3501741890,\r\n]\r\nconst T6 = [\r\n    1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933,\r\n    2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900,\r\n    4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723,\r\n    2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385,\r\n    3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473,\r\n    692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113,\r\n    3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529,\r\n    1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523,\r\n    1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122,\r\n    1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824,\r\n    4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204,\r\n    4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614,\r\n    2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839,\r\n    106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461,\r\n    3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937,\r\n    3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598,\r\n    1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696,\r\n    1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017,\r\n    560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918,\r\n    2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114,\r\n    3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840,\r\n    3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030,\r\n    3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940,\r\n    1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268,\r\n    4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330,\r\n    3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036,\r\n    446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778,\r\n    915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837,\r\n    223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799,\r\n    4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129,\r\n    2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319,\r\n    2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859,\r\n    3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884,\r\n    3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336,\r\n    4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085,\r\n    3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314,\r\n    1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086,\r\n    325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127,\r\n    901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326,\r\n    3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179,\r\n    1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897,\r\n    1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980,\r\n    1893020342, 1950903388, 1120974935,\r\n]\r\nconst T7 = [\r\n    2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173,\r\n    1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970,\r\n    3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698,\r\n    244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515,\r\n    1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868,\r\n    1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033,\r\n    1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914,\r\n    861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368,\r\n    1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827,\r\n    2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239,\r\n    2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009,\r\n    4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174,\r\n    1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224,\r\n    2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286,\r\n    2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237,\r\n    1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968,\r\n    172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081,\r\n    1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047,\r\n    2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278,\r\n    2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539,\r\n    719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150,\r\n    2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665,\r\n    4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005,\r\n    4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898,\r\n    1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670,\r\n    3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556,\r\n    1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178,\r\n    188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442,\r\n    2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569,\r\n    2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044,\r\n    2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634,\r\n    2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639,\r\n    919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549,\r\n    1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196,\r\n    3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050,\r\n    81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974,\r\n    895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576,\r\n    1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897,\r\n    3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516,\r\n    935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519,\r\n    3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572,\r\n    2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195,\r\n    3060847922, 1551124588, 1463996600,\r\n]\r\nconst T8 = [\r\n    4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623,\r\n    4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885,\r\n    3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053,\r\n    3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835,\r\n    2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848,\r\n    3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143,\r\n    3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389,\r\n    1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913,\r\n    1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242,\r\n    529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619,\r\n    679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159,\r\n    133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524,\r\n    777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424,\r\n    1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981,\r\n    1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582,\r\n    1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953,\r\n    2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766,\r\n    1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162,\r\n    1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748,\r\n    2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234,\r\n    2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765,\r\n    514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535,\r\n    1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070,\r\n    3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413,\r\n    3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325,\r\n    3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816,\r\n    4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628,\r\n    3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092,\r\n    2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814,\r\n    3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464,\r\n    410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844,\r\n    1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714,\r\n    1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454,\r\n    2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521,\r\n    3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700,\r\n    2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909,\r\n    2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841,\r\n    3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542,\r\n    1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736,\r\n    3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274,\r\n    1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712,\r\n    227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555,\r\n    850817237, 1817998408, 3092726480,\r\n]\r\nconst U1 = [\r\n    0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554,\r\n    708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108,\r\n    1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990,\r\n    4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216,\r\n    2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058,\r\n    3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343,\r\n    3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029,\r\n    3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995,\r\n    899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682,\r\n    1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444,\r\n    1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147,\r\n    2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269,\r\n    3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775,\r\n    1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265,\r\n    1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835,\r\n    92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566,\r\n    1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884,\r\n    101039829, 135050206, 437757123, 337553864, 1042385657, 807962610,\r\n    573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024,\r\n    2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182,\r\n    4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980,\r\n    1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472,\r\n    1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354,\r\n    159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380,\r\n    3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550,\r\n    3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648,\r\n    4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073,\r\n    2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895,\r\n    4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213,\r\n    2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075,\r\n    1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761,\r\n    841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234,\r\n    4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144,\r\n    2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406,\r\n    3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436,\r\n    875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562,\r\n    1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056,\r\n    933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808,\r\n    496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806,\r\n    1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516,\r\n    3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154,\r\n    2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232,\r\n    2370213795,\r\n]\r\nconst U2 = [\r\n    0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694,\r\n    824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388,\r\n    2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410,\r\n    2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776,\r\n    3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918,\r\n    3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543,\r\n    1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569,\r\n    1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355,\r\n    3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933,\r\n    4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895,\r\n    3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975,\r\n    3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917,\r\n    2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523,\r\n    2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409,\r\n    1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751,\r\n    53458370, 839224033, 957055980, 605657339, 790073846, 2373340630,\r\n    2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216,\r\n    3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602,\r\n    4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276,\r\n    545572369, 296679730, 446754879, 129166120, 213705253, 1709610350,\r\n    1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296,\r\n    1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598,\r\n    3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840,\r\n    2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386,\r\n    1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268,\r\n    1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403,\r\n    636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558,\r\n    2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780,\r\n    3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378,\r\n    1014646705, 930369212, 711349675, 560487590, 272786309, 457992840,\r\n    106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326,\r\n    1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114,\r\n    401639597, 486441376, 768917123, 651868046, 1003007129, 818324884,\r\n    1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846,\r\n    1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696,\r\n    2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122,\r\n    4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796,\r\n    2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517,\r\n    1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235,\r\n    243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545,\r\n    3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663,\r\n    2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461,\r\n    2827177882, 2743944855,\r\n]\r\nconst U3 = [\r\n    0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294,\r\n    590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588,\r\n    1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250,\r\n    3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176,\r\n    3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278,\r\n    2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663,\r\n    2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769,\r\n    3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195,\r\n    1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173,\r\n    1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214,\r\n    766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317,\r\n    1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239,\r\n    532201772, 313773861, 830661914, 1015671571, 731183368, 648017665,\r\n    3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195,\r\n    2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725,\r\n    3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916,\r\n    3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354,\r\n    3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200,\r\n    2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814,\r\n    840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892,\r\n    1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050,\r\n    3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177,\r\n    4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199,\r\n    2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165,\r\n    273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755,\r\n    1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833,\r\n    1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228,\r\n    1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910,\r\n    331544205, 516552836, 1039717051, 821288114, 669961897, 719700128,\r\n    2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410,\r\n    2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516,\r\n    3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539,\r\n    2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549,\r\n    3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991,\r\n    4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081,\r\n    1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827,\r\n    369057872, 418672217, 1002783846, 919489135, 567498868, 752375421,\r\n    209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663,\r\n    793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501,\r\n    1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691,\r\n    3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009,\r\n    3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927,\r\n    2544078150,\r\n]\r\nconst U4 = [\r\n    0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204,\r\n    1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408,\r\n    1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100,\r\n    2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816,\r\n    3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748,\r\n    3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843,\r\n    377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439,\r\n    1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315,\r\n    2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623,\r\n    2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475,\r\n    3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905,\r\n    1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837,\r\n    923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535,\r\n    3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555,\r\n    3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895,\r\n    2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496,\r\n    1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164,\r\n    96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418,\r\n    983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110,\r\n    4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026,\r\n    2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121,\r\n    3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453,\r\n    3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017,\r\n    2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261,\r\n    1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905,\r\n    1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243,\r\n    3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116,\r\n    3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296,\r\n    3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812,\r\n    1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584,\r\n    265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814,\r\n    821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988,\r\n    3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416,\r\n    3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692,\r\n    57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702,\r\n    1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730,\r\n    1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053,\r\n    2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233,\r\n    4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253,\r\n    836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907,\r\n    251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495,\r\n    1418573201, 1335535747, 1184342925,\r\n]\r\nfunction convertToInt32(bytes) {\r\n    const result = []\r\n    for (let i = 0; i < bytes.length; i += 4) {\r\n        result.push(\r\n            (bytes[i] << 24) |\r\n                (bytes[i + 1] << 16) |\r\n                (bytes[i + 2] << 8) |\r\n                bytes[i + 3],\r\n        )\r\n    }\r\n    return result\r\n}\r\nclass AES {\r\n    get key() {\r\n        return __classPrivateFieldGet$2(this, _AES_key, \"f\").slice()\r\n    }\r\n    constructor(key) {\r\n        _AES_key.set(this, void 0)\r\n        _AES_Kd.set(this, void 0)\r\n        _AES_Ke.set(this, void 0)\r\n        if (!(this instanceof AES)) {\r\n            throw Error(\"AES must be instanitated with `new`\")\r\n        }\r\n        __classPrivateFieldSet$2(this, _AES_key, new Uint8Array(key), \"f\")\r\n        const rounds = numberOfRounds[this.key.length]\r\n        if (rounds == null) {\r\n            throw new TypeError(\"invalid key size (must be 16, 24 or 32 bytes)\")\r\n        }\r\n        __classPrivateFieldSet$2(this, _AES_Ke, [], \"f\")\r\n        __classPrivateFieldSet$2(this, _AES_Kd, [], \"f\")\r\n        for (let i = 0; i <= rounds; i++) {\r\n            __classPrivateFieldGet$2(this, _AES_Ke, \"f\").push([0, 0, 0, 0])\r\n            __classPrivateFieldGet$2(this, _AES_Kd, \"f\").push([0, 0, 0, 0])\r\n        }\r\n        const roundKeyCount = (rounds + 1) * 4\r\n        const KC = this.key.length / 4\r\n        const tk = convertToInt32(this.key)\r\n        let index\r\n        for (let i = 0; i < KC; i++) {\r\n            index = i >> 2\r\n            __classPrivateFieldGet$2(this, _AES_Ke, \"f\")[index][i % 4] = tk[i]\r\n            __classPrivateFieldGet$2(this, _AES_Kd, \"f\")[rounds - index][\r\n                i % 4\r\n            ] = tk[i]\r\n        }\r\n        let rconpointer = 0\r\n        let t = KC,\r\n            tt\r\n        while (t < roundKeyCount) {\r\n            tt = tk[KC - 1]\r\n            tk[0] ^=\r\n                (S[(tt >> 16) & 255] << 24) ^\r\n                (S[(tt >> 8) & 255] << 16) ^\r\n                (S[tt & 255] << 8) ^\r\n                S[(tt >> 24) & 255] ^\r\n                (rcon[rconpointer] << 24)\r\n            rconpointer += 1\r\n            if (KC != 8) {\r\n                for (let i = 1; i < KC; i++) {\r\n                    tk[i] ^= tk[i - 1]\r\n                }\r\n            } else {\r\n                for (let i = 1; i < KC / 2; i++) {\r\n                    tk[i] ^= tk[i - 1]\r\n                }\r\n                tt = tk[KC / 2 - 1]\r\n                tk[KC / 2] ^=\r\n                    S[tt & 255] ^\r\n                    (S[(tt >> 8) & 255] << 8) ^\r\n                    (S[(tt >> 16) & 255] << 16) ^\r\n                    (S[(tt >> 24) & 255] << 24)\r\n                for (let i = KC / 2 + 1; i < KC; i++) {\r\n                    tk[i] ^= tk[i - 1]\r\n                }\r\n            }\r\n            let i = 0,\r\n                r,\r\n                c\r\n            while (i < KC && t < roundKeyCount) {\r\n                r = t >> 2\r\n                c = t % 4\r\n                __classPrivateFieldGet$2(this, _AES_Ke, \"f\")[r][c] = tk[i]\r\n                __classPrivateFieldGet$2(this, _AES_Kd, \"f\")[rounds - r][c] =\r\n                    tk[i++]\r\n                t++\r\n            }\r\n        }\r\n        for (let r = 1; r < rounds; r++) {\r\n            for (let c = 0; c < 4; c++) {\r\n                tt = __classPrivateFieldGet$2(this, _AES_Kd, \"f\")[r][c]\r\n                __classPrivateFieldGet$2(this, _AES_Kd, \"f\")[r][c] =\r\n                    U1[(tt >> 24) & 255] ^\r\n                    U2[(tt >> 16) & 255] ^\r\n                    U3[(tt >> 8) & 255] ^\r\n                    U4[tt & 255]\r\n            }\r\n        }\r\n    }\r\n    encrypt(plaintext) {\r\n        if (plaintext.length != 16) {\r\n            throw new TypeError(\"invalid plaintext size (must be 16 bytes)\")\r\n        }\r\n        const rounds = __classPrivateFieldGet$2(this, _AES_Ke, \"f\").length - 1\r\n        const a = [0, 0, 0, 0]\r\n        let t = convertToInt32(plaintext)\r\n        for (let i = 0; i < 4; i++) {\r\n            t[i] ^= __classPrivateFieldGet$2(this, _AES_Ke, \"f\")[0][i]\r\n        }\r\n        for (let r = 1; r < rounds; r++) {\r\n            for (let i = 0; i < 4; i++) {\r\n                a[i] =\r\n                    T1[(t[i] >> 24) & 255] ^\r\n                    T2[(t[(i + 1) % 4] >> 16) & 255] ^\r\n                    T3[(t[(i + 2) % 4] >> 8) & 255] ^\r\n                    T4[t[(i + 3) % 4] & 255] ^\r\n                    __classPrivateFieldGet$2(this, _AES_Ke, \"f\")[r][i]\r\n            }\r\n            t = a.slice()\r\n        }\r\n        const result = new Uint8Array(16)\r\n        let tt = 0\r\n        for (let i = 0; i < 4; i++) {\r\n            tt = __classPrivateFieldGet$2(this, _AES_Ke, \"f\")[rounds][i]\r\n            result[4 * i] = (S[(t[i] >> 24) & 255] ^ (tt >> 24)) & 255\r\n            result[4 * i + 1] =\r\n                (S[(t[(i + 1) % 4] >> 16) & 255] ^ (tt >> 16)) & 255\r\n            result[4 * i + 2] =\r\n                (S[(t[(i + 2) % 4] >> 8) & 255] ^ (tt >> 8)) & 255\r\n            result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255\r\n        }\r\n        return result\r\n    }\r\n    decrypt(ciphertext) {\r\n        if (ciphertext.length != 16) {\r\n            throw new TypeError(\"invalid ciphertext size (must be 16 bytes)\")\r\n        }\r\n        const rounds = __classPrivateFieldGet$2(this, _AES_Kd, \"f\").length - 1\r\n        const a = [0, 0, 0, 0]\r\n        let t = convertToInt32(ciphertext)\r\n        for (let i = 0; i < 4; i++) {\r\n            t[i] ^= __classPrivateFieldGet$2(this, _AES_Kd, \"f\")[0][i]\r\n        }\r\n        for (let r = 1; r < rounds; r++) {\r\n            for (let i = 0; i < 4; i++) {\r\n                a[i] =\r\n                    T5[(t[i] >> 24) & 255] ^\r\n                    T6[(t[(i + 3) % 4] >> 16) & 255] ^\r\n                    T7[(t[(i + 2) % 4] >> 8) & 255] ^\r\n                    T8[t[(i + 1) % 4] & 255] ^\r\n                    __classPrivateFieldGet$2(this, _AES_Kd, \"f\")[r][i]\r\n            }\r\n            t = a.slice()\r\n        }\r\n        const result = new Uint8Array(16)\r\n        let tt = 0\r\n        for (let i = 0; i < 4; i++) {\r\n            tt = __classPrivateFieldGet$2(this, _AES_Kd, \"f\")[rounds][i]\r\n            result[4 * i] = (Si[(t[i] >> 24) & 255] ^ (tt >> 24)) & 255\r\n            result[4 * i + 1] =\r\n                (Si[(t[(i + 3) % 4] >> 16) & 255] ^ (tt >> 16)) & 255\r\n            result[4 * i + 2] =\r\n                (Si[(t[(i + 2) % 4] >> 8) & 255] ^ (tt >> 8)) & 255\r\n            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255\r\n        }\r\n        return result\r\n    }\r\n}\r\n;(_AES_key = new WeakMap()),\r\n    (_AES_Kd = new WeakMap()),\r\n    (_AES_Ke = new WeakMap())\r\nclass ModeOfOperation {\r\n    constructor(name, key, cls) {\r\n        if (cls && !(this instanceof cls)) {\r\n            throw new Error(`${name} must be instantiated with \"new\"`)\r\n        }\r\n        Object.defineProperties(this, {\r\n            aes: {\r\n                enumerable: true,\r\n                value: new AES(key),\r\n            },\r\n            name: {\r\n                enumerable: true,\r\n                value: name,\r\n            },\r\n        })\r\n    }\r\n}\r\nvar __classPrivateFieldSet$1 =\r\n    (__$G && __$G.__classPrivateFieldSet) ||\r\n    function (receiver, state, value, kind, f) {\r\n        if (kind === \"m\") throw new TypeError(\"Private method is not writable\")\r\n        if (kind === \"a\" && !f)\r\n            throw new TypeError(\"Private accessor was defined without a setter\")\r\n        if (\r\n            typeof state === \"function\"\r\n                ? receiver !== state || !f\r\n                : !state.has(receiver)\r\n        )\r\n            throw new TypeError(\r\n                \"Cannot write private member to an object whose class did not declare it\",\r\n            )\r\n        return (\r\n            kind === \"a\"\r\n                ? f.call(receiver, value)\r\n                : f\r\n                  ? (f.value = value)\r\n                  : state.set(receiver, value),\r\n            value\r\n        )\r\n    }\r\nvar __classPrivateFieldGet$1 =\r\n    (__$G && __$G.__classPrivateFieldGet) ||\r\n    function (receiver, state, kind, f) {\r\n        if (kind === \"a\" && !f)\r\n            throw new TypeError(\"Private accessor was defined without a getter\")\r\n        if (\r\n            typeof state === \"function\"\r\n                ? receiver !== state || !f\r\n                : !state.has(receiver)\r\n        )\r\n            throw new TypeError(\r\n                \"Cannot read private member from an object whose class did not declare it\",\r\n            )\r\n        return kind === \"m\"\r\n            ? f\r\n            : kind === \"a\"\r\n              ? f.call(receiver)\r\n              : f\r\n                ? f.value\r\n                : state.get(receiver)\r\n    }\r\nvar _CBC_iv, _CBC_lastBlock\r\nclass CBC extends ModeOfOperation {\r\n    constructor(key, iv) {\r\n        super(\"ECC\", key, CBC)\r\n        _CBC_iv.set(this, void 0)\r\n        _CBC_lastBlock.set(this, void 0)\r\n        if (iv) {\r\n            if (iv.length % 16) {\r\n                throw new TypeError(\"invalid iv size (must be 16 bytes)\")\r\n            }\r\n            __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(iv), \"f\")\r\n        } else {\r\n            __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(16), \"f\")\r\n        }\r\n        __classPrivateFieldSet$1(this, _CBC_lastBlock, this.iv, \"f\")\r\n    }\r\n    get iv() {\r\n        return new Uint8Array(__classPrivateFieldGet$1(this, _CBC_iv, \"f\"))\r\n    }\r\n    encrypt(plaintext) {\r\n        if (plaintext.length % 16) {\r\n            throw new TypeError(\r\n                \"invalid plaintext size (must be multiple of 16 bytes)\",\r\n            )\r\n        }\r\n        const ciphertext = new Uint8Array(plaintext.length)\r\n        for (let i = 0; i < plaintext.length; i += 16) {\r\n            for (let j = 0; j < 16; j++) {\r\n                __classPrivateFieldGet$1(this, _CBC_lastBlock, \"f\")[j] ^=\r\n                    plaintext[i + j]\r\n            }\r\n            __classPrivateFieldSet$1(\r\n                this,\r\n                _CBC_lastBlock,\r\n                this.aes.encrypt(\r\n                    __classPrivateFieldGet$1(this, _CBC_lastBlock, \"f\"),\r\n                ),\r\n                \"f\",\r\n            )\r\n            ciphertext.set(\r\n                __classPrivateFieldGet$1(this, _CBC_lastBlock, \"f\"),\r\n                i,\r\n            )\r\n        }\r\n        return ciphertext\r\n    }\r\n    decrypt(ciphertext) {\r\n        if (ciphertext.length % 16) {\r\n            throw new TypeError(\r\n                \"invalid ciphertext size (must be multiple of 16 bytes)\",\r\n            )\r\n        }\r\n        const plaintext = new Uint8Array(ciphertext.length)\r\n        for (let i = 0; i < ciphertext.length; i += 16) {\r\n            const block = this.aes.decrypt(ciphertext.subarray(i, i + 16))\r\n            for (let j = 0; j < 16; j++) {\r\n                plaintext[i + j] =\r\n                    block[j] ^\r\n                    __classPrivateFieldGet$1(this, _CBC_lastBlock, \"f\")[j]\r\n                __classPrivateFieldGet$1(this, _CBC_lastBlock, \"f\")[j] =\r\n                    ciphertext[i + j]\r\n            }\r\n        }\r\n        return plaintext\r\n    }\r\n}\r\n;(_CBC_iv = new WeakMap()), (_CBC_lastBlock = new WeakMap())\r\nvar __classPrivateFieldSet =\r\n    (__$G && __$G.__classPrivateFieldSet) ||\r\n    function (receiver, state, value, kind, f) {\r\n        if (kind === \"m\") throw new TypeError(\"Private method is not writable\")\r\n        if (kind === \"a\" && !f)\r\n            throw new TypeError(\"Private accessor was defined without a setter\")\r\n        if (\r\n            typeof state === \"function\"\r\n                ? receiver !== state || !f\r\n                : !state.has(receiver)\r\n        )\r\n            throw new TypeError(\r\n                \"Cannot write private member to an object whose class did not declare it\",\r\n            )\r\n        return (\r\n            kind === \"a\"\r\n                ? f.call(receiver, value)\r\n                : f\r\n                  ? (f.value = value)\r\n                  : state.set(receiver, value),\r\n            value\r\n        )\r\n    }\r\nvar __classPrivateFieldGet =\r\n    (__$G && __$G.__classPrivateFieldGet) ||\r\n    function (receiver, state, kind, f) {\r\n        if (kind === \"a\" && !f)\r\n            throw new TypeError(\"Private accessor was defined without a getter\")\r\n        if (\r\n            typeof state === \"function\"\r\n                ? receiver !== state || !f\r\n                : !state.has(receiver)\r\n        )\r\n            throw new TypeError(\r\n                \"Cannot read private member from an object whose class did not declare it\",\r\n            )\r\n        return kind === \"m\"\r\n            ? f\r\n            : kind === \"a\"\r\n              ? f.call(receiver)\r\n              : f\r\n                ? f.value\r\n                : state.get(receiver)\r\n    }\r\nvar _CTR_remaining, _CTR_remainingIndex, _CTR_counter\r\nclass CTR extends ModeOfOperation {\r\n    constructor(key, initialValue) {\r\n        super(\"CTR\", key, CTR)\r\n        _CTR_remaining.set(this, void 0)\r\n        _CTR_remainingIndex.set(this, void 0)\r\n        _CTR_counter.set(this, void 0)\r\n        __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), \"f\")\r\n        __classPrivateFieldGet(this, _CTR_counter, \"f\").fill(0)\r\n        __classPrivateFieldSet(\r\n            this,\r\n            _CTR_remaining,\r\n            __classPrivateFieldGet(this, _CTR_counter, \"f\"),\r\n            \"f\",\r\n        )\r\n        __classPrivateFieldSet(this, _CTR_remainingIndex, 16, \"f\")\r\n        if (initialValue == null) {\r\n            initialValue = 1\r\n        }\r\n        if (typeof initialValue === \"number\") {\r\n            this.setCounterValue(initialValue)\r\n        } else {\r\n            this.setCounterBytes(initialValue)\r\n        }\r\n    }\r\n    get counter() {\r\n        return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, \"f\"))\r\n    }\r\n    setCounterValue(value) {\r\n        if (\r\n            !Number.isInteger(value) ||\r\n            value < 0 ||\r\n            value > Number.MAX_SAFE_INTEGER\r\n        ) {\r\n            throw new TypeError(\"invalid counter initial integer value\")\r\n        }\r\n        for (let index = 15; index >= 0; --index) {\r\n            __classPrivateFieldGet(this, _CTR_counter, \"f\")[index] = value % 256\r\n            value = Math.floor(value / 256)\r\n        }\r\n    }\r\n    setCounterBytes(value) {\r\n        if (value.length !== 16) {\r\n            throw new TypeError(\r\n                \"invalid counter initial Uint8Array value length\",\r\n            )\r\n        }\r\n        __classPrivateFieldGet(this, _CTR_counter, \"f\").set(value)\r\n    }\r\n    increment() {\r\n        for (let i = 15; i >= 0; i--) {\r\n            if (__classPrivateFieldGet(this, _CTR_counter, \"f\")[i] === 255) {\r\n                __classPrivateFieldGet(this, _CTR_counter, \"f\")[i] = 0\r\n            } else {\r\n                __classPrivateFieldGet(this, _CTR_counter, \"f\")[i]++\r\n                break\r\n            }\r\n        }\r\n    }\r\n    encrypt(plaintext) {\r\n        var _a, _b\r\n        const crypttext = new Uint8Array(plaintext)\r\n        for (let i = 0; i < crypttext.length; i++) {\r\n            if (__classPrivateFieldGet(this, _CTR_remainingIndex, \"f\") === 16) {\r\n                __classPrivateFieldSet(\r\n                    this,\r\n                    _CTR_remaining,\r\n                    this.aes.encrypt(\r\n                        __classPrivateFieldGet(this, _CTR_counter, \"f\"),\r\n                    ),\r\n                    \"f\",\r\n                )\r\n                __classPrivateFieldSet(this, _CTR_remainingIndex, 0, \"f\")\r\n                this.increment()\r\n            }\r\n            crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, \"f\")[\r\n                (__classPrivateFieldSet(\r\n                    this,\r\n                    _CTR_remainingIndex,\r\n                    ((_b = __classPrivateFieldGet(\r\n                        this,\r\n                        _CTR_remainingIndex,\r\n                        \"f\",\r\n                    )),\r\n                    (_a = _b++),\r\n                    _b),\r\n                    \"f\",\r\n                ),\r\n                _a)\r\n            ]\r\n        }\r\n        return crypttext\r\n    }\r\n    decrypt(ciphertext) {\r\n        return this.encrypt(ciphertext)\r\n    }\r\n}\r\n;(_CTR_remaining = new WeakMap()),\r\n    (_CTR_remainingIndex = new WeakMap()),\r\n    (_CTR_counter = new WeakMap())\r\nfunction pkcs7Strip(data) {\r\n    if (data.length < 16) {\r\n        throw new TypeError(\"PKCS#7 invalid length\")\r\n    }\r\n    const padder = data[data.length - 1]\r\n    if (padder > 16) {\r\n        throw new TypeError(\"PKCS#7 padding byte out of range\")\r\n    }\r\n    const length = data.length - padder\r\n    for (let i = 0; i < padder; i++) {\r\n        if (data[length + i] !== padder) {\r\n            throw new TypeError(\"PKCS#7 invalid padding byte\")\r\n        }\r\n    }\r\n    return new Uint8Array(data.subarray(0, length))\r\n}\r\nfunction looseArrayify(hexString) {\r\n    if (typeof hexString === \"string\" && !hexString.startsWith(\"0x\")) {\r\n        hexString = \"0x\" + hexString\r\n    }\r\n    return getBytesCopy(hexString)\r\n}\r\nfunction zpad$1(value, length) {\r\n    value = String(value)\r\n    while (value.length < length) {\r\n        value = \"0\" + value\r\n    }\r\n    return value\r\n}\r\nfunction getPassword(password) {\r\n    if (typeof password === \"string\") {\r\n        return toUtf8Bytes(password, \"NFKC\")\r\n    }\r\n    return getBytesCopy(password)\r\n}\r\nfunction spelunk(object, _path) {\r\n    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i)\r\n    assertArgument(match != null, \"invalid path\", \"path\", _path)\r\n    const path = match[1]\r\n    const type = match[3]\r\n    const reqd = match[4] === \"!\"\r\n    let cur = object\r\n    for (const comp of path.toLowerCase().split(\".\")) {\r\n        if (Array.isArray(cur)) {\r\n            if (!comp.match(/^[0-9]+$/)) {\r\n                break\r\n            }\r\n            cur = cur[parseInt(comp)]\r\n        } else if (typeof cur === \"object\") {\r\n            let found = null\r\n            for (const key in cur) {\r\n                if (key.toLowerCase() === comp) {\r\n                    found = cur[key]\r\n                    break\r\n                }\r\n            }\r\n            cur = found\r\n        } else {\r\n            cur = null\r\n        }\r\n        if (cur == null) {\r\n            break\r\n        }\r\n    }\r\n    assertArgument(!reqd || cur != null, \"missing required value\", \"path\", path)\r\n    if (type && cur != null) {\r\n        if (type === \"int\") {\r\n            if (typeof cur === \"string\" && cur.match(/^-?[0-9]+$/)) {\r\n                return parseInt(cur)\r\n            } else if (Number.isSafeInteger(cur)) {\r\n                return cur\r\n            }\r\n        }\r\n        if (type === \"number\") {\r\n            if (typeof cur === \"string\" && cur.match(/^-?[0-9.]*$/)) {\r\n                return parseFloat(cur)\r\n            }\r\n        }\r\n        if (type === \"data\") {\r\n            if (typeof cur === \"string\") {\r\n                return looseArrayify(cur)\r\n            }\r\n        }\r\n        if (type === \"array\" && Array.isArray(cur)) {\r\n            return cur\r\n        }\r\n        if (type === typeof cur) {\r\n            return cur\r\n        }\r\n        assertArgument(false, `wrong type found for ${type} `, \"path\", path)\r\n    }\r\n    return cur\r\n}\r\nconst defaultPath$1 = \"m/44'/60'/0'/0/0\"\r\nfunction isKeystoreJson(json) {\r\n    try {\r\n        const data = JSON.parse(json)\r\n        const version = data.version != null ? parseInt(data.version) : 0\r\n        if (version === 3) {\r\n            return true\r\n        }\r\n    } catch (error) {}\r\n    return false\r\n}\r\nfunction decrypt(data, key, ciphertext) {\r\n    const cipher = spelunk(data, \"crypto.cipher:string\")\r\n    if (cipher === \"aes-128-ctr\") {\r\n        const iv = spelunk(data, \"crypto.cipherparams.iv:data!\")\r\n        const aesCtr = new CTR(key, iv)\r\n        return hexlify(aesCtr.decrypt(ciphertext))\r\n    }\r\n    assert(false, \"unsupported cipher\", \"UNSUPPORTED_OPERATION\", {\r\n        operation: \"decrypt\",\r\n    })\r\n}\r\nfunction getAccount(data, _key) {\r\n    const key = getBytes(_key)\r\n    const ciphertext = spelunk(data, \"crypto.ciphertext:data!\")\r\n    const computedMAC = hexlify(\r\n        keccak256(concat([key.slice(16, 32), ciphertext])),\r\n    ).substring(2)\r\n    assertArgument(\r\n        computedMAC === spelunk(data, \"crypto.mac:string!\").toLowerCase(),\r\n        \"incorrect password\",\r\n        \"password\",\r\n        \"[ REDACTED ]\",\r\n    )\r\n    const privateKey = decrypt(data, key.slice(0, 16), ciphertext)\r\n    const address = computeAddress(privateKey)\r\n    if (data.address) {\r\n        let check = data.address.toLowerCase()\r\n        if (!check.startsWith(\"0x\")) {\r\n            check = \"0x\" + check\r\n        }\r\n        assertArgument(\r\n            getAddress(check) === address,\r\n            \"keystore address/privateKey mismatch\",\r\n            \"address\",\r\n            data.address,\r\n        )\r\n    }\r\n    const account = {\r\n        address: address,\r\n        privateKey: privateKey,\r\n    }\r\n    const version = spelunk(data, \"x-ethers.version:string\")\r\n    if (version === \"0.1\") {\r\n        const mnemonicKey = key.slice(32, 64)\r\n        const mnemonicCiphertext = spelunk(\r\n            data,\r\n            \"x-ethers.mnemonicCiphertext:data!\",\r\n        )\r\n        const mnemonicIv = spelunk(data, \"x-ethers.mnemonicCounter:data!\")\r\n        const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv)\r\n        account.mnemonic = {\r\n            path: spelunk(data, \"x-ethers.path:string\") || defaultPath$1,\r\n            locale: spelunk(data, \"x-ethers.locale:string\") || \"en\",\r\n            entropy: hexlify(\r\n                getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)),\r\n            ),\r\n        }\r\n    }\r\n    return account\r\n}\r\nfunction getDecryptKdfParams(data) {\r\n    const kdf = spelunk(data, \"crypto.kdf:string\")\r\n    if (kdf && typeof kdf === \"string\") {\r\n        if (kdf.toLowerCase() === \"scrypt\") {\r\n            const salt = spelunk(data, \"crypto.kdfparams.salt:data!\")\r\n            const N = spelunk(data, \"crypto.kdfparams.n:int!\")\r\n            const r = spelunk(data, \"crypto.kdfparams.r:int!\")\r\n            const p = spelunk(data, \"crypto.kdfparams.p:int!\")\r\n            assertArgument(\r\n                N > 0 && (N & (N - 1)) === 0,\r\n                \"invalid kdf.N\",\r\n                \"kdf.N\",\r\n                N,\r\n            )\r\n            assertArgument(r > 0 && p > 0, \"invalid kdf\", \"kdf\", kdf)\r\n            const dkLen = spelunk(data, \"crypto.kdfparams.dklen:int!\")\r\n            assertArgument(\r\n                dkLen === 32,\r\n                \"invalid kdf.dklen\",\r\n                \"kdf.dflen\",\r\n                dkLen,\r\n            )\r\n            return {\r\n                name: \"scrypt\",\r\n                salt: salt,\r\n                N: N,\r\n                r: r,\r\n                p: p,\r\n                dkLen: 64,\r\n            }\r\n        } else if (kdf.toLowerCase() === \"pbkdf2\") {\r\n            const salt = spelunk(data, \"crypto.kdfparams.salt:data!\")\r\n            const prf = spelunk(data, \"crypto.kdfparams.prf:string!\")\r\n            const algorithm = prf.split(\"-\").pop()\r\n            assertArgument(\r\n                algorithm === \"sha256\" || algorithm === \"sha512\",\r\n                \"invalid kdf.pdf\",\r\n                \"kdf.pdf\",\r\n                prf,\r\n            )\r\n            const count = spelunk(data, \"crypto.kdfparams.c:int!\")\r\n            const dkLen = spelunk(data, \"crypto.kdfparams.dklen:int!\")\r\n            assertArgument(\r\n                dkLen === 32,\r\n                \"invalid kdf.dklen\",\r\n                \"kdf.dklen\",\r\n                dkLen,\r\n            )\r\n            return {\r\n                name: \"pbkdf2\",\r\n                salt: salt,\r\n                count: count,\r\n                dkLen: dkLen,\r\n                algorithm: algorithm,\r\n            }\r\n        }\r\n    }\r\n    assertArgument(false, \"unsupported key-derivation function\", \"kdf\", kdf)\r\n}\r\nfunction decryptKeystoreJsonSync(json, _password) {\r\n    const data = JSON.parse(json)\r\n    const password = getPassword(_password)\r\n    const params = getDecryptKdfParams(data)\r\n    if (params.name === \"pbkdf2\") {\r\n        const { salt, count, dkLen, algorithm } = params\r\n        const key = pbkdf2(password, salt, count, dkLen, algorithm)\r\n        return getAccount(data, key)\r\n    }\r\n    assert(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", {\r\n        params: params,\r\n    })\r\n    const { salt, N, r, p, dkLen } = params\r\n    const key = scryptSync(password, salt, N, r, p, dkLen)\r\n    return getAccount(data, key)\r\n}\r\nfunction stall$1(duration) {\r\n    return new Promise((resolve) => {\r\n        setTimeout(() => {\r\n            resolve()\r\n        }, duration)\r\n    })\r\n}\r\nasync function decryptKeystoreJson(json, _password, progress) {\r\n    const data = JSON.parse(json)\r\n    const password = getPassword(_password)\r\n    const params = getDecryptKdfParams(data)\r\n    if (params.name === \"pbkdf2\") {\r\n        if (progress) {\r\n            progress(0)\r\n            await stall$1(0)\r\n        }\r\n        const { salt, count, dkLen, algorithm } = params\r\n        const key = pbkdf2(password, salt, count, dkLen, algorithm)\r\n        if (progress) {\r\n            progress(1)\r\n            await stall$1(0)\r\n        }\r\n        return getAccount(data, key)\r\n    }\r\n    assert(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", {\r\n        params: params,\r\n    })\r\n    const { salt, N, r, p, dkLen } = params\r\n    const key = await scrypt(password, salt, N, r, p, dkLen, progress)\r\n    return getAccount(data, key)\r\n}\r\nfunction getEncryptKdfParams(options) {\r\n    const salt =\r\n        options.salt != null\r\n            ? getBytes(options.salt, \"options.salt\")\r\n            : randomBytes(32)\r\n    let N = 1 << 17,\r\n        r = 8,\r\n        p = 1\r\n    if (options.scrypt) {\r\n        if (options.scrypt.N) {\r\n            N = options.scrypt.N\r\n        }\r\n        if (options.scrypt.r) {\r\n            r = options.scrypt.r\r\n        }\r\n        if (options.scrypt.p) {\r\n            p = options.scrypt.p\r\n        }\r\n    }\r\n    assertArgument(\r\n        typeof N === \"number\" &&\r\n            N > 0 &&\r\n            Number.isSafeInteger(N) &&\r\n            (BigInt(N) & BigInt(N - 1)) === BigInt(0),\r\n        \"invalid scrypt N parameter\",\r\n        \"options.N\",\r\n        N,\r\n    )\r\n    assertArgument(\r\n        typeof r === \"number\" && r > 0 && Number.isSafeInteger(r),\r\n        \"invalid scrypt r parameter\",\r\n        \"options.r\",\r\n        r,\r\n    )\r\n    assertArgument(\r\n        typeof p === \"number\" && p > 0 && Number.isSafeInteger(p),\r\n        \"invalid scrypt p parameter\",\r\n        \"options.p\",\r\n        p,\r\n    )\r\n    return {\r\n        name: \"scrypt\",\r\n        dkLen: 32,\r\n        salt: salt,\r\n        N: N,\r\n        r: r,\r\n        p: p,\r\n    }\r\n}\r\nfunction _encryptKeystore(key, kdf, account, options) {\r\n    const privateKey = getBytes(account.privateKey, \"privateKey\")\r\n    const iv =\r\n        options.iv != null\r\n            ? getBytes(options.iv, \"options.iv\")\r\n            : randomBytes(16)\r\n    assertArgument(\r\n        iv.length === 16,\r\n        \"invalid options.iv length\",\r\n        \"options.iv\",\r\n        options.iv,\r\n    )\r\n    const uuidRandom =\r\n        options.uuid != null\r\n            ? getBytes(options.uuid, \"options.uuid\")\r\n            : randomBytes(16)\r\n    assertArgument(\r\n        uuidRandom.length === 16,\r\n        \"invalid options.uuid length\",\r\n        \"options.uuid\",\r\n        options.iv,\r\n    )\r\n    const derivedKey = key.slice(0, 16)\r\n    const macPrefix = key.slice(16, 32)\r\n    const aesCtr = new CTR(derivedKey, iv)\r\n    const ciphertext = getBytes(aesCtr.encrypt(privateKey))\r\n    const mac = keccak256(concat([macPrefix, ciphertext]))\r\n    const data = {\r\n        address: account.address.substring(2).toLowerCase(),\r\n        id: uuidV4(uuidRandom),\r\n        version: 3,\r\n        Crypto: {\r\n            cipher: \"aes-128-ctr\",\r\n            cipherparams: {\r\n                iv: hexlify(iv).substring(2),\r\n            },\r\n            ciphertext: hexlify(ciphertext).substring(2),\r\n            kdf: \"scrypt\",\r\n            kdfparams: {\r\n                salt: hexlify(kdf.salt).substring(2),\r\n                n: kdf.N,\r\n                dklen: 32,\r\n                p: kdf.p,\r\n                r: kdf.r,\r\n            },\r\n            mac: mac.substring(2),\r\n        },\r\n    }\r\n    if (account.mnemonic) {\r\n        const client =\r\n            options.client != null ? options.client : `ethers/${version}`\r\n        const path = account.mnemonic.path || defaultPath$1\r\n        const locale = account.mnemonic.locale || \"en\"\r\n        const mnemonicKey = key.slice(32, 64)\r\n        const entropy = getBytes(\r\n            account.mnemonic.entropy,\r\n            \"account.mnemonic.entropy\",\r\n        )\r\n        const mnemonicIv = randomBytes(16)\r\n        const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv)\r\n        const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy))\r\n        const now = new Date()\r\n        const timestamp =\r\n            now.getUTCFullYear() +\r\n            \"-\" +\r\n            zpad$1(now.getUTCMonth() + 1, 2) +\r\n            \"-\" +\r\n            zpad$1(now.getUTCDate(), 2) +\r\n            \"T\" +\r\n            zpad$1(now.getUTCHours(), 2) +\r\n            \"-\" +\r\n            zpad$1(now.getUTCMinutes(), 2) +\r\n            \"-\" +\r\n            zpad$1(now.getUTCSeconds(), 2) +\r\n            \".0Z\"\r\n        const gethFilename = \"UTC--\" + timestamp + \"--\" + data.address\r\n        data[\"x-ethers\"] = {\r\n            client: client,\r\n            gethFilename: gethFilename,\r\n            path: path,\r\n            locale: locale,\r\n            mnemonicCounter: hexlify(mnemonicIv).substring(2),\r\n            mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\r\n            version: \"0.1\",\r\n        }\r\n    }\r\n    return JSON.stringify(data)\r\n}\r\nfunction encryptKeystoreJsonSync(account, password, options) {\r\n    if (options == null) {\r\n        options = {}\r\n    }\r\n    const passwordBytes = getPassword(password)\r\n    const kdf = getEncryptKdfParams(options)\r\n    const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64)\r\n    return _encryptKeystore(getBytes(key), kdf, account, options)\r\n}\r\nasync function encryptKeystoreJson(account, password, options) {\r\n    if (options == null) {\r\n        options = {}\r\n    }\r\n    const passwordBytes = getPassword(password)\r\n    const kdf = getEncryptKdfParams(options)\r\n    const key = await scrypt(\r\n        passwordBytes,\r\n        kdf.salt,\r\n        kdf.N,\r\n        kdf.r,\r\n        kdf.p,\r\n        64,\r\n        options.progressCallback,\r\n    )\r\n    return _encryptKeystore(getBytes(key), kdf, account, options)\r\n}\r\nconst defaultPath = \"m/44'/60'/0'/0/0\"\r\nconst MasterSecret = new Uint8Array([\r\n    66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100,\r\n])\r\nconst HardenedBit = 2147483648\r\nconst N = BigInt(\r\n    \"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\",\r\n)\r\nconst Nibbles = \"0123456789abcdef\"\r\nfunction zpad(value, length) {\r\n    let result = \"\"\r\n    while (value) {\r\n        result = Nibbles[value % 16] + result\r\n        value = Math.trunc(value / 16)\r\n    }\r\n    while (result.length < length * 2) {\r\n        result = \"0\" + result\r\n    }\r\n    return \"0x\" + result\r\n}\r\nfunction encodeBase58Check(_value) {\r\n    const value = getBytes(_value)\r\n    const check = dataSlice(sha256(sha256(value)), 0, 4)\r\n    const bytes = concat([value, check])\r\n    return encodeBase58(bytes)\r\n}\r\nconst _guard = {}\r\nfunction ser_I(index, chainCode, publicKey, privateKey) {\r\n    const data = new Uint8Array(37)\r\n    if (index & HardenedBit) {\r\n        assert(\r\n            privateKey != null,\r\n            \"cannot derive child of neutered node\",\r\n            \"UNSUPPORTED_OPERATION\",\r\n            {\r\n                operation: \"deriveChild\",\r\n            },\r\n        )\r\n        data.set(getBytes(privateKey), 1)\r\n    } else {\r\n        data.set(getBytes(publicKey))\r\n    }\r\n    for (let i = 24; i >= 0; i -= 8) {\r\n        data[33 + (i >> 3)] = (index >> (24 - i)) & 255\r\n    }\r\n    const I = getBytes(computeHmac(\"sha512\", chainCode, data))\r\n    return {\r\n        IL: I.slice(0, 32),\r\n        IR: I.slice(32),\r\n    }\r\n}\r\nfunction derivePath(node, path) {\r\n    const components = path.split(\"/\")\r\n    assertArgument(\r\n        components.length > 0 && (components[0] === \"m\" || node.depth > 0),\r\n        \"invalid path\",\r\n        \"path\",\r\n        path,\r\n    )\r\n    if (components[0] === \"m\") {\r\n        components.shift()\r\n    }\r\n    let result = node\r\n    for (let i = 0; i < components.length; i++) {\r\n        const component = components[i]\r\n        if (component.match(/^[0-9]+'$/)) {\r\n            const index = parseInt(component.substring(0, component.length - 1))\r\n            assertArgument(\r\n                index < HardenedBit,\r\n                \"invalid path index\",\r\n                `path[${i}]`,\r\n                component,\r\n            )\r\n            result = result.deriveChild(HardenedBit + index)\r\n        } else if (component.match(/^[0-9]+$/)) {\r\n            const index = parseInt(component)\r\n            assertArgument(\r\n                index < HardenedBit,\r\n                \"invalid path index\",\r\n                `path[${i}]`,\r\n                component,\r\n            )\r\n            result = result.deriveChild(index)\r\n        } else {\r\n            assertArgument(\r\n                false,\r\n                \"invalid path component\",\r\n                `path[${i}]`,\r\n                component,\r\n            )\r\n        }\r\n    }\r\n    return result\r\n}\r\nclass HDNodeWallet extends BaseWallet {\r\n    publicKey\r\n    fingerprint\r\n    parentFingerprint\r\n    mnemonic\r\n    chainCode\r\n    path\r\n    index\r\n    depth\r\n    constructor(\r\n        guard,\r\n        signingKey,\r\n        parentFingerprint,\r\n        chainCode,\r\n        path,\r\n        index,\r\n        depth,\r\n        mnemonic,\r\n        provider,\r\n    ) {\r\n        super(signingKey, provider)\r\n        assertPrivate(guard, _guard, \"HDNodeWallet\")\r\n        defineProperties(this, {\r\n            publicKey: signingKey.compressedPublicKey,\r\n        })\r\n        const fingerprint = dataSlice(ripemd160(sha256(this.publicKey)), 0, 4)\r\n        defineProperties(this, {\r\n            parentFingerprint: parentFingerprint,\r\n            fingerprint: fingerprint,\r\n            chainCode: chainCode,\r\n            path: path,\r\n            index: index,\r\n            depth: depth,\r\n        })\r\n        defineProperties(this, {\r\n            mnemonic: mnemonic,\r\n        })\r\n    }\r\n    connect(provider) {\r\n        return new HDNodeWallet(\r\n            _guard,\r\n            this.signingKey,\r\n            this.parentFingerprint,\r\n            this.chainCode,\r\n            this.path,\r\n            this.index,\r\n            this.depth,\r\n            this.mnemonic,\r\n            provider,\r\n        )\r\n    }\r\n    #account() {\r\n        const account = {\r\n            address: this.address,\r\n            privateKey: this.privateKey,\r\n        }\r\n        const m = this.mnemonic\r\n        if (this.path && m && m.wordlist.locale === \"en\" && m.password === \"\") {\r\n            account.mnemonic = {\r\n                path: this.path,\r\n                locale: \"en\",\r\n                entropy: m.entropy,\r\n            }\r\n        }\r\n        return account\r\n    }\r\n    async encrypt(password, progressCallback) {\r\n        return await encryptKeystoreJson(this.#account(), password, {\r\n            progressCallback: progressCallback,\r\n        })\r\n    }\r\n    encryptSync(password) {\r\n        return encryptKeystoreJsonSync(this.#account(), password)\r\n    }\r\n    get extendedKey() {\r\n        assert(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"extendedKey\",\r\n        })\r\n        return encodeBase58Check(\r\n            concat([\r\n                \"0x0488ADE4\",\r\n                zpad(this.depth, 1),\r\n                this.parentFingerprint,\r\n                zpad(this.index, 4),\r\n                this.chainCode,\r\n                concat([\"0x00\", this.privateKey]),\r\n            ]),\r\n        )\r\n    }\r\n    hasPath() {\r\n        return this.path != null\r\n    }\r\n    neuter() {\r\n        return new HDNodeVoidWallet(\r\n            _guard,\r\n            this.address,\r\n            this.publicKey,\r\n            this.parentFingerprint,\r\n            this.chainCode,\r\n            this.path,\r\n            this.index,\r\n            this.depth,\r\n            this.provider,\r\n        )\r\n    }\r\n    deriveChild(_index) {\r\n        const index = getNumber(_index, \"index\")\r\n        assertArgument(index <= 4294967295, \"invalid index\", \"index\", index)\r\n        let path = this.path\r\n        if (path) {\r\n            path += \"/\" + (index & ~HardenedBit)\r\n            if (index & HardenedBit) {\r\n                path += \"'\"\r\n            }\r\n        }\r\n        const { IR, IL } = ser_I(\r\n            index,\r\n            this.chainCode,\r\n            this.publicKey,\r\n            this.privateKey,\r\n        )\r\n        const ki = new SigningKey(\r\n            toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32),\r\n        )\r\n        return new HDNodeWallet(\r\n            _guard,\r\n            ki,\r\n            this.fingerprint,\r\n            hexlify(IR),\r\n            path,\r\n            index,\r\n            this.depth + 1,\r\n            this.mnemonic,\r\n            this.provider,\r\n        )\r\n    }\r\n    derivePath(path) {\r\n        return derivePath(this, path)\r\n    }\r\n    static #fromSeed(_seed, mnemonic) {\r\n        assertArgument(isBytesLike(_seed), \"invalid seed\", \"seed\", \"[REDACTED]\")\r\n        const seed = getBytes(_seed, \"seed\")\r\n        assertArgument(\r\n            seed.length >= 16 && seed.length <= 64,\r\n            \"invalid seed\",\r\n            \"seed\",\r\n            \"[REDACTED]\",\r\n        )\r\n        const I = getBytes(computeHmac(\"sha512\", MasterSecret, seed))\r\n        const signingKey = new SigningKey(hexlify(I.slice(0, 32)))\r\n        return new HDNodeWallet(\r\n            _guard,\r\n            signingKey,\r\n            \"0x00000000\",\r\n            hexlify(I.slice(32)),\r\n            \"m\",\r\n            0,\r\n            0,\r\n            mnemonic,\r\n            null,\r\n        )\r\n    }\r\n    static fromExtendedKey(extendedKey) {\r\n        const bytes = toBeArray(decodeBase58(extendedKey))\r\n        assertArgument(\r\n            bytes.length === 82 ||\r\n                encodeBase58Check(bytes.slice(0, 78)) === extendedKey,\r\n            \"invalid extended key\",\r\n            \"extendedKey\",\r\n            \"[ REDACTED ]\",\r\n        )\r\n        const depth = bytes[4]\r\n        const parentFingerprint = hexlify(bytes.slice(5, 9))\r\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16)\r\n        const chainCode = hexlify(bytes.slice(13, 45))\r\n        const key = bytes.slice(45, 78)\r\n        switch (hexlify(bytes.slice(0, 4))) {\r\n            case \"0x0488b21e\":\r\n            case \"0x043587cf\": {\r\n                const publicKey = hexlify(key)\r\n                return new HDNodeVoidWallet(\r\n                    _guard,\r\n                    computeAddress(publicKey),\r\n                    publicKey,\r\n                    parentFingerprint,\r\n                    chainCode,\r\n                    null,\r\n                    index,\r\n                    depth,\r\n                    null,\r\n                )\r\n            }\r\n            case \"0x0488ade4\":\r\n            case \"0x04358394 \":\r\n                if (key[0] !== 0) {\r\n                    break\r\n                }\r\n                return new HDNodeWallet(\r\n                    _guard,\r\n                    new SigningKey(key.slice(1)),\r\n                    parentFingerprint,\r\n                    chainCode,\r\n                    null,\r\n                    index,\r\n                    depth,\r\n                    null,\r\n                    null,\r\n                )\r\n        }\r\n        assertArgument(\r\n            false,\r\n            \"invalid extended key prefix\",\r\n            \"extendedKey\",\r\n            \"[ REDACTED ]\",\r\n        )\r\n    }\r\n    static createRandom(password, path, wordlist) {\r\n        if (password == null) {\r\n            password = \"\"\r\n        }\r\n        if (path == null) {\r\n            path = defaultPath\r\n        }\r\n        if (wordlist == null) {\r\n            wordlist = LangEn.wordlist()\r\n        }\r\n        const mnemonic = Mnemonic.fromEntropy(\r\n            randomBytes(16),\r\n            password,\r\n            wordlist,\r\n        )\r\n        return HDNodeWallet.#fromSeed(\r\n            mnemonic.computeSeed(),\r\n            mnemonic,\r\n        ).derivePath(path)\r\n    }\r\n    static fromMnemonic(mnemonic, path) {\r\n        if (!path) {\r\n            path = defaultPath\r\n        }\r\n        return HDNodeWallet.#fromSeed(\r\n            mnemonic.computeSeed(),\r\n            mnemonic,\r\n        ).derivePath(path)\r\n    }\r\n    static fromPhrase(phrase, password, path, wordlist) {\r\n        if (password == null) {\r\n            password = \"\"\r\n        }\r\n        if (path == null) {\r\n            path = defaultPath\r\n        }\r\n        if (wordlist == null) {\r\n            wordlist = LangEn.wordlist()\r\n        }\r\n        const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist)\r\n        return HDNodeWallet.#fromSeed(\r\n            mnemonic.computeSeed(),\r\n            mnemonic,\r\n        ).derivePath(path)\r\n    }\r\n    static fromSeed(seed) {\r\n        return HDNodeWallet.#fromSeed(seed, null)\r\n    }\r\n}\r\nclass HDNodeVoidWallet extends VoidSigner {\r\n    publicKey\r\n    fingerprint\r\n    parentFingerprint\r\n    chainCode\r\n    path\r\n    index\r\n    depth\r\n    constructor(\r\n        guard,\r\n        address,\r\n        publicKey,\r\n        parentFingerprint,\r\n        chainCode,\r\n        path,\r\n        index,\r\n        depth,\r\n        provider,\r\n    ) {\r\n        super(address, provider)\r\n        assertPrivate(guard, _guard, \"HDNodeVoidWallet\")\r\n        defineProperties(this, {\r\n            publicKey: publicKey,\r\n        })\r\n        const fingerprint = dataSlice(ripemd160(sha256(publicKey)), 0, 4)\r\n        defineProperties(this, {\r\n            publicKey: publicKey,\r\n            fingerprint: fingerprint,\r\n            parentFingerprint: parentFingerprint,\r\n            chainCode: chainCode,\r\n            path: path,\r\n            index: index,\r\n            depth: depth,\r\n        })\r\n    }\r\n    connect(provider) {\r\n        return new HDNodeVoidWallet(\r\n            _guard,\r\n            this.address,\r\n            this.publicKey,\r\n            this.parentFingerprint,\r\n            this.chainCode,\r\n            this.path,\r\n            this.index,\r\n            this.depth,\r\n            provider,\r\n        )\r\n    }\r\n    get extendedKey() {\r\n        assert(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", {\r\n            operation: \"extendedKey\",\r\n        })\r\n        return encodeBase58Check(\r\n            concat([\r\n                \"0x0488B21E\",\r\n                zpad(this.depth, 1),\r\n                this.parentFingerprint,\r\n                zpad(this.index, 4),\r\n                this.chainCode,\r\n                this.publicKey,\r\n            ]),\r\n        )\r\n    }\r\n    hasPath() {\r\n        return this.path != null\r\n    }\r\n    deriveChild(_index) {\r\n        const index = getNumber(_index, \"index\")\r\n        assertArgument(index <= 4294967295, \"invalid index\", \"index\", index)\r\n        let path = this.path\r\n        if (path) {\r\n            path += \"/\" + (index & ~HardenedBit)\r\n            if (index & HardenedBit) {\r\n                path += \"'\"\r\n            }\r\n        }\r\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null)\r\n        const Ki = SigningKey.addPoints(IL, this.publicKey, true)\r\n        const address = computeAddress(Ki)\r\n        return new HDNodeVoidWallet(\r\n            _guard,\r\n            address,\r\n            Ki,\r\n            this.fingerprint,\r\n            hexlify(IR),\r\n            path,\r\n            index,\r\n            this.depth + 1,\r\n            this.provider,\r\n        )\r\n    }\r\n    derivePath(path) {\r\n        return derivePath(this, path)\r\n    }\r\n}\r\nfunction getAccountPath(_index) {\r\n    const index = getNumber(_index, \"index\")\r\n    assertArgument(\r\n        index >= 0 && index < HardenedBit,\r\n        \"invalid account index\",\r\n        \"index\",\r\n        index,\r\n    )\r\n    return `m/44'/60'/${index}'/0/0`\r\n}\r\nfunction getIndexedAccountPath(_index) {\r\n    const index = getNumber(_index, \"index\")\r\n    assertArgument(\r\n        index >= 0 && index < HardenedBit,\r\n        \"invalid account index\",\r\n        \"index\",\r\n        index,\r\n    )\r\n    return `m/44'/60'/0'/0/${index}`\r\n}\r\nfunction isCrowdsaleJson(json) {\r\n    try {\r\n        const data = JSON.parse(json)\r\n        if (data.encseed) {\r\n            return true\r\n        }\r\n    } catch (error) {}\r\n    return false\r\n}\r\nfunction decryptCrowdsaleJson(json, _password) {\r\n    const data = JSON.parse(json)\r\n    const password = getPassword(_password)\r\n    const address = getAddress(spelunk(data, \"ethaddr:string!\"))\r\n    const encseed = looseArrayify(spelunk(data, \"encseed:string!\"))\r\n    assertArgument(\r\n        encseed && encseed.length % 16 === 0,\r\n        \"invalid encseed\",\r\n        \"json\",\r\n        json,\r\n    )\r\n    const key = getBytes(pbkdf2(password, password, 2e3, 32, \"sha256\")).slice(\r\n        0,\r\n        16,\r\n    )\r\n    const iv = encseed.slice(0, 16)\r\n    const encryptedSeed = encseed.slice(16)\r\n    const aesCbc = new CBC(key, iv)\r\n    const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)))\r\n    let seedHex = \"\"\r\n    for (let i = 0; i < seed.length; i++) {\r\n        seedHex += String.fromCharCode(seed[i])\r\n    }\r\n    return {\r\n        address: address,\r\n        privateKey: id(seedHex),\r\n    }\r\n}\r\nfunction stall(duration) {\r\n    return new Promise((resolve) => {\r\n        setTimeout(() => {\r\n            resolve()\r\n        }, duration)\r\n    })\r\n}\r\nclass Wallet extends BaseWallet {\r\n    constructor(key, provider) {\r\n        if (typeof key === \"string\" && !key.startsWith(\"0x\")) {\r\n            key = \"0x\" + key\r\n        }\r\n        let signingKey = typeof key === \"string\" ? new SigningKey(key) : key\r\n        super(signingKey, provider)\r\n    }\r\n    connect(provider) {\r\n        return new Wallet(this.signingKey, provider)\r\n    }\r\n    async encrypt(password, progressCallback) {\r\n        const account = {\r\n            address: this.address,\r\n            privateKey: this.privateKey,\r\n        }\r\n        return await encryptKeystoreJson(account, password, {\r\n            progressCallback: progressCallback,\r\n        })\r\n    }\r\n    encryptSync(password) {\r\n        const account = {\r\n            address: this.address,\r\n            privateKey: this.privateKey,\r\n        }\r\n        return encryptKeystoreJsonSync(account, password)\r\n    }\r\n    static #fromAccount(account) {\r\n        assertArgument(account, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\")\r\n        if (\r\n            \"mnemonic\" in account &&\r\n            account.mnemonic &&\r\n            account.mnemonic.locale === \"en\"\r\n        ) {\r\n            const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy)\r\n            const wallet = HDNodeWallet.fromMnemonic(\r\n                mnemonic,\r\n                account.mnemonic.path,\r\n            )\r\n            if (\r\n                wallet.address === account.address &&\r\n                wallet.privateKey === account.privateKey\r\n            ) {\r\n                return wallet\r\n            }\r\n            console.log(\r\n                \"WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key\",\r\n            )\r\n        }\r\n        const wallet = new Wallet(account.privateKey)\r\n        assertArgument(\r\n            wallet.address === account.address,\r\n            \"address/privateKey mismatch\",\r\n            \"json\",\r\n            \"[ REDACTED ]\",\r\n        )\r\n        return wallet\r\n    }\r\n    static async fromEncryptedJson(json, password, progress) {\r\n        let account = null\r\n        if (isKeystoreJson(json)) {\r\n            account = await decryptKeystoreJson(json, password, progress)\r\n        } else if (isCrowdsaleJson(json)) {\r\n            if (progress) {\r\n                progress(0)\r\n                await stall(0)\r\n            }\r\n            account = decryptCrowdsaleJson(json, password)\r\n            if (progress) {\r\n                progress(1)\r\n                await stall(0)\r\n            }\r\n        }\r\n        return Wallet.#fromAccount(account)\r\n    }\r\n    static fromEncryptedJsonSync(json, password) {\r\n        let account = null\r\n        if (isKeystoreJson(json)) {\r\n            account = decryptKeystoreJsonSync(json, password)\r\n        } else if (isCrowdsaleJson(json)) {\r\n            account = decryptCrowdsaleJson(json, password)\r\n        } else {\r\n            assertArgument(false, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\")\r\n        }\r\n        return Wallet.#fromAccount(account)\r\n    }\r\n    static createRandom(provider) {\r\n        const wallet = HDNodeWallet.createRandom()\r\n        if (provider) {\r\n            return wallet.connect(provider)\r\n        }\r\n        return wallet\r\n    }\r\n    static fromPhrase(phrase, provider) {\r\n        const wallet = HDNodeWallet.fromPhrase(phrase)\r\n        if (provider) {\r\n            return wallet.connect(provider)\r\n        }\r\n        return wallet\r\n    }\r\n}\r\nconst Base64 =\r\n    \")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\"\r\nfunction decodeBits(width, data) {\r\n    const maxValue = (1 << width) - 1\r\n    const result = []\r\n    let accum = 0,\r\n        bits = 0,\r\n        flood = 0\r\n    for (let i = 0; i < data.length; i++) {\r\n        accum = (accum << 6) | Base64.indexOf(data[i])\r\n        bits += 6\r\n        while (bits >= width) {\r\n            const value = accum >> (bits - width)\r\n            accum &= (1 << (bits - width)) - 1\r\n            bits -= width\r\n            if (value === 0) {\r\n                flood += maxValue\r\n            } else {\r\n                result.push(value + flood)\r\n                flood = 0\r\n            }\r\n        }\r\n    }\r\n    return result\r\n}\r\nfunction decodeOwlA(data, accents) {\r\n    let words = decodeOwl(data).join(\",\")\r\n    accents.split(/,/g).forEach((accent) => {\r\n        const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/)\r\n        assertArgument(\r\n            match !== null,\r\n            \"internal error parsing accents\",\r\n            \"accents\",\r\n            accents,\r\n        )\r\n        let posOffset = 0\r\n        const positions = decodeBits(parseInt(match[3]), match[4])\r\n        const charCode = parseInt(match[2])\r\n        const regex = new RegExp(`([${match[1]}])`, \"g\")\r\n        words = words.replace(regex, (all, letter) => {\r\n            const rem = --positions[posOffset]\r\n            if (rem === 0) {\r\n                letter = String.fromCharCode(letter.charCodeAt(0), charCode)\r\n                posOffset++\r\n            }\r\n            return letter\r\n        })\r\n    })\r\n    return words.split(\",\")\r\n}\r\nclass WordlistOwlA extends WordlistOwl {\r\n    #accent\r\n    constructor(locale, data, accent, checksum) {\r\n        super(locale, data, checksum)\r\n        this.#accent = accent\r\n    }\r\n    get _accent() {\r\n        return this.#accent\r\n    }\r\n    _decodeWords() {\r\n        return decodeOwlA(this._data, this._accent)\r\n    }\r\n}\r\nconst wordlists = {\r\n    en: LangEn.wordlist(),\r\n}\r\nvar ethers = Object.freeze({\r\n    __proto__: null,\r\n    AbiCoder: AbiCoder,\r\n    AbstractProvider: AbstractProvider,\r\n    AbstractSigner: AbstractSigner,\r\n    AlchemyProvider: AlchemyProvider,\r\n    AnkrProvider: AnkrProvider,\r\n    BaseContract: BaseContract,\r\n    BaseWallet: BaseWallet,\r\n    Block: Block,\r\n    BrowserProvider: BrowserProvider,\r\n    CloudflareProvider: CloudflareProvider,\r\n    ConstructorFragment: ConstructorFragment,\r\n    Contract: Contract,\r\n    ContractEventPayload: ContractEventPayload,\r\n    ContractFactory: ContractFactory,\r\n    ContractTransactionReceipt: ContractTransactionReceipt,\r\n    ContractTransactionResponse: ContractTransactionResponse,\r\n    ContractUnknownEventPayload: ContractUnknownEventPayload,\r\n    EnsPlugin: EnsPlugin,\r\n    EnsResolver: EnsResolver,\r\n    ErrorDescription: ErrorDescription,\r\n    ErrorFragment: ErrorFragment,\r\n    EtherSymbol: EtherSymbol,\r\n    EtherscanPlugin: EtherscanPlugin,\r\n    EtherscanProvider: EtherscanProvider,\r\n    EventFragment: EventFragment,\r\n    EventLog: EventLog,\r\n    EventPayload: EventPayload,\r\n    FallbackFragment: FallbackFragment,\r\n    FallbackProvider: FallbackProvider,\r\n    FeeData: FeeData,\r\n    FeeDataNetworkPlugin: FeeDataNetworkPlugin,\r\n    FetchCancelSignal: FetchCancelSignal,\r\n    FetchRequest: FetchRequest,\r\n    FetchResponse: FetchResponse,\r\n    FetchUrlFeeDataNetworkPlugin: FetchUrlFeeDataNetworkPlugin,\r\n    FixedNumber: FixedNumber,\r\n    Fragment: Fragment,\r\n    FunctionFragment: FunctionFragment,\r\n    GasCostPlugin: GasCostPlugin,\r\n    HDNodeVoidWallet: HDNodeVoidWallet,\r\n    HDNodeWallet: HDNodeWallet,\r\n    Indexed: Indexed,\r\n    InfuraProvider: InfuraProvider,\r\n    InfuraWebSocketProvider: InfuraWebSocketProvider,\r\n    Interface: Interface,\r\n    IpcSocketProvider: IpcSocketProvider,\r\n    JsonRpcApiProvider: JsonRpcApiProvider,\r\n    JsonRpcProvider: JsonRpcProvider,\r\n    JsonRpcSigner: JsonRpcSigner,\r\n    LangEn: LangEn,\r\n    Log: Log,\r\n    LogDescription: LogDescription,\r\n    MaxInt256: MaxInt256,\r\n    MaxUint256: MaxUint256,\r\n    MessagePrefix: MessagePrefix,\r\n    MinInt256: MinInt256,\r\n    Mnemonic: Mnemonic,\r\n    MulticoinProviderPlugin: MulticoinProviderPlugin,\r\n    N: N$1,\r\n    NamedFragment: NamedFragment,\r\n    Network: Network,\r\n    NetworkPlugin: NetworkPlugin,\r\n    NonceManager: NonceManager,\r\n    ParamType: ParamType,\r\n    PocketProvider: PocketProvider,\r\n    QuickNodeProvider: QuickNodeProvider,\r\n    Result: Result,\r\n    Signature: Signature,\r\n    SigningKey: SigningKey,\r\n    SocketBlockSubscriber: SocketBlockSubscriber,\r\n    SocketEventSubscriber: SocketEventSubscriber,\r\n    SocketPendingSubscriber: SocketPendingSubscriber,\r\n    SocketProvider: SocketProvider,\r\n    SocketSubscriber: SocketSubscriber,\r\n    StructFragment: StructFragment,\r\n    Transaction: Transaction,\r\n    TransactionDescription: TransactionDescription,\r\n    TransactionReceipt: TransactionReceipt,\r\n    TransactionResponse: TransactionResponse,\r\n    Typed: Typed,\r\n    TypedDataEncoder: TypedDataEncoder,\r\n    UndecodedEventLog: UndecodedEventLog,\r\n    UnmanagedSubscriber: UnmanagedSubscriber,\r\n    Utf8ErrorFuncs: Utf8ErrorFuncs,\r\n    VoidSigner: VoidSigner,\r\n    Wallet: Wallet,\r\n    WebSocketProvider: WebSocketProvider,\r\n    WeiPerEther: WeiPerEther,\r\n    Wordlist: Wordlist,\r\n    WordlistOwl: WordlistOwl,\r\n    WordlistOwlA: WordlistOwlA,\r\n    ZeroAddress: ZeroAddress,\r\n    ZeroHash: ZeroHash,\r\n    accessListify: accessListify,\r\n    assert: assert,\r\n    assertArgument: assertArgument,\r\n    assertArgumentCount: assertArgumentCount,\r\n    assertNormalize: assertNormalize,\r\n    assertPrivate: assertPrivate,\r\n    checkResultErrors: checkResultErrors,\r\n    computeAddress: computeAddress,\r\n    computeHmac: computeHmac,\r\n    concat: concat,\r\n    copyRequest: copyRequest,\r\n    dataLength: dataLength,\r\n    dataSlice: dataSlice,\r\n    decodeBase58: decodeBase58,\r\n    decodeBase64: decodeBase64,\r\n    decodeBytes32String: decodeBytes32String,\r\n    decodeRlp: decodeRlp,\r\n    decryptCrowdsaleJson: decryptCrowdsaleJson,\r\n    decryptKeystoreJson: decryptKeystoreJson,\r\n    decryptKeystoreJsonSync: decryptKeystoreJsonSync,\r\n    defaultPath: defaultPath,\r\n    defineProperties: defineProperties,\r\n    dnsEncode: dnsEncode,\r\n    encodeBase58: encodeBase58,\r\n    encodeBase64: encodeBase64,\r\n    encodeBytes32String: encodeBytes32String,\r\n    encodeRlp: encodeRlp,\r\n    encryptKeystoreJson: encryptKeystoreJson,\r\n    encryptKeystoreJsonSync: encryptKeystoreJsonSync,\r\n    ensNormalize: ensNormalize,\r\n    formatEther: formatEther,\r\n    formatUnits: formatUnits,\r\n    fromTwos: fromTwos,\r\n    getAccountPath: getAccountPath,\r\n    getAddress: getAddress,\r\n    getBigInt: getBigInt,\r\n    getBytes: getBytes,\r\n    getBytesCopy: getBytesCopy,\r\n    getCreate2Address: getCreate2Address,\r\n    getCreateAddress: getCreateAddress,\r\n    getDefaultProvider: getDefaultProvider,\r\n    getIcapAddress: getIcapAddress,\r\n    getIndexedAccountPath: getIndexedAccountPath,\r\n    getNumber: getNumber,\r\n    getUint: getUint,\r\n    hashMessage: hashMessage,\r\n    hexlify: hexlify,\r\n    id: id,\r\n    isAddress: isAddress,\r\n    isAddressable: isAddressable,\r\n    isBytesLike: isBytesLike,\r\n    isCallException: isCallException,\r\n    isCrowdsaleJson: isCrowdsaleJson,\r\n    isError: isError,\r\n    isHexString: isHexString,\r\n    isKeystoreJson: isKeystoreJson,\r\n    isValidName: isValidName,\r\n    keccak256: keccak256,\r\n    lock: lock,\r\n    makeError: makeError,\r\n    mask: mask,\r\n    namehash: namehash,\r\n    parseEther: parseEther,\r\n    parseUnits: parseUnits$1,\r\n    pbkdf2: pbkdf2,\r\n    randomBytes: randomBytes,\r\n    recoverAddress: recoverAddress,\r\n    resolveAddress: resolveAddress,\r\n    resolveProperties: resolveProperties,\r\n    ripemd160: ripemd160,\r\n    scrypt: scrypt,\r\n    scryptSync: scryptSync,\r\n    sha256: sha256,\r\n    sha512: sha512,\r\n    showThrottleMessage: showThrottleMessage,\r\n    solidityPacked: solidityPacked,\r\n    solidityPackedKeccak256: solidityPackedKeccak256,\r\n    solidityPackedSha256: solidityPackedSha256,\r\n    stripZerosLeft: stripZerosLeft,\r\n    toBeArray: toBeArray,\r\n    toBeHex: toBeHex,\r\n    toBigInt: toBigInt,\r\n    toNumber: toNumber,\r\n    toQuantity: toQuantity,\r\n    toTwos: toTwos,\r\n    toUtf8Bytes: toUtf8Bytes,\r\n    toUtf8CodePoints: toUtf8CodePoints,\r\n    toUtf8String: toUtf8String,\r\n    uuidV4: uuidV4,\r\n    verifyMessage: verifyMessage,\r\n    verifyTypedData: verifyTypedData,\r\n    version: version,\r\n    wordlists: wordlists,\r\n    zeroPadBytes: zeroPadBytes,\r\n    zeroPadValue: zeroPadValue,\r\n})\r\nexport {\r\n    AbiCoder,\r\n    AbstractProvider,\r\n    AbstractSigner,\r\n    AlchemyProvider,\r\n    AnkrProvider,\r\n    BaseContract,\r\n    BaseWallet,\r\n    Block,\r\n    BrowserProvider,\r\n    CloudflareProvider,\r\n    ConstructorFragment,\r\n    Contract,\r\n    ContractEventPayload,\r\n    ContractFactory,\r\n    ContractTransactionReceipt,\r\n    ContractTransactionResponse,\r\n    ContractUnknownEventPayload,\r\n    EnsPlugin,\r\n    EnsResolver,\r\n    ErrorDescription,\r\n    ErrorFragment,\r\n    EtherSymbol,\r\n    EtherscanPlugin,\r\n    EtherscanProvider,\r\n    EventFragment,\r\n    EventLog,\r\n    EventPayload,\r\n    FallbackFragment,\r\n    FallbackProvider,\r\n    FeeData,\r\n    FeeDataNetworkPlugin,\r\n    FetchCancelSignal,\r\n    FetchRequest,\r\n    FetchResponse,\r\n    FetchUrlFeeDataNetworkPlugin,\r\n    FixedNumber,\r\n    Fragment,\r\n    FunctionFragment,\r\n    GasCostPlugin,\r\n    HDNodeVoidWallet,\r\n    HDNodeWallet,\r\n    Indexed,\r\n    InfuraProvider,\r\n    InfuraWebSocketProvider,\r\n    Interface,\r\n    IpcSocketProvider,\r\n    JsonRpcApiProvider,\r\n    JsonRpcProvider,\r\n    JsonRpcSigner,\r\n    LangEn,\r\n    Log,\r\n    LogDescription,\r\n    MaxInt256,\r\n    MaxUint256,\r\n    MessagePrefix,\r\n    MinInt256,\r\n    Mnemonic,\r\n    MulticoinProviderPlugin,\r\n    N$1 as N,\r\n    NamedFragment,\r\n    Network,\r\n    NetworkPlugin,\r\n    NonceManager,\r\n    ParamType,\r\n    PocketProvider,\r\n    QuickNodeProvider,\r\n    Result,\r\n    Signature,\r\n    SigningKey,\r\n    SocketBlockSubscriber,\r\n    SocketEventSubscriber,\r\n    SocketPendingSubscriber,\r\n    SocketProvider,\r\n    SocketSubscriber,\r\n    StructFragment,\r\n    Transaction,\r\n    TransactionDescription,\r\n    TransactionReceipt,\r\n    TransactionResponse,\r\n    Typed,\r\n    TypedDataEncoder,\r\n    UndecodedEventLog,\r\n    UnmanagedSubscriber,\r\n    Utf8ErrorFuncs,\r\n    VoidSigner,\r\n    Wallet,\r\n    WebSocketProvider,\r\n    WeiPerEther,\r\n    Wordlist,\r\n    WordlistOwl,\r\n    WordlistOwlA,\r\n    ZeroAddress,\r\n    ZeroHash,\r\n    accessListify,\r\n    assert,\r\n    assertArgument,\r\n    assertArgumentCount,\r\n    assertNormalize,\r\n    assertPrivate,\r\n    checkResultErrors,\r\n    computeAddress,\r\n    computeHmac,\r\n    concat,\r\n    copyRequest,\r\n    dataLength,\r\n    dataSlice,\r\n    decodeBase58,\r\n    decodeBase64,\r\n    decodeBytes32String,\r\n    decodeRlp,\r\n    decryptCrowdsaleJson,\r\n    decryptKeystoreJson,\r\n    decryptKeystoreJsonSync,\r\n    defaultPath,\r\n    defineProperties,\r\n    dnsEncode,\r\n    encodeBase58,\r\n    encodeBase64,\r\n    encodeBytes32String,\r\n    encodeRlp,\r\n    encryptKeystoreJson,\r\n    encryptKeystoreJsonSync,\r\n    ensNormalize,\r\n    ethers,\r\n    formatEther,\r\n    formatUnits,\r\n    fromTwos,\r\n    getAccountPath,\r\n    getAddress,\r\n    getBigInt,\r\n    getBytes,\r\n    getBytesCopy,\r\n    getCreate2Address,\r\n    getCreateAddress,\r\n    getDefaultProvider,\r\n    getIcapAddress,\r\n    getIndexedAccountPath,\r\n    getNumber,\r\n    getUint,\r\n    hashMessage,\r\n    hexlify,\r\n    id,\r\n    isAddress,\r\n    isAddressable,\r\n    isBytesLike,\r\n    isCallException,\r\n    isCrowdsaleJson,\r\n    isError,\r\n    isHexString,\r\n    isKeystoreJson,\r\n    isValidName,\r\n    keccak256,\r\n    lock,\r\n    makeError,\r\n    mask,\r\n    namehash,\r\n    parseEther,\r\n    parseUnits$1 as parseUnits,\r\n    pbkdf2,\r\n    randomBytes,\r\n    recoverAddress,\r\n    resolveAddress,\r\n    resolveProperties,\r\n    ripemd160,\r\n    scrypt,\r\n    scryptSync,\r\n    sha256,\r\n    sha512,\r\n    showThrottleMessage,\r\n    solidityPacked,\r\n    solidityPackedKeccak256,\r\n    solidityPackedSha256,\r\n    stripZerosLeft,\r\n    toBeArray,\r\n    toBeHex,\r\n    toBigInt,\r\n    toNumber,\r\n    toQuantity,\r\n    toTwos,\r\n    toUtf8Bytes,\r\n    toUtf8CodePoints,\r\n    toUtf8String,\r\n    uuidV4,\r\n    verifyMessage,\r\n    verifyTypedData,\r\n    version,\r\n    wordlists,\r\n    zeroPadBytes,\r\n    zeroPadValue,\r\n}\r\n","'use strict';\n\nvar possibleNames = require('possible-typed-array-names');\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\n\n/** @type {import('.')} */\nmodule.exports = function availableTypedArrays() {\n\tvar /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\t// @ts-expect-error\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nc = undefined;","import \"./style.css\";\r\nimport { ethers } from \"./ethers.min.js\";\r\n\r\n// import { checkNetwork, switchNetwork } from \"../helper/EthereumRequests.js\";\r\nimport {\r\n  marketplaceContractAddress,\r\n  marketplaceAbi,\r\n} from \"../contracts/constants.js\";\r\n\r\nlet connected = false;\r\nconsole.log(connected);\r\n\r\nconst connect = document.getElementById(\"connect\");\r\n// const submit = document.getElementsByClassName(\"submit\");\r\nconst balance = document.getElementById(\"balance\");\r\nconst listCar = document.getElementById(\"listCar\");\r\nconst buttonsContainer = document.getElementById(\"buttonsContainer\");\r\nconst modalContainer = document.getElementById(\"modal-container\");\r\nconst balanceContainer = document.querySelector(\".balance-container\");\r\nconst notification = document.getElementById(\"notification\");\r\n\r\n// const cancelButton = document.getElementsByClassName(\".cancel\")\r\n\r\nconst name = document.getElementById(\"name\");\r\nconst model = document.getElementById(\"model\");\r\nconst year = document.getElementById(\"year\");\r\nconst image = document.getElementById(\"image\");\r\nconst location = document.getElementById(\"location\");\r\nconst price = document.getElementById(\"price\");\r\nconst details = document.getElementById(\"details\");\r\n\r\nconst targetChainId = \"0xaa36a7\";\r\n\r\ndocument.querySelector(\".cancel\").addEventListener(\"click\", () => {\r\n  modalContainer.classList.add(\"hidden\");\r\n});\r\n\r\ndocument.getElementById(\"cancelNotif\").addEventListener(\"click\", () => {\r\n  notification.classList.add(\"hidden\");\r\n});\r\n\r\n// document.querySelector\r\n\r\nlistCar.addEventListener(\"click\", () => {\r\n  modalContainer.classList.remove(\"hidden\");\r\n  modalContainer.classList.add(\"flex\");\r\n});\r\n\r\nname.addEventListener(\"click\", () => {\r\n  name.classList.remove(\"bg-[#e4e4e4]\");\r\n  name.classList.add(\"border\");\r\n  name.classList.add(\"border-solid\");\r\n  name.classList.add(\"border-blue-500\");\r\n});\r\n\r\nmodel.addEventListener(\"click\", () => {\r\n  model.classList.remove(\"bg-[#e4e4e4]\");\r\n  model.classList.add(\"border\");\r\n  model.classList.add(\"border-solid\");\r\n  model.classList.add(\"border-blue-500\");\r\n});\r\n\r\nyear.addEventListener(\"click\", () => {\r\n  year.classList.remove(\"bg-[#e4e4e4]\");\r\n  year.classList.add(\"border\");\r\n  year.classList.add(\"border-solid\");\r\n  year.classList.add(\"border-blue-500\");\r\n});\r\n\r\nimage.addEventListener(\"click\", () => {\r\n  image.classList.remove(\"bg-[#e4e4e4]\");\r\n  image.classList.add(\"border\");\r\n  image.classList.add(\"border-solid\");\r\n  image.classList.add(\"border-blue-500\");\r\n});\r\n\r\nlocation.addEventListener(\"click\", () => {\r\n  location.classList.remove(\"bg-[#e4e4e4]\");\r\n  location.classList.add(\"border\");\r\n  location.classList.add(\"border-solid\");\r\n  location.classList.add(\"border-blue-500\");\r\n});\r\n\r\nprice.addEventListener(\"click\", () => {\r\n  price.classList.remove(\"bg-[#e4e4e4]\");\r\n  price.classList.add(\"border\");\r\n  price.classList.add(\"border-solid\");\r\n  price.classList.add(\"border-blue-500\");\r\n});\r\n\r\ndetails.addEventListener(\"click\", () => {\r\n  details.classList.remove(\"bg-[#e4e4e4]\");\r\n  details.classList.add(\"border\");\r\n  details.classList.add(\"border-solid\");\r\n  details.classList.add(\"border-blue-500\");\r\n});\r\n\r\nconnect.addEventListener(\"click\", async () => {\r\n  console.log(\"Clicked\");\r\n\r\n  if (typeof window.ethereum !== \"undefined\") {\r\n    try {\r\n      const wallets = await window.ethereum.request({\r\n        method: \"eth_requestAccounts\",\r\n      });\r\n\r\n      const connectedWallet = wallets[0];\r\n      connected = true;\r\n\r\n      const isTargetChainId = await checkNetwork(targetChainId);\r\n      if (isTargetChainId === false) await switchNetwork(targetChainId);\r\n\r\n      buttonsContainer.classList.add(\"w-[16rem]\");\r\n      connect.classList.add(\"hidden\");\r\n      await getWalletBalance(connectedWallet);\r\n      listCar.classList.remove(\"hidden\");\r\n      const products = await getCars();\r\n      renderNewCar(products);\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  } else {\r\n    connect.innerHTML = \"Install the Metamask Extension Wallet\";\r\n  }\r\n});\r\n\r\n// const submitNewCar = () => {\r\ndocument.getElementById(\"submit\").addEventListener(\"click\", async (e) => {\r\n  e.preventDefault();\r\n  modalContainer.classList.add(\"hidden\");\r\n  const carMake = name.value.trim();\r\n  const carModel = model.value.trim();\r\n  const _year = year.value.trim();\r\n  const imageUrl = image.value.trim();\r\n  const carPrice = price.value.trim();\r\n  const carDetails = details.value.trim();\r\n\r\n  console.log(carMake, carModel, _year, imageUrl, carDetails, carPrice);\r\n\r\n  const contract = await getContract(\r\n    marketplaceContractAddress,\r\n    marketplaceAbi\r\n  );\r\n\r\n  try {\r\n    showNotification(`Listing ${carMake + \" \" + carModel + \" \" + _year}...`);\r\n    const transactionResponse = await contract.listCar(\r\n      carMake,\r\n      carModel,\r\n      imageUrl,\r\n      _year,\r\n      ethers.parseEther(carPrice),\r\n      carDetails\r\n    );\r\n    await listenForTransactionMine(\r\n      transactionResponse,\r\n      new ethers.BrowserProvider(window.ethereum)\r\n    );\r\n    const products = await contract.getAllListedCars();\r\n    renderNewCar(products);\r\n  } catch (error) {\r\n    console.log(error);\r\n    notification.classList.remove(\"bg-yellow-400\");\r\n    notification.classList.add(\"bg-red-400\");\r\n    notification.innerHTML = \"Transaction Failed\";\r\n  }\r\n});\r\n// };\r\n\r\ndocument.getElementById(\"marketplace\").addEventListener(\"click\", async (e) => {\r\n  if (e.target.className.includes(\"buyBtn\")) {\r\n    const contract = await getContract(\r\n      marketplaceContractAddress,\r\n      marketplaceAbi\r\n    );\r\n    console.log(\"calling buy\");\r\n    try {\r\n      showNotification(`Buying ${e.target.name}...`);\r\n      const transactionResponse = await contract.buyCar({\r\n        value: ethers.parseEther(e.target.price),\r\n        carId: ethers.parseEther(e.target.id),\r\n      });\r\n      await listenForTransactionMine(\r\n        transactionResponse,\r\n        new ethers.BrowserProvider(window.ethereum)\r\n      );\r\n      const products = await contract.getAllListedCars();\r\n      renderNewCar(products);\r\n    } catch (error) {\r\n      console.log(error);\r\n      notification.classList.remove(\"bg-yellow-400\");\r\n      notification.classList.add(\"bg-red-400\");\r\n      notification.innerHTML = \"Transaction Failed\";\r\n    }\r\n  }\r\n});\r\n\r\nconst checkNetwork = async (targetChainId) => {\r\n  try {\r\n    const currentChainId = await window.ethereum.request({\r\n      method: \"eth_chainId\",\r\n    });\r\n    if (currentChainId === targetChainId) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n};\r\n\r\nconst switchNetwork = async (targetChainId) => {\r\n  console.log(\"switch\");\r\n  await window.ethereum.request({\r\n    method: \"wallet_switchEthereumChain\",\r\n    params: [{ chainId: targetChainId }],\r\n  });\r\n\r\n  // refresh webpage\r\n  window.location.reload();\r\n};\r\n\r\nconst getWalletBalance = async (address) => {\r\n  const provider = new ethers.BrowserProvider(window.ethereum);\r\n  const unFormattedBalance = await provider.getBalance(address);\r\n  balance.classList.remove(\"hidden\");\r\n  balanceContainer.classList.add(\"flex\");\r\n  balanceContainer.classList.add(\"justify-center\");\r\n  balanceContainer.classList.add(\"items-center\");\r\n  balance.innerHTML = `Balance: ${Number(\r\n    ethers.formatEther(unFormattedBalance)\r\n  ).toFixed(2)} eth`;\r\n};\r\n\r\nconst renderNewCar = (products) => {\r\n  document.getElementById(\"marketplace\").innerHTML = \"\";\r\n  products.forEach((product) => {\r\n    const [\r\n      carId,\r\n      make,\r\n      model,\r\n      imageUrl,\r\n      year,\r\n      seller,\r\n      price,\r\n      description,\r\n      isSold,\r\n    ] = product;\r\n    const newDiv = document.createElement(\"div\");\r\n    newDiv.className = `border border-solid border-[#d1d1d1] rounded-b-lg ${ethers.formatEther(\r\n      carId\r\n    )}`;\r\n    newDiv.innerHTML = productTemplate(\r\n      carId,\r\n      make,\r\n      model,\r\n      imageUrl,\r\n      year,\r\n      seller,\r\n      price,\r\n      description,\r\n      isSold\r\n    );\r\n    document.getElementById(\"marketplace\").appendChild(newDiv);\r\n  });\r\n};\r\n\r\nconst productTemplate = (\r\n  id,\r\n  make,\r\n  model,\r\n  imageUrl,\r\n  year,\r\n  seller,\r\n  price,\r\n  description,\r\n  isSold\r\n) => {\r\n  if (isSold) {\r\n    return `\r\n    <div class=\"relative w-full\">\r\n    <image\r\n      src=${imageUrl}\r\n      alt=\"\"\r\n      layout=\"responsive\"\r\n      width=\"{300}\"\r\n      height=\"{300}\"\r\n    />\r\n  </div>\r\n  <div class=\"p-5 text-dccm-black\">\r\n    <div class=\"border-b border-solid border-b-[#d9d9d9] pb-4\">\r\n      <div class=\"flex justify-between\">\r\n        <p class=\"font-medium text-[1.25rem]\">${make} ${model} ${year}</p>\r\n        <div class=\"w-[4.8125rem]\">\r\n          <button\r\n            class=\"border border-solid border-[#d1d1d1] w-full py-[0.1875rem] text-sm font-medium rounded-sm hover:bg-green-400 hover:text-white hover:border-0 buyBtn\" id=${id}\r\n          >\r\n            Buy\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"mt-2 flex justify-between\">\r\n        <p class=\"text-[1.25rem] font-bold\">${ethers.formatEther(price)} Eth</p>\r\n        <p>Sold</p>\r\n      </div>\r\n    </div>\r\n    <div class=\"mt-3\">\r\n      ${description}\r\n    </div>\r\n    `;\r\n  } else {\r\n    return `\r\n    <div class=\"relative w-full\">\r\n    <image\r\n      src=${imageUrl}\r\n      alt=\"\"\r\n      layout=\"responsive\"\r\n      width=\"{300}\"\r\n      height=\"{300}\"\r\n    />\r\n  </div>\r\n  <div class=\"p-5 text-dccm-black\">\r\n    <div class=\"border-b border-solid border-b-[#d9d9d9] pb-4\">\r\n      <div class=\"flex justify-between\">\r\n        <p class=\"font-medium text-[1.25rem]\">${make} ${model} ${year}</p>\r\n        <div class=\"w-[4.8125rem]\">\r\n          <button\r\n            class=\"border border-solid border-[#d1d1d1] w-full py-[0.1875rem] text-sm font-medium rounded-sm hover:bg-green-400 hover:text-white hover:border-0 buyBtn\" id=${ethers.formatEther(\r\n              id\r\n            )} price=${ethers.formatEther(price)} name=${make} ${model} ${year}\r\n          >\r\n            Buy\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div class=\"mt-2\">\r\n        <p class=\"text-[1.25rem] font-bold\">${ethers.formatEther(price)} Eth</p>\r\n      </div>\r\n    </div>\r\n    <div class=\"mt-3\">\r\n      ${description}\r\n    </div>\r\n    `;\r\n  }\r\n};\r\n\r\nfunction listenForTransactionMine(transactionResponse, provider) {\r\n  notification.innerHTML = `Mining ${transactionResponse.hash}...`;\r\n\r\n  return new Promise((resolve, reject) => {\r\n    provider.once(transactionResponse.hash, (transactionReceipt) => {\r\n      notification.innerHTML = \"Transaction completed\";\r\n      resolve();\r\n    });\r\n  });\r\n}\r\n\r\nconst getCars = async () => {\r\n  const contract = await getContract(\r\n    marketplaceContractAddress,\r\n    marketplaceAbi\r\n  );\r\n  const products = await contract.getAllListedCars();\r\n  return products;\r\n};\r\n\r\nconst getContract = async (contractAddress, contractAbi) => {\r\n  try {\r\n    const provider = new ethers.BrowserProvider(window.ethereum);\r\n    const signer = await provider.getSigner();\r\n    const contract = new ethers.Contract(contractAddress, contractAbi, signer);\r\n\r\n    return contract;\r\n  } catch (error) {\r\n    console.log(error);\r\n  }\r\n};\r\n\r\nconst showNotification = (notificationText) => {\r\n  notification.classList.add(\"bg-yellow-400\");\r\n  notification.classList.add(\"flex\");\r\n  notification.classList.remove(\"hidden\");\r\n  notification.innerHTML = notificationText;\r\n};\r\n"],"names":[],"sourceRoot":""}